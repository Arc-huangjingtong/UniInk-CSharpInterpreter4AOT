<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.Core</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Util.Concurrency.ReaderWriterSlimWrapper">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Concurrency.UpgradableReadWriteLock"/> based on <see cref="T:System.Threading.ReaderWriterLockSlim"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.AffinalReaderWriterSlimWrapper">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Concurrency.ReadWriteLock"/> that only allows
            to take an upgradable read lock on a dedicated thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.AffinalReaderWriterSlimWrapper.#ctor(System.Threading.Thread)">
            <summary>
            Support upgrade on provided thread only
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.ConcurrentArray`1">
            <summary>
            Rather ineffective on modification (memory traffic O(n^2)), but no overhead on reading
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific">
            <summary>
            Non-thread-bound part of the dispatcher platform-specific implementation. This is exposed with static methods on the <see cref="T:JetBrains.Threading.JetDispatcher" /> class.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.CreatePlatformDispatcherImpl">
            <summary>
            Creates platform-specific, non-thread-bound implementation of the entity actually deferring the execution.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.CreateDispatcherTimer">
            <summary>
            Creates platform-specific dispatcher timer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.CreateDispatcherTimer(System.Int32)">
            <summary>
            Creates platform-specific dispatcher timer.
            </summary>
            <param name="interval">Interval in milliseconds</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.PumpMessagesOnce">
            <summary>
            Pumps all the messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific.Run">
            <summary>
            Employs the current thread.
            Pumps the messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown" /> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.MessageLoopStatus">
            <summary>
            Message loop break reason.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.MessageLoopStatus.DispatcherImplShutdown">
            <summary>
            DispatcherImplShutdown has been shutdown.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.MessageLoopStatus.Error">
            <summary>
            Unhandled exception has been raised during an action invocation.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.MessageLoopStatus.Condition">
            <summary>
            Exit condition has been met.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.MessageLoopStatus.Timeout">
            <summary>
            Timeout has been elapsed.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixDispatcherImpl.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure)">
            <summary>
            Actually schedules deferred invocation of the action.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixDispatcherImpl.UnixDispatcherPlatformSpecific.PumpMessagesOnce">
            <summary>
            Pumps all the Windows messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixDispatcherImpl.UnixDispatcherPlatformSpecific.Run">
            <summary>
            Employs the current thread.
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown"/> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixDispatcherImpl.UnixDispatcherPlatformSpecific.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout"/> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnixDispatcherImpl.UnixDispatcherPlatformSpecific.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition"/> is true, but for at most <paramref name="timeout"/> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout"/> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinDispatcherImpl.myPreTranslates">
            <summary>
            Custom message translators that could be registered on the fly, and will be executed before the standard message procesing.
            </summary>
            <remarks>The collection is copy-on-write.</remarks>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.Init(JetBrains.Threading.JetDispatcher)">
            <summary>
            Init the instance (activities not related to the registration of this instance).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.RegisterPreTranslate(JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Interop.WinApi.MSG,System.Boolean})">
            <summary>
            Register a custom Windows message processor and put it at the beginning of the handler list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.myControlInstanceForStaticMethods">
            <summary>
            There're static methods that require a control this.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.InternalPumpMessagesOnce">
            <summary>
            Implements a custom message pump for pumping all of the messages currently in the queue.
            </summary>
            <returns>The number of messages pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.InternalWaitForMessages(System.UInt32)">
            <summary>
            Waits until there are messages in the queue, for the <paramref name="timeout" /> milliseconds at most (-1 to wait infinitely).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.ourHwndSourceFromHwndMethod">
            <summary>
            (DK) To avoid referencing PresentationCore use reflection to call HwndSource.FromHwnd() method.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.PumpMessagesOnce">
            <summary>
            Pumps all the Windows messages (and async actions) currently on the queue, and terminates.
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.JetBrains#Util#Concurrency#IJetDispatcherPlatformSpecific#Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.JetBrains#Util#Concurrency#IJetDispatcherPlatformSpecific#Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but for at most <paramref name="timeout" /> period of time.
            Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.JetBrains#Util#Concurrency#IJetDispatcherPlatformSpecific#Run">
            <summary>
            Employs the current thread.
            Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="!:BeginInvokeShutdown" /> is invoked for this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.WinDispatcherImpl.WindowsDispatcherPlatformSpecific.ToWinFormsMessage(JetBrains.Interop.WinApi.MSG)">
            <summary>
            TODO: a copy of a method from UI Interactive Windows. Should be externalized when we split basic WinAPI dispatcher and its WinForms/Avalon integrations.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.WaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET
            </summary>
            <return>true if event was SET, false if timeout expired</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.MsgWaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET or new message is appeared in queue
            </summary>
            <return>true if event was SET, false if timeout expired, null if new message is appeared in queue</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.WaitOne">
            <summary>
              Waiting for event to be SET
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Events.IEventWaitHandle.MsgWaitOne">
            <summary>
              <return>true if event was SET, false if new message is appeared in queue</return>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ExecutionContextEx.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)">
            <summary>
            The same as <see cref="T:System.Threading.ExecutionContext"/>.<see cref="M:System.Threading.ExecutionContext.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)"/> but allows <c>null</c> value for <paramref name="context"/> parameter.
            <see cref="T:System.Threading.ExecutionContext"/>.<see cref="M:System.Threading.ExecutionContext.Capture"/> may return <c>null</c> when <see cref="T:System.Threading.ExecutionContext"/>.<see cref="M:System.Threading.ExecutionContext.IsFlowSuppressed"/> is <c>true</c>   
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ExecutionContextEx.Run(System.Threading.ExecutionContext,System.Action)">
            <inheritdoc cref="M:JetBrains.Util.Concurrency.ExecutionContextEx.Run(System.Threading.ExecutionContext,System.Threading.ContextCallback,System.Object)"/>
        </member>
        <member name="T:JetBrains.Util.Concurrency.FrugalLocalLazy`1">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> and <see cref="T:JetBrains.Util.Concurrency.LocalLazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>This class only supports creating reference types with default constructors in a thread-unsafe manner, but its added memory usage is exactly zero (it takes as much space in the containing class as a field with a reference to the lazily-created value would do).</para>
            <para>For use in private fields only. Do not expose! Assigning this object to any variables breaks the pattern.</para>
            </summary>
            <typeparam name="T">Specifies the type of element being laziliy initialized.</typeparam>
        </member>
        <member name="M:JetBrains.Util.Concurrency.GroupingEventHostEx.QueueAtShort(JetBrains.Threading.GroupingEventHost,JetBrains.Lifetimes.Lifetime,System.String,System.TimeSpan,System.Action)">
            <summary>
            <para>Queues the action to execute once on the <paramref name="host"/>.<see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>.<see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread when the timeout elapses.</para>
            <para>Handles intervals smaller than <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/> only.</para>
            <para>Returns a token that cancels the action execution. The token disposal is optional.</para>
            <para>The execution will be either guarded or not, depending on the presence of <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/> property value.</para>
            </summary>
            <param name="host"><c>this</c></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="interval">A non-negative time interval.</param>
        </member>
        <member name="T:JetBrains.Util.Concurrency.InterruptibleLazy`1">
            <summary>
            The problem with <see cref="T:System.Lazy`1"/> is that in case of exception thrown during calculation, this exception is cached and all following invokations will throw exactly the same exception.
            So in case we want to interrupt calculation of lazy with OCE and than calculate real value by following invocation, we should use this class.   
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Concurrency.JetConcurrentQueue`1">
            <summary>
            Concurrent blocking queue with predefined size. All operations are thread safe. Operations like <code>ToArray</code> or <code>GetEnumerator</code>
            takes queue snapshot at some moment.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.#ctor(System.Int32)">
            <summary>
            Constructs queue with predefined size. Queue size is defined logarithmically. Queue is not growing, nor shrinking.
            </summary>
            <param name="logMaxSize">From 1 to 20. Real queue size will be 1&lt;&lt;<see cref="!:logMaxSize"/>.</param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryAdd(`0)">
            <summary>
            Enqueues to the tail of the queue. Increases tail.
            </summary>
            <param name="t"></param>
            <returns></returns>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)">
            <summary>
            Dequeues from the head of the queue. Moves head.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)">
            <summary>
            Peeks from the head of the queue. Leaves head untouched. Sequential peeks will return same result if no other thread dequeues or clears simultaneously.
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Count">
            <summary>
            Number of elements in queue snapshot.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Concurrency.JetConcurrentQueue`1.SyncRoot">
            <summary>
            Not real SyncRoot, but you can use it for external synchronization
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryTake(`0@)">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/>. Implementation of <see cref="M:System.Collections.Concurrent.IProducerConsumerCollection`1.TryTake(`0@)"/>
            </summary>
            <param name="res"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Dequeue">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/> but returns <code>null</code> <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryDequeue(`0@)"/> returns false
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.Peek">
            <summary>
            Same as <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)"/> but returns <code>null</code> when <see cref="M:JetBrains.Util.Concurrency.JetConcurrentQueue`1.TryPeek(`0@)"/> returns false
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Concurrency.JetThreadApartment">
            <summary>
            Thread Apartments APIs wrapper for compatibility with .NET Core on Unix.
            On platforms with native thread apartment model support (.NET Framework, .NET Core WindowsDesktop.App) it's just a proxy to platform APIs
            and on other platforms it emulates STA threads for our Dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetThreadApartment.STAThread">
            <summary>
            Emulates <see cref="T:System.STAThreadAttribute"/> on platforms without native thread apartment model support.
            Must be called only from methods marked with <see cref="T:System.STAThreadAttribute"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetThreadApartment.SetJetApartmentState(System.Threading.Thread,System.Threading.ApartmentState)">
            <inheritdoc cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)"/>
            <summary>
            Use this method instead of <see cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.JetThreadApartment.GetJetApartmentState(System.Threading.Thread)">
            <inheritdoc cref="M:System.Threading.Thread.GetApartmentState"/>
            <summary>
            Use this method instead of <see cref="M:System.Threading.Thread.GetApartmentState"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LocalLazy`1">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>Note that if you're passing a factory function and it's a closure, a new reference object is created for it per each instance. To avoid this, you can use <see cref="T:JetBrains.Util.Concurrency.LocalLazy`2"/>.</para>
            </summary>
            <typeparam name="TValue">Specifies the type of element being laziliy initialized.</typeparam>
        </member>
        <member name="F:JetBrains.Util.Concurrency.LocalLazy`1.myFlags">
            <summary>
            Mode and state data packed into a single int for less space.
            LazyExecutionMode values and Flag* fields.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LocalLazy`1.#ctor(JetBrains.Util.Concurrency.LazyExecutionMode)">
            <summary>
            Creates the value on-demand using the default constructor.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LocalLazy`1.#ctor(System.Func{`0},JetBrains.Util.Concurrency.LazyExecutionMode)">
            <summary>
            Creates the value on-demand with the user-supplied factory.
            See <see cref="T:JetBrains.Util.Concurrency.LocalLazy`2"/> if you want to pass a parameter to the factory lambda without allocating a closure for each instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LocalLazy`1.#ctor(`0)">
            <summary>
            Just wraps an already-created value.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LocalLazy`2">
            <summary>
            <para>Provides support for several common patterns of lazy initialization, including the ability to initialize value types and to use null values.</para>
            <para>This is a frugal version of <see cref="T:System.Lazy`1"/> that does not create any objects until the lazy value is initialized to a reference type.</para>
            <para>The difference from <see cref="T:JetBrains.Util.Concurrency.LocalLazy`1"/> is that you don't have to create a new closure for the factory function with each call. Instead, you can pre-cache a function taking a parameter and pass the parameter into this struct separately. This way no reference types are created per instance until it's time to instantiate your object.</para>
            </summary>
            <typeparam name="TValue">Specifies the type of element being laziliy initialized.</typeparam>
            <typeparam name="TFactoryParameter">Type of the parameter passed to the factory function.</typeparam>
        </member>
        <member name="F:JetBrains.Util.Concurrency.LocalLazy`2.myFlags">
            <summary>
            Mode and state data packed into a single int for less space.
            LazyExecutionMode values and Flag* fields.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.LockableObject`1">
            <summary>
            An object instance with access protected with a lock.
            To get the protected instance, call <see cref="M:JetBrains.Util.Concurrency.LockableObject`1.UsingLock" /> with a <c>using</c> construct, and read its <see cref="P:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Value" />.
            To make such an object, define a lock as <see cref="T:JetBrains.Util.Concurrency.LockObject" />, and wrap some value with <see cref="M:JetBrains.Util.Concurrency.LockObject.MakeLockableObject``1(``0,System.TimeSpan)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockableObject`1.UsingLock">
            <summary>
            Takes the lock and returns the object thru which you can access the locked value.
            </summary>
            <returns>A disposable object which (a) MUST be disposed of when done (preferrably, with a <c>using</c>); (b) gives access to the protected object in <see cref="P:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Value" />.</returns>
            <seealso cref="M:JetBrains.Util.Concurrency.LockObject.UsingLockFor``1(``0,System.TimeSpan)" />
        </member>
        <member name="T:JetBrains.Util.Concurrency.LockObject">
            <summary>
            When you need to create an instance of some object to <c>lock</c> against it (<see cref="M:System.Threading.Monitor.Enter(System.Object)" />), use this class.
            It has an additional method for entering the lock with a timeout (throwing an exception if failed).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockObject.MakeLockableObject``1(``0,System.TimeSpan)">
            <summary>
            Makes a wrapper for an object which can only be accessed under a lock.
            To get the protected instance, call <see cref="M:JetBrains.Util.Concurrency.LockableObject`1.UsingLock" /> with a <c>using</c> construct, and read its <see cref="P:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Value" />.
            If you do not expose the value to your clients directly but only thru this wrapper, then it helps them take the locks correctly with minimal overhead.
            </summary>
            <param name="value">The value protected by the lock. Clients will be able to read it until the lock is released.</param>
            <param name="timeout">A timeout for waiting on the lock, turns a potential deadlock into an exception, which often saves the program from a complete hand. <see cref="F:System.TimeSpan.MaxValue" /> is a special value which does not set a timeout for the wait.</param>
            <returns>A wrapper object. No special handling requirements for it.</returns>
            <seealso cref="M:JetBrains.Util.Concurrency.LockObject.UsingLockFor``1(``0,System.TimeSpan)" />
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockObject.UsingLock(System.TimeSpan)">
            <summary>
            Takes a lock. If the timeout expires before the lock can be acquired, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockObject.UsingLockFor``1(``0,System.TimeSpan)">
            <summary>
            Takes a lock. If the timeout expires before the lock can be acquired, throws an exception.
            Exposes the given <paramref name="value" /> to the clients.
            If you do not expose the value to your clients directly but only thru this method, then it helps them take the locks correctly with minimal overhead.
            See <see cref="M:JetBrains.Util.Concurrency.LockObject.MakeLockableObject``1(``0,System.TimeSpan)" /> for a wrapper with similar functionality.
            </summary>
            <param name="value">The value protected by the lock. Clients will be able to read it until the lock is released.</param>
            <param name="timeout">A timeout for waiting on the lock, turns a potential deadlock into an exception, which often saves the program from a complete hand. <see cref="F:System.TimeSpan.MaxValue" /> is a special value which does not set a timeout for the wait.</param>
            <returns>A disposable object which (a) MUST be disposed of when done (preferrably, with a <c>using</c>); (b) gives access to the protected object in <see cref="P:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Value" />.</returns>
            <seealso cref="M:JetBrains.Util.Concurrency.LockObject.MakeLockableObject``1(``0,System.TimeSpan)" />
        </member>
        <member name="M:JetBrains.Util.Concurrency.LockObject.Locked.Dispose">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeEvent">
            <summary>
              This class just uses WaitForSingleObject directly to work around unwanted consequences of
              message pumping that may happen while doing WaitHandle.WaitOne. It is not intended to implement
              all the functionality that WaitHandle possess.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.WaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET
            </summary>
            <return>true if event was SET, false if timeout expired</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.MsgWaitOne(System.Int32)">
            <summary>
              Waiting for event to be SET or new message is appeared in queue
            </summary>
            <return>true if event was SET, false if timeout expired, null if new message is appeared in queue</return>
            <param name="timeout"></param>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.WaitOne">
            <summary>
              Waiting for event to be SET
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.NativeEvent.MsgWaitOne">
            <summary>
              <return>true if event was SET, false if new message is appeared in queue</return>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeManualEvent">
            <summary>
              External API for events, named NativeManualEvent for compat. reasons
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.NativeAutoEvent">
            <summary>
              External API for events, named NativeAutoEvent for compat. reasons
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.ObjectWithLockTaken`1">
            <inheritdoc cref="M:JetBrains.Util.Concurrency.LockObject.UsingLockFor``1(``0,System.TimeSpan)" />
        </member>
        <member name="M:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.#ctor(JetBrains.Util.Concurrency.LockObject,`0,System.TimeSpan@)">
            <summary>
            Takes the lock or throws.
            Timeout does not work when under debugger.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Value">
            <summary>
            Gets the value if lock is currently held. Otherwise, throws.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ObjectWithLockTaken`1.Dispose">
            <summary>
            Releases the lock. Do not call multiple times; it tries to check for multiple calls, but, being a struct, this does not work when copied byvalue.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the writer lock. If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the writer lock. If the time limit expires, throws an exception.
            Exits the writer lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingWriteLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            For high performance code. No lambda and heap allocation.
            </summary>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterReadLock(System.Threading.ReaderWriterLockSlim,System.Int32)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            NOTE: this overload takes milliseconds for perf because it's what the library method uses internally.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock. If the time limit expires, throws an exception.
            Exits the reader lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingReadLock(System.Threading.ReaderWriterLockSlim)">
            <summary>
            For high performance code. No lambda and heap allocation.
            </summary>    
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock upgradeable to writer lock (by a nested <see cref="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)"/> request). If the time limit expires, throws an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.UsingUpgradeableReadLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)">
            <summary>
            Enters the reader lock upgradeable to writer lock (by a nested <see cref="M:JetBrains.Util.Concurrency.ReaderWriterLockSlimEx.EnterWriteLock(System.Threading.ReaderWriterLockSlim,System.TimeSpan)"/> request). If the time limit expires, throws an exception.
            Exits the reader lock when you dispose of the return value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.ReentrantWriterPreferenceReadWriteLock.WriterLock.TryAcquire(System.Int32)">
            <summary>
            Try to acquire write lock
            </summary>
            <param name="timeout"></param>
            <remarks>
            Zero timeout means that we don not wait and we have only one attempt to fetch write lock, and we don not hope
            to acquire write lock in case of active reader locks in other threads, so we do not change the value of
            AccessRequested to not interrupt readers.
            Otherwise, at any timeout value greater than zero we set
            AccessRequested to true and readers have a chance to interrupt before timeout elapse.
            Any timeout value less than zero will lead to infinite waiting with AccessRequested set to true, <see cref="M:JetBrains.Util.Concurrency.ReentrantWriterPreferenceReadWriteLock.WriterLock.Acquire"/>
            </remarks>
            <returns>true in case of successfully acquired lock, otherwise false</returns>
        </member>
        <member name="T:JetBrains.Util.Concurrency.SpinWaitLockRef">
            <summary>
            A reference wrapper for the <see cref="T:JetBrains.Threading.SpinWaitLock"/> for those usages that don't mind creating a new object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Enter">
            <summary>
            Locks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Exit">
            <summary>
            Unlocks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Push">
            <summary>
            Pushes an <see cref="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Enter"/>/<see cref="M:JetBrains.Util.Concurrency.SpinWaitLockRef.Exit"/> bracket.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.Threading.SequentialScheduler">
            <summary>
            Lightweight task scheduler that executes items sequentially on a passed scheduler
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.Threading.Tasks.SchedulerAwaiter">
            <summary>
            Yields' implementation.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Concurrency.Threading.Tasks.SchedulerAwaiter.IsCompleted">
            <summary>
            This asks if the stuff could be executed inplace without scheduling, never true for a yielder.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Threading.Tasks.SchedulerAwaiter.GetResult">
            <summary>
            The action given to awaiter MUST be executed no matter what; this is the place where we should report cancelations and failures.
            We cannot track failures on a value type I'm afraid, but the cancelations we can do. And should.
            </summary>
            <exception cref="T:System.Threading.Tasks.TaskCanceledException"></exception>
        </member>
        <member name="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool">
             <summary>
             Adornment to system <see cref="T:System.Threading.ThreadPool"/> that allows never suffer from threads exhaustion.<br/>
            
             Problem: <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will NOT start your
             action on a background thread immediately IF all available threads are occupied. System
             pool has a growth strategy and it depends on framework. NETFramework adds new thread to available ones
             every 1 second.<br/>
            
             Solution: Use <see cref="M:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool.Queue(System.Action)"/> to enqueue action that will be scheduled to system pool and if job isn't started
             after <see cref="P:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool.TimeoutUntilNewThreadMs"/> (default: 50ms) new thread will be created.<br/>
            
             Caution: You must catch exceptions in queued actions by yourself (the same for system ThreadPool).<br/>
             
             Implementation details:
             - It's guaranteed that action will be executed once and only once.
             - All internal algorithms are non-blocking wait-free (<see cref="T:System.Collections.Concurrent.ConcurrentQueue`1"/> is used and it's lock-free)
             - Algorithms try to null memory as fast as possible, so GC load mustn't be high
             - Special infinite running "Controller" thread is started first time you access <see cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool"/>
              - All internally created threads has <c>IsBackground == true</c> and <c>Name</c> starts with "UnlimitedPool" 
             </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool.Queue(System.Action)">
            <summary>
            Queue action to execute on background
            </summary>
            <param name="action">Action to execute. You must try/catch exceptions inside action by yourself (as in <see cref="T:System.Threading.ThreadPool"/>) </param>
            <exception cref="T:System.ArgumentNullException">if action is null</exception>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool.SetTimeoutUntilNewThreadCreated(JetBrains.Lifetimes.Lifetime,System.Int32)">
            <summary>
            Change <see cref="P:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool.TimeoutUntilNewThreadMs"/> until lifetime terminates
            </summary>
            <param name="lifetime"></param>
            <param name="newTimeoutMs"></param>
        </member>
        <member name="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler">
            <summary>
            Special <see cref="T:System.Threading.Tasks.TaskScheduler"/> that guarantees that enqueued task will be executed as fast as possible on
            a system thread pool or (if pool is exhausted) on dedicated thread.
            <seealso cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPool"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer">
            <summary>
            A timer which executes its callback method on a thread pool thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.#ctor(JetBrains.Lifetimes.Lifetime,System.Action,System.Boolean)">
            <summary>
            Initializes a new instance of the timer. The timer is not started.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.#ctor(JetBrains.Lifetimes.Lifetime,System.TimeSpan,System.Action,System.Boolean)">
            <summary>
            Initializes a new instance of the timer and start it with the specified period.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.#ctor(JetBrains.Lifetimes.Lifetime,System.TimeSpan,System.TimeSpan,System.Action,System.Boolean)">
            <summary>
            Initializes a new instance of the timer and start it within the specified time and with the specified period.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.Start(System.TimeSpan)">
            <summary>
            Start or restart the timer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.Stop">
            <summary>
            Stop the timer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.Timer.ThreadPoolTimer.Change(System.TimeSpan,System.TimeSpan)">
            <summary>
            Changes the start time and the interval between callback invocations.
            </summary>
            <param name="duetime">The delay before invoking the callback. Specify negative one (-1) milliseconds to prevent the timer from restarting. Specify zero (0) to restart the timer immediately.</param>
            <param name="period">The interval between invocations of the callback method. Specify negative one (-1) milliseconds to disable periodic signaling.</param>
        </member>
        <member name="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger">
            <summary>
            <para>Allows to join expected callbacks from unguarded context into the current guarded context.</para>
            <para>When running in the guarded context, nest the actions that might cause callbacks from unguarded context within a <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> call. <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> will come <c>True</c>.</para>
            <para>In the callback handler, use <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)"/>. If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/>, it will be merged into the current guarded context (this is considered a reentrant-safe activity). Otherwise, <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> will be used.</para>
            <para>Can be reused.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.ReentrancyGuard,JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags)">
            <summary>
            Init.
            </summary>
            <param name="lifetime"></param>
            <param name="guard">Identifies the thread.</param>
            <param name="flags">Behavior flags &amp; options.</param>
        </member>
        <member name="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback">
            <summary>
            Whether we're inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)">
            <summary>
            <para>Executes the <paramref name="F"/> in the guarded context.</para>
            <para>If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> (ie running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>), merges the call into the current guarded context. Otherwise, does the regular <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>Executes sync or async. Must be run on the <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> thread.</para>
            <para>Catches all exceptions.</para>
            <para>The lifetime of this schedulled request is limited by the lifetime of this unguarded callbacks merger.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(JetBrains.Lifetimes.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes the <paramref name="F"/> in the guarded context.</para>
            <para>If <see cref="P:JetBrains.Util.Concurrency.UnguardedCallbackMerger.IsExpectingUnguardedCallback"/> (ie running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>), merges the call into the current guarded context. Otherwise, does the regular <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>Executes sync or async. Must be run on the <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> thread.</para>
            <para>Catches all exceptions.</para>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)">
            <summary>
            <para>Says that we're expecting callbacks from the unguarded context, and they should be allowed into the current context if they use <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExecuteOrQueueOrMerge(System.String,System.Action)"/>.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags">
            <summary>
            <see cref="T:JetBrains.Util.Concurrency.UnguardedCallbackMerger"/> behavior aspects.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.ExecutePendingLeftovers">
            <summary>
            <para>Use the default <see cref="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ReentrancyGuard"/> behavior: if the callbacks were queued for execution with <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>, they're not reclaimed after the owning object is disposed of, and will still have a chance to execute.</para>
            <para>This is the default.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.DropPendingLeftovers">
            <summary>
            <para>If there're any pending callbacks queued for execution with <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> at the moment the owning object is disposed of, they're dropped.</para>
            <para>No code submitted through this object will execute after it is disposed of.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.ProhibitNestedExpectations">
            <summary>
            <para>When running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>, nested calls to <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> are prohibited. An attempt to place such a call will result in an exception.</para>
            <para>This is the default.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Concurrency.UnguardedCallbackMerger.BehaviorFlags.AllowNestedExpectations">
            <summary>
            <para>When running inside <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/>, nested calls to <see cref="M:JetBrains.Util.Concurrency.UnguardedCallbackMerger.ExpectUnguardedCallback(System.Action)"/> are allowed.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.RawCircularBufferHeader">
            <summary>
              Implements a raw circular buffer which is attached to an existing memory pointer (e.g. to work on some shared memory).
            </summary>
            <remarks>
              Strategy: manages allocation of sequential memory chunks called messages.
              <see cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.TotalSize" /> is the total available space of the buffer. <see cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.BufferHeaderSize" /> bytes in the beginning are occupied by this header structure.
              The remaining memory is either empty, or occupied by a single contiguous used block of messages (
              <see
                cref="F:JetBrains.Util.dataStructures.RawCircularBufferHeader.BlockHead" />
              ), or by two contiguous blocks after the content wraps over the buffer end.
              Possible layouts:
              [header] {head} -empty-                       // just started writing
              [header] -empty1- {head} -empty2-             // read some first messages of the written
              [header] {head} -empty1- {tail} -empty2-      // attempted writing new messafe after {head}, there were not enough space till the end of the buffer, so we wrapped head to the beginning (there's small -empty2- because we do not break messages when wrapping around the buffer, message memory is always contiguous)
              and then it goes all around
            </remarks>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RawCircularBufferHeader.FreeSpace">
            <summary>
              The available free space at this moment.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RawCircularBufferHeader.MaxDataSize">
            <summary>
              Maximum payload size (that's max free space minus the message header).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryReadMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*,System.Action{JetBrains.Util.dataStructures.ByteBuffer})">
            <summary>
              Reads the message, if any present, and invokes the callback. Returns whether there was any message to invoke the callback with.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryReadMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*)">
            <summary>
              Reads the message, if any present. If not, yields <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RawCircularBufferHeader.TryWriteMessage(JetBrains.Util.dataStructures.RawCircularBufferHeader*,System.Byte[])">
            <summary>
              Tries to write message, returns <c>False</c> if there's no space left.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ChunkedMemoryStream">
            <summary>
            A stream that resides in memory and allocates more chunks of data instead of reallocating the large continuous chunk.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myBuffers">
            <summary>
            Chunk buffers (non-zero-length only  required for index two-way translation).
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCachedCurrentBuffer_Index">
            <summary>
            With multiple small calls to Read or Write, caches the last-used current buffer and avoids costly calls into a chunk list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCachedCurrentBuffer_Value">
            <summary>
            With multiple small calls to Read or Write, caches the last-used current buffer and avoids costly calls into a chunk list.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferIndex">
            <summary>
            The buffer from <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myBuffers" /> the <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myPositionIncludingStartOffset" /> is currently in. "Before first byte" is preferred to "After last byte" (even if at end of stream). Could be equal to number of buffers (eg pointing beyond the end of list of buffers)  when exactly at the end of the stream.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferOffset">
            <summary>
            Offset of the <see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myPositionIncludingStartOffset" /> from the beginning of its current buffer (<see cref="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.myCurrentBufferIndex" />).
            Shouldn't be equal to current buffer length (should be zero in the next buffer instead).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.#ctor">
            <summary>
              <para>Allocates the new stream which will grow as you write.</para>
              <para>When done writing, you can <see cref="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.Freeze" /> the stream to prevent subsequent modification by consumers.</para>
              <para>If you want multiple consumers to read the frozen stream without interrupting one another, give them individual lightweight instances produced with <see cref="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ShallowClone" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.#ctor(JetBrains.Util.DataStructures.ChunkList{System.Byte[]},System.Int64,System.Int64,JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags,System.UInt64)">
            <summary>
            Clone ctor.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.ChunkedMemoryStream.Guid">
            <summary>
            The unique identifier of this breed of cloned streams.
            New for each new stream. Same in all cloned instances.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.AsImmutable">
            <summary>
            Wraps with an immutable interface. Must be frozen already.
            The current position in the stream is NOT passed to the immutable instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffers(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Int32)">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>No guarantees are provided for innutability of the buffers' contents, so the stream is neither <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen" /> nor can it ever be frozen.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffers(System.Byte[][])">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>No guarantees are provided for innutability of the buffers' contents, so the stream is neither <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen" /> nor can it ever be frozen.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffersGuaranteedImmutable(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Int32)">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.CreateOnUserBuffersGuaranteedImmutable(System.Byte[][])">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed <see cref="P:JetBrains.Util.Collections.IFreezable.IsFrozen" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.Freeze">
            <summary>
            Fluent version of <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ReadByte">
            <summary>
            An optimized func for reading just one byte; without it, base impl might go into allocations on every read.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ShallowClone">
            <summary>
              <para>Makes a lightweight clone which only creates a copy of the wrapper class, but reuses the whole same buffers.</para>
              <para>The current stream must be frozen.</para>
              <para>This way you can have multiple readers over the same data without their interfering with each other's position and yet without wasting memory.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ToArray">
            <summary>
            Returns the array contents, trimming any excess storage.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.TrimExcess">
            <summary>
            Works similarly to <see cref="M:System.Collections.Generic.List`1.TrimExcess" />.
            Frees the unused buffers, but does not free the unused leftovers of the last buffer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.GetBufferAndOffsetOfPosition(System.Int64,System.Int32@,System.Int32@)">
            <summary>
            Gets the buffer and offset in it where the <paramref name="lPositionIncludingStartOffset" /> falls.
            Offset can be zero and never can be equal to the length of the buffer. At the very end, the buffer index is equal to the number of buffers.
            Throws when the length is outside the buffers span.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.TryGetBufferAndOffsetOfPosition(System.Int64,System.Int32@,System.Int32@)">
            <summary>
            Gets the buffer and offset in it where the <paramref name="lPositionIncludingStartOffset" /> falls.
            Offset can be zero and never can be equal to the length of the buffer. At the very end, the buffer index is equal to the number of buffers.
            Returns <c>-1</c> of OK and the total max length of the buffers-allocated space (including start offset) if the position does not fall within the allocated space.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream">
            <summary>
            Wrap the chunked memory stream as an immutable byte stream. Must be frozen.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.Length">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.Position">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ChunkedMemoryStream.ImmutableChunkedMemoryStream.WithNoLifetime">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsOnUserBuffers">
            <summary>
            Whether we're running on user buffers (as passed to ctor) and should not be modifying them.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsFrozen">
            <summary>
            <see cref="M:JetBrains.Util.Collections.IFreezable.Freeze" /> has been called.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ChunkedMemoryStream.StateFlags.IsCloned">
            <summary>
            Tracking flag for clones.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2">
            <summary>
              <para>Mapping from one family of objects into another and vice versa.</para>
              <para>Uses the runtime <see cref="T:System.Collections.Generic.Dictionary`2" /> for storage. As compared to the <code>BidirectionalMapOnCompactMap{TLeft,TRight}</code>, this is a few times faster. With large amounts of memory it will use more mem (and might get into LOH).</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Count">
            <summary>
            Get the number of mappings.
            As we implement the identity mapping, the number of items on both sides is always in sync.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Add(`0,`1)">
            <summary>
            Adds a new mapping to the map. Both ends must be unique in their maps.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.RemoveMapping(`0,`1)">
            <summary>
            Removes mapping if exists.
            If left/right element doesn't refer to right/left then error will be logged without removing and exception throwing.
            </summary>
            <param name="left"></param>
            <param name="right"></param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.SetMapping(`0,`1,System.Boolean)">
            <summary>
            Adds a new mapping to the map. You should use <see cref="M:JetBrains.Util.dataStructures.BidirectionalMapOnDictionary`2.Add(`0,`1)" /> whenever possible, as it throws on dpulicate keys.
            </summary>
            <param name="left">Left key.</param>
            <param name="right">Right key.</param>
            <param name="bIgnoreConflicts">Whether to ignore duplicate keys in left and right collections silently. Not recommended. The conflicting mappings will be dropped.</param>
        </member>
        <member name="T:JetBrains.Util.dataStructures.OfEqualItems">
            <summary>
            If there're multiple equal items in the list, which one of them should be taken for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeAny">
            <summary>
            If there're multiple equal items in the list, take any of them for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeFirst">
            <summary>
            If there're multiple equal items in the list (must be contiguous in a sorted list), take the lowest-index one for a hit.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.OfEqualItems.TakeLast">
            <summary>
            If there're multiple equal items in the list (must be contiguous in a sorted list), take the highest-index one for a hit.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.EnumeratorWithReadWriteLock`1">
            <summary>
            Wraps an enumerable (or enumerator) with <see cref="T:System.Threading.ReaderWriterLockSlim"/> to be able to interrupt/ materialize enumerable when write lock is requested 
            </summary>
            <typeparam name="T">Type of the items to be enumerated</typeparam>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalList`1">
            <summary>
              <para>A frugal version of a generic variable-size list.</para>
              <para>Properties:</para>
              <para> Is a value type (non-POD though), thus merges into the memory of the owning type.</para>
              <para> Stores first <see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount" /> items within own memory.</para>
              <para> Stores the remaining items, if any, in a dynamic list. If there aren't any more items, the dynamic list is not created.</para>
              <para> Does not create any new objects when there are just <c>0</c>,<c>1</c>...<see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount" /> items in the list.</para>
              <para>Memory: <see cref="F:JetBrains.Util.dataStructures.FrugalLocalList`1.LocalItemsCount" /> pointers for first items, plus one pointer for the lazily-created list of remaining items items.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsIList">
            <summary>
              <para>Boxes this value type and returns the custom box object which implements a readonly <see cref="T:System.Collections.Generic.IList`1" />.</para>
              <para>The box PARTIALLY reflects modifications in the original structure. To create a full copy, use <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList" /> or <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToArray" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsIReadOnlyList">
            <summary>
              <para>Boxes this value type and returns the custom box object which implements a readonly <see cref="T:System.Collections.Generic.IList`1" />.</para>
              <para>The box PARTIALLY reflects modifications in the original structure. To create a full copy, use <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList" /> or <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToArray" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.GetEnumerator">
            <summary>
            Allows to enumerate the list in language constructs like C# <c>foreach</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList`1.ToList">
            <summary>
              <para>Creates a new <see cref="T:System.Collections.Generic.List`1" /> with the items.</para>
              <para>Calling the <see cref="M:JetBrains.Util.dataStructures.FrugalLocalList`1.AsIList" /> ext method would just box the existing <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1" /> instance with a readonly interface.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.Create``1">
            <summary>Creates an empty list.</summary>
            <typeparam name="T">The type of elements stored in the list.</typeparam>
            <returns>An empty list.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.Create``1(``0)">
            <summary>Creates a list that contains the specified object.</summary>
            <param name="item">The object to store in the list.</param>
            <typeparam name="T">The type of elements stored in the list.</typeparam>
            <returns>A list that contains the specified object.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.Create``1(``0,``0)">
            <summary>Creates a list that contains the specified objects.</summary>
            <param name="item1">The first object to store in the list.</param>
            <param name="item2">The second object to store in the list.</param>
            <typeparam name="T">The type of elements stored in the list.</typeparam>
            <returns>A list that contains the specified objects.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.Create``1(``0,``0,``0)">
            <summary>Creates a list that contains the specified objects.</summary>
            <param name="item1">The first object to store in the list.</param>
            <param name="item2">The second object to store in the list.</param>
            <param name="item3">The third object to store in the list.</param>
            <typeparam name="T">The type of elements stored in the list.</typeparam>
            <returns>A list that contains the specified objects.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.Create``1(``0,``0,``0,``0)">
            <summary>Creates a list that contains the specified objects.</summary>
            <param name="item1">The first object to store in the list.</param>
            <param name="item2">The second object to store in the list.</param>
            <param name="item3">The third object to store in the list.</param>
            <param name="item4">The fourth object to store in the list.</param>
            <typeparam name="T">The type of elements stored in the list.</typeparam>
            <returns>A list that contains the specified objects.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRange``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Creates a new list populated with the specified items.</summary>
            <param name="items">The elements to add to the list.</param>
            <typeparam name="T">The type of element stored in the list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRange``1(System.ReadOnlySpan{``0})">
            <summary>Creates a new list populated with the specified items.</summary>
            <param name="items">The elements to add to the list.</param>
            <typeparam name="TItem">The type of element stored in the list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRangeWhere``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Creates a new list populated with the specified items, filtered down. Useful when you're trying to fetch the single item from the collection and deal with cases when there're none or a few, because this deals nicely with no extra alloactions.</summary>
            <param name="items">The elements to add to the list.</param>
            <param name="passfilter">Pass-filter for items.</param>
            <typeparam name="T">The type of element stored in the list.</typeparam>
            <returns>A list that contains the specified items.</returns>
            <remarks>This is not the most useful overload, the best ones are those which take value types for collection as they prevent boxing as opposed to <c>.Where()</c>.</remarks>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRangeWhere``1(System.Collections.Immutable.ImmutableArray{``0},System.Func{``0,System.Boolean})">
            <summary>Creates a new list populated with the specified items, filtered down. Useful when you're trying to fetch the single item from the collection and deal with cases when there're none or a few, because this deals nicely with no extra alloactions.</summary>
            <param name="items">The elements to add to the list.</param>
            <param name="passfilter">Pass-filter for items.</param>
            <typeparam name="T">The type of element stored in the list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRangeWhere``1(JetBrains.Util.dataStructures.FrugalLocalList{``0},System.Func{``0,System.Boolean})">
            <summary>Creates a new list populated with the specified items, filtered down. Useful when you're trying to fetch the single item from the collection and deal with cases when there're none or a few, because this deals nicely with no extra alloactions.</summary>
            <param name="items">The elements to add to the list.</param>
            <param name="passfilter">Pass-filter for items.</param>
            <typeparam name="T">The type of element stored in the list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRange``2(JetBrains.Util.dataStructures.FrugalLocalList{``0},System.Func{``0,``1})">
            <summary>Initializes a new instance of the list.</summary>
            <param name="items">The source list to initialize the resulting list with.</param>
            <param name="selector">The function to apply to each element from the source list.</param>
            <typeparam name="TSource">The type of element stored in the source list.</typeparam>
            <typeparam name="TResult">The type of element to store in the target list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.CreateRange``3(JetBrains.Util.dataStructures.FrugalLocalList{``0},``1,System.Func{``0,``1,``2})">
            <summary>Initializes a new instance of the list.</summary>
            <param name="items">The source list to initialize the resulting list with.</param>
            <param name="selector">The function to apply to each element from the source list.</param>
            <param name="arg">An argument to be passed to the selector mapping function.</param>
            <typeparam name="TSource">The type of element stored in the source list.</typeparam>
            <typeparam name="TArg">The type of argument to pass to the selector mapping function.</typeparam>
            <typeparam name="TResult">The type of element to store in the target list.</typeparam>
            <returns>A list that contains the specified items.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalList.ToFrugalLocalList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Creates a list from the specified collection.</summary>
            <param name="items">The collection of objects to copy to the list.</param>
            <typeparam name="TSource">The type of elements contained in <paramref name="items" />.</typeparam>
            <returns>A list that contains the specified collection of objects.</returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListAsIList`1">
            <summary>
            A readonly helper to expose the <see cref="T:System.Collections.Generic.IEnumerable`1" /> and alike interface from <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1" />. Boxes the structure explicitly.
            You SHOULD do C# <c>foreach</c> right on the list, which will cause the compiler to emit code which calls into the original struct public methods directly.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListAsIList`1.Enumerator">
            <summary>
            Does not share the enumerator class/struct with the list itself because that one does not implement the interfaces,
            which allows to skip on <see cref="M:System.IDisposable.Dispose" /> and try-finally sections in emitted code.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.FrugalLocalListEnumerator`1">
            <summary>
            The minimal enumerator implementation for the <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1" />.
            Only supports C# <c>foreach</c>, does not have even <c>Dispose</c> to save on try-finally sections.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalListEx.IsEmpty``1(JetBrains.Util.dataStructures.FrugalLocalList{``0}@)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection" /> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalListEx.SingleOrFirstErr``1(JetBrains.Util.dataStructures.FrugalLocalList{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, throws an exception  (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)" />).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg4"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.FrugalLocalListEx.SingleOrFirstOrDefaultErr``1(JetBrains.Util.dataStructures.FrugalLocalList{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, returns NULL (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)" />).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream">
            <inheritdoc cref="T:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream" />
        </member>
        <member name="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.BytesInCache">
            <summary>
            We put all of the bytes read from the underlying stream into cache to make this view seekable.
            This tells how much of the stream bytes have been taken to cache already.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.ImmutableView">
            <summary>
            Gets the immutable stream.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.IsFullyCached">
            <summary>
            Gets if all the bytes from the underlying sequential stream have already been taken into the random-access cache.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.LengthIfKnown">
            <summary>
              <para>Total length of the stream, if it's cheap to tell.</para>
              <para>With a sequential-only underlying stream, it is generally not available, so to tell the <see cref="P:System.IO.Stream.Length" /> our clients on the <see cref="T:System.IO.Stream" /> interface we'd need to fully read and fully cache the stream, which will be expensive if you only need the length for diag.</para>
              <para>The length is cheaply known when:</para>
              <para> We have already cached the whole underlying stream.</para>
              <para> Stream owner has told us the length it knows from some other source (e.g. a ZIP entry stores its uncompressed length).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.GetOrFullyReadForLength">
            <summary>
            Gets the length, if known (<see cref="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.LengthIfKnown" />), otherwise, reads the underlying stream to the end to know the length.
            <see cref="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.ImmutableView" />.<see cref="P:System.IO.Stream.Length" /> does this.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.GetSequentialStreamClone(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Can give you a stream clone if you only intend sequential access.
             If reading the underlying stream has already cached most if it  gives a clone of the immutable stream view, to complete caching, regardless.
             If the supplier of the original sequential stream knows how to make another one just like it  asks for it, and returns. That would be the real non-caching stream.
             In all other cases  a clone of the immutable stream view, caching and all.
            </summary>
            <param name="lifetime">
            Lifetime of the stream access.
            NOTE: you do not need to dispose of the stream. Disposing of the stream might or might not have effect.
            </param>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ImmutableByteStream">
            <summary>
            Base class for our streams which are guaranteed to be immutable and seekable (but might possibly be lazy), which makes a basis for the use of file bodies in the reliable builds.
            Our streams contract is that it does not obey <see cref="T:System.IDisposable" /> (safe to be disposed once or multiple times without impairing operation), but takes a <see cref="T:JetBrains.Lifetimes.Lifetime" /> upon construction if required by the specific instance.
            Streams support shallow cloning, that's multiple stream reader views over the single instance, with independent positions.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ImmutableByteStream.Empty">
            <summary>
            An empty immutable stream.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.ImmutableByteStream.myLazyDigest">
            <summary>
            Digest of the stream contents, lazily-calculated. The main reason for having it wrapped into a Lazy reference type is to have it shared (full-write) between shallow clones.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.#ctor(JetBrains.Util.dataStructures.ImmutableByteStream)">
            <inheritdoc />
            <param name="clonesource">Optional. When creating a shallow-cloned instance, gives a pointer to the cloning source. This allows to reuse the lazy message digest. Failure to report the clone source when implementing your <see cref="M:JetBrains.Util.dataStructures.ImmutableByteStream.ShallowClone" /> would not break anything, but will slow down access to message digest. This is critical for one of the main clients, Immutable File Items, because they'd return a new shallow clone on each file body property access.</param>
        </member>
        <member name="P:JetBrains.Util.dataStructures.ImmutableByteStream.CanRead">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.dataStructures.ImmutableByteStream.CanSeek">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.dataStructures.ImmutableByteStream.CanWrite">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.dataStructures.ImmutableByteStream.Digest">
            <summary>
            Lazily-computed hash of the bytes in the stream.
            It is NOT guaranteed to be stable between runs, but hashing algorithm must be exactly the same for all <see cref="T:JetBrains.Util.dataStructures.ImmutableByteStream" /> implementations within the single process run.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.ComputeDigest(System.IO.Stream)">
            <summary>
            Exposes the function which is used for computing <see cref="P:JetBrains.Util.dataStructures.ImmutableByteStream.Digest" /> over the file content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.CreateOnUserBuffersGuaranteedImmutable(System.Byte[][])">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed immutable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.CreateOnUserBuffersGuaranteedImmutable(System.Collections.Generic.IEnumerable{System.Byte[]},System.Int32,System.Int32)">
            <summary>
              <para>Wraps user buffers with a readonly stream.</para>
              <para>Caller claims the buffers to be ever immutable, so the stream is assumed immutable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.EndWrite(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.Flush">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.FromByteArray(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Wraps an immutable byte array as an immutable byte stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.SetLength(System.Int64)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.ShallowClone">
            <summary>
              <para>Makes a lightweight clone which has an independent position in the stream and can run independent read/write operations, but shares the same media.</para>
              <para>This way you can have multiple readers over the same data without their interfering with each other's position and yet without wasting memory.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.WithNoLifetime">
            <summary>
              <para>Ideally in .NET, immutable memory streams should be non-lifetimed and GC controlled. In reality, to optimize memory use, sometimes the immutable byte streams might have limited lifetime if they're being projected by a certain source rather than copied to GC-controlled memory.</para>
              <para>This method tries to ensure that the memory owned by this file item has no end of life. Returns a new instance only if a change were made. We suppose that implementations know when their memory might possibly become invalid.</para>
              <para>Note that a totally different implementation of a byte stream might be returned from this method.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.Write(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.WriteAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStream.WriteByte(System.Byte)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStreamStructuralComparer.Compare(JetBrains.Util.dataStructures.ImmutableByteStream,JetBrains.Util.dataStructures.ImmutableByteStream)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStreamStructuralComparer.Equals(JetBrains.Util.dataStructures.ImmutableByteStream,JetBrains.Util.dataStructures.ImmutableByteStream)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.ImmutableByteStreamStructuralComparer.GetHashCode(JetBrains.Util.dataStructures.ImmutableByteStream)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream">
            <summary>
            Wraps a sequential stream with a view which supports seek operations. For that, it has to keep a copy of already-passed bytes, even if you skip them when seeking, so use only when needed (like, when you want to analyze a header of a sequential stream with a reader which requires seeking).
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.myData">
            <summary>
            Data shared between all the clones of the immutable stream, pumping off the same underlying sequential stream.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.myPosition">
            <summary>
            Current position in this clone of the stream. This data is not shared.
            MIGHT be beyond the cache length because we do not pump on seek, only when we actually try to read.
            MIGHT be beyond <see cref="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Length" />, because many sequential streams do not tell their real length.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.#ctor(JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.IO.Stream},System.Boolean,System.Nullable{System.Int64})">
            <summary>
            </summary>
            <param name="lifetime">A lifetime for opening the main underlying sequential stream (the first call to <see cref="!:FOpenStream" />). Might be <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal" /> if you don't care.</param>
            <param name="FOpenStream">
              <para>The lazy sequential stream to be wrapped.</para>
              <para>At this point, will be wrapped even if seekable.</para>
              <para>Set <see cref="!:canOpenMultiple" /> to <c>True</c>, if possible, to enable opening another instances of the underlying sequential stream, in case client wants to consume the stream sequentially without the overhead of caching it in mem. This is useful only for cases like bulk extracting entries. If is an error to return the same stream instance multiple times in this case. If <c>False</c>, you'd be only called once anyway.</para>
            </param>
            <param name="canOpenMultiple">See <paramref name="FOpenStream" />.</param>
            <param name="customlength">
              <para>If the <see cref="P:System.IO.Stream.Length" /> property of the underlying stream is irrelevant (which might be a case with a sequential stream), you must provide its value by some external knowledge, otherwise seeking based on end or getting the length would be a costly operation because it would have to read the stream fully.</para>
              <para>Leave empty to use from the underlying stream or read to end for learning the length.</para>
            </param>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.BytesInCache">
            <summary>
            We put all of the bytes read from the underlying stream into cache to make this view seekable.
            This tells how much of the stream bytes have been taken to cache already.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.IsFullyCached">
            <summary>
            Gets if all the bytes from the underlying sequential stream have already been taken into the random-access cache.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Length">
            <summary>
            MIGHT be expensive to calculate! Check <see cref="P:JetBrains.Util.dataStructures.IImmutableViewOnSequentialStream.LengthIfKnown" /> to know if the length is immediately available.
            Otherwise, would need to fully consume the underlying stream to tell.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.LengthIfKnown">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.GetOrFullyReadForLength">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.GetSequentialStreamClone(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.WithNoLifetime">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.JetBrains#Util#dataStructures#IImmutableViewOnSequentialStream#ImmutableView">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.PumpIntoCache(System.Nullable{System.Int64})">
            <summary>
            Ensures we can read <paramref name="needAfterPos" /> bytes from the current <see cref="P:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Position" />.
            Must be protected with lock at caller side.
            </summary>
            <param name="needAfterPos">
            Recommended amount. Must have as many bytes available in the cache, unless the input stream runs out of bytes.
            NULL is a special value, means we need to pump it all and have the full content in cache.
            </param>
            <returns>Bytes actually available, after pos and to the end of the current cache, but at most <paramref name="needAfterPos" />.</returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata">
            <summary>
            The common data shared between all the clones.
            This object is also reused as the Operations Lock shared by all the clones.
            Main goal to have this as an object: we can't just copy all data because we want to release (from all clones) the sequential stream when it gets exhausted, which means we need some kind of an object box around it anyway, let's keep all data in there.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.Cache">
            <summary>
            Bytes which we pump from the sequential stream get cached here, for random access.
            Operations locked via the data object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.ExternalLifetime">
            <summary>
            As passed by creator.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.FOpenStream">
            <summary>
            Opens the main underlying stream.
            Maybe opens a clone of the underlying stream.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.IsFullyCached">
            <summary>
            When <see cref="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.UnderlyingStream" /> is read to the end, it's released, NULLed, and this gets <c>True</c> (under lock).
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.UnderlyingStream">
            <summary>
            The main underlying sequential stream.
            Lazy-created to enable mass-creation of immutable file item promises with low overhead. For example, the zip entry inflater eagerly allocates its working buffers, so with mass-creation for all the entries this makes quite a number.
            Gets NULLed after exhaustion (to release its resources, incl inner buffer).
            Operations and NULLing locked via the data object.
            States:
             Non-NULL: partially cached, OK.
             NULL and <see cref="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.IsFullyCached" />: fully cached, stream released, OK.
             NULL and NOT <see cref="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.IsFullyCached" />: aborted by termination, BROKEN.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.UnderlyingStreamLength">
            <summary>
            Lazy-reads the length from the underlying stream, if it tells anything.
            Might throw or tell zero. Or potentially any bullshit. Only asked if we don't know <see cref="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.UserSuppliedLength" /> and need to know the prospected length.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.RandomAccessViewOnSequentialStream.Clonedata.UserSuppliedLength">
            <summary>
            Stores custom length as supplied, for asserting when we do know the real length.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.ReadOnlyFrugalLocalList`1">
            <summary>
            Readonly representation for <see cref="T:JetBrains.Util.dataStructures.FrugalLocalList`1"/>
            Can be used in public API
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner">
            <summary>
            Represents a string-like object over a managed memory buffer presented as a byte array, written in the UTF-16LE encoding.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner.Create(System.Byte[],System.UInt32,System.UInt32)">
            <summary>
            Creates a string source over a byte array.
            </summary>
            <param name="array">The array.</param>
            <param name="cbstart">The index to the first byte of the string, in bytes.</param>
            <param name="cblength">The length of the string in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.ByteArrayUtf16leStringSourceOwner.JetBrains#Util#dataStructures#Sources#IStringSourceOwner#AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSource`1">
            <summary>
              <para>A value type which implements a set of <see cref="T:System.Collections.Generic.ICollection`1" />-like accessors. The collection interface itself is not implemented to avoid accidental boxing.</para>
              <para>This can be used to represents a specialized view on a larger collection or a data source, or a result of dynamic calculation, which does not allocate memory per-instance.</para>
              <para>The <see cref="T:JetBrains.Util.dataStructures.Sources.ICollectionSourceOwner`1" /> serves as a common backend for a set of such collections (or even is a singleton), while the reference-type and value-type parameters in the collection source instance allow to define the context to make the collection source owner serve a specific collection.</para>
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSource`1.FromCollection(System.Collections.Generic.ICollection{`0})">
            <summary>
            Wraps an actual collection object with a collection source.
            </summary>
            <param name="collection"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.CollectionSource`1.Enumerator.DataRefY">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSourceDebugView`1">
            <summary>
            Renders collection source contents for the debugger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceEx.AsCollectionSource``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Wraps an actual collection object with a collection source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceEx.AsEnumCollectionSource``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Wraps an enumerable with a collection source so that it's not committed to a collection but enumerated anew on each request.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.CollectionSourceOwnerHelpers.GetCountViaEnumeration``1(JetBrains.Util.dataStructures.Sources.CollectionSource{``0}@)">
            <summary>
            Counts items by iterating the collection. Revert to this impl if you can't count the items faster.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.CollectionSourcePodData">
            <summary>
            An empty placeholder which allocates memory for POD data of collection source owners.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.EmptyStringSourceOwner">
            <summary>
            Represents an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.EmptyStringSourceOwner.JetBrains#Util#dataStructures#Sources#IStringSourceOwner#AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.IStringSourceOwner">
            <summary>
            An interface to switchable implementations behind the <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsManagedStringSource(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <summary>
              <para>Returns a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" /> which is guaranteed to be hosted in the managed memory, i.e. its lifetime won't terminate.</para>
              <para>Required if you plan on using the string longer than the lifetime it's been produced under.</para>
              <para>Native strings will be rendered as runtime strings. Non-native strings, e.g. strings or substrings, will be returned AS IS.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.IStringSourceOwner.AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.IStringSourceOwner.Fixed``2(JetBrains.Util.dataStructures.Sources.StringSource@,``0,JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate{``0,``1})">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="ss">Instance.</param>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name=""></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner">
            <summary>
            A string in the native memory.
            Cannot be directly treated as an <c>LPCWSTR</c> because for it zero-termination is not guaranteed.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.Create(JetBrains.Lifetimes.Lifetime,System.Char*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Checks the lifetime before accessing the memory range (not safe from races though, rule this out with external means of control).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.Create(JetBrains.Lifetimes.Lifetime,System.UInt16*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Checks the lifetime before accessing the memory range (not safe from races though, rule this out with external means of control).
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.CreateWithoutLifetime(System.Char*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Has NO means for checking that the mem is still valid, so don't use unless really have to.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.CreateWithoutLifetime(System.UInt16*,System.UInt32)">
            <summary>
            Stringsources a native memory range. Has NO means for checking that the mem is still valid, so don't use unless really have to.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.NativeStringSourceOwner.JetBrains#Util#dataStructures#Sources#IStringSourceOwner#AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RealCollectionSourceOwner`1">
            <summary>
            Wraps a real collection into a collection source.
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RuntimeStringSourceOwner">
            <summary>
            Wraps a runtime string object as a string source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.RuntimeStringSourceOwner.JetBrains#Util#dataStructures#Sources#IStringSourceOwner#AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.RuntimeSubStringSourceOwner">
            <summary>
            Wraps a runtime string object as a string source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.RuntimeSubStringSourceOwner.JetBrains#Util#dataStructures#Sources#IStringSourceOwner#AsSpan(JetBrains.Util.dataStructures.Sources.StringSource@)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.StringSource">
            <summary>
              <para>Represents a string which has not yet been calculated as a runtime string object.</para>
              <para>Allows for most string-related operations without allocation of a real runtime string.</para>
              <para>Like with <c>HSTRING</c></para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.Empty">
            <summary>
              <para>Gets a source for an empty string.</para>
              <para>This is equivalent to a NULL value for this structure.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.DataPod">
            <summary>
            POD data member.
            </summary>
        </member>
        <member name="F:JetBrains.Util.dataStructures.Sources.StringSource.DataRefX">
            <summary>
            One of the reference data members.
            </summary>
        </member>
        <member name="P:JetBrains.Util.dataStructures.Sources.StringSource.IsEmpty">
            <summary>
            Gets whether the string is empty.
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.AsManagedStringSource">
            <summary>
              <para>Returns a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" /> which is guaranteed to be hosted in the managed memory, i.e. its lifetime won't terminate.</para>
              <para>Required if you plan on using the string longer than the lifetime it's been produced under.</para>
              <para>Native strings will be rendered as runtime strings. Non-native strings, e.g. strings or substrings, will be returned AS IS.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.AsSpan">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.Fixed``2(``0,JetBrains.Util.dataStructures.Sources.StringSourceFixedDelegate{``0,``1})">
            <summary>
              <para>Processes a string as a fixed pointer to the char array.</para>
              <para>This char array MIGHT NOT be zero-terminated!!</para>
              <para>It MUST NOT be modified.</para>
              <para>It might be a subrange of some other runtime string object, or a pointer to a native memory area, or some stack/reusable buffer.</para>
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name=""></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSource.ToRuntimeString">
            <summary>
              <para>Renders the runtime string object for this string source.</para>
              <para>This specific operation is what a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" /> tries to avoid by providing a string-like API to some non-allocating object.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.IsEmpty(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Gets whether the string is empty.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)" />
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.IsEmpty(System.Nullable{JetBrains.Util.dataStructures.Sources.StringSource})">
            <summary>
            Gets whether the string is empty.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)" />
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.Split(JetBrains.Util.dataStructures.Sources.StringSource,System.Char[])">
            <summary>
            Returns an array of string sources that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separators" />.
            </returns>
            <param name="ths"></param>
            <param name="separators">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.Split(JetBrains.Util.dataStructures.Sources.StringSource,System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an array of string sources that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separators" />.
            </returns>
            <param name="ths"></param>
            <param name="separators">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned,
            or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.dataStructures.Sources.StringSourceEx.ToRuntimeString(System.Nullable{JetBrains.Util.dataStructures.Sources.StringSource})">
            <summary>
              <para>Renders the runtime string object for this string source.</para>
              <para>This specific operation is what a <see cref="T:JetBrains.Util.dataStructures.Sources.StringSource" /> tries to avoid by providing a string-like API to some non-allocating object.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.dataStructures.Sources.StringSourcePodData">
            <summary>
            An empty placeholder which allocates memory for POD data of string source owners.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.AsyncPipeReader">
            <summary>
            Reads from the reader end of the pipe which has been opened with Overlapped IO enabled.
            The read is asynchronous without holding up any threads, using OS ThreadpoolIO.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsBusy">
            <summary>
            Either placing a read async call, or analyzing its results and whether it's sync or async, or running the code inside the callback.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsInCallback">
            <summary>
            Set to True when executing callback code. Most importantly, we must not wait for a callback when inside a callback. Changed under the <see cref="F:JetBrains.Util.Threading.AsyncPipeReader.myIsBusy" /> lock only, allows to tell if we're taking the lock in some nested code of the callback.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.myIsReadChainStopped">
            <summary>
            Not processing or awaiting, usually because the lifetime has been terminated or pipe broken or some error has occurred.
            Means there's no pending wait, we're not analyzing the pending read results, and we're not about to do a new pending read.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.#ctor(JetBrains.Lifetimes.Lifetime,System.Void*,System.Action{JetBrains.Util.dataStructures.ByteBuffer},System.Action)">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="FOnRead">Reader callback. Must not do complex operations, as might occur on the OS IO pool thread and under a lock. The buffer is temporary for the callback duration only. MUST NOT terminate lifetime in it.</param>
            <param name="FUserOnEof">Optional. Notifies when reading the pipe breaks. Same callback limitations apply: OS thread, under lock. MUST NOT terminate lifetime in it.</param>
        </member>
        <member name="P:JetBrains.Util.Threading.AsyncPipeReader.IsRunning">
            <summary>
            Gets whether the lifetime has not yet been terminated and the pipe has not yet been closed on either end.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.InitiateOverlappedIoConnectNamedPipe">
            <summary>
            Initiates pipe connect (if a read has failed because no clients have connected yet).
            MUST be under Busy Lock.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.InitiateOverlappedIoReadFile">
            <summary>
            Initiates the next read from pipe.
            MUST be under Busy Lock.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.SwitchIoResult(JetBrains.Interop.WinApi.WinError,JetBrains.Util.Threading.AsyncPipeReader.SwitchFlags,System.UInt32,JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.OperationControlFlags)">
            <summary>
            Called whenever we have an IO result. Unified handling for all cases.
            Which are:
            (1) On ReadFile function immediate return result.
            (2) On ConnectNamed Pipe immediate return result.
            (3) Upon a successful result of either above, the unwrapped result from within <see cref="M:JetBrains.Interop.WinApi.Kernel32Dll.GetOverlappedResult(System.Void*,JetBrains.Interop.WinApi.OVERLAPPED*,System.UInt32*,System.Int32)" /> (called recursively after unwrapping).
            (4) From an async IO Complection Callback (which already has the result unwrapped).
            Triggers other IO operations as needed (connect pipe, read loop, etc).
            MUST be called under the Busy Lock.
            </summary>
            <param name="ioresult">The IO Result we're switching over.</param>
            <param name="switchflags">The context we've been called from.</param>
            <param name="dwBytesRead">If called with a ready successful result, then need to pass the number of bytes from it.</param>
            <param name="operflags">The context of how the operation has been initiated (read or not), and if we're the chosen party to handle its result (first to be called on the sync/async reply).</param>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.OperationsChain.YieldBreak">
            <summary>
            Means we should yield this thread, and the chain of operations will be continued elsewhere (from an async callback, for example, or it's shut down completely).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.OperationsChain.ContinueHere">
            <summary>
            Means the caller should initiate the next IO operation in the chain immediately. We do not call it right here because the stack would grow on async results then.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl">
            <summary>
            We want to know if we've initiated an IO operation and not completed it yet (sync or async).
            All access must be protected by the owner's Busy Lock.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.myIsPendingOverlappedIo">
            <summary>
            An overlapped IO operation has been initiated, and has not yet completed (or been acknowledged for).
            TPIO has been started, an overlapped IO call has been placed.
            This state means that either:
             The operation went async, we're expecting a callback. The callback will give us the result and eat up the TPIO.
             The operation has succeeded synchronously (in FILE_SKIP_COMPLETION_PORT_ON_SUCCESS mode), and we're in between the IO call and the handling code. Will need to cancel the now-unneeded TPIO.
             The operation has failed (with a code other than ERROR_IO_PENDING), and we're in between the IO call and the handling code. Will need to cancel the now-unneeded TPIO.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.NotifyAbortingOnShutdown">
            <summary>
            Called from lifetime termination handler when shutting down the reader.
            MUST be called under owner's Busy Lock.
            Gets if we need to cancel anything.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.NotifyAfterBeginIo(JetBrains.Interop.WinApi.WinError)">
            <summary>
            Called just after a call to an overlapped IO operation, telling its result.
            MUST be called under owner's Busy Lock.
            Checks if we are the ones to handle the operation result (rather than callback).
            Checks if TPIO should be canceled.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.NotifyBeforeBeginIo(JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.OperationKind)">
            <summary>
            Called before initiating any overlapped IO operation.
            MUST be called under owner's Busy Lock.
            It is an error if <see cref="F:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.myIsPendingOverlappedIo" /> is <c>True</c>.
            Sets the state, starts the TPIO.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.NotifyWithinCompletionCallback">
            <summary>
            Called from within the completion callback for an overlapped IO operation.
            MUST be called under owner's Busy Lock.
            Checks if we are the ones to handle the operation result (the callback rather than the code which initiated an IO operation and might have had the reply synchronously).
            TPIO need not be canceled if we're in the callback, we've used it up.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.OperationControlFlags.ShouldHandleSuccessResult">
            <summary>
            Of multiple parties possibly handling the result (code right after the overlapped IO operation, and callback), the one which is calling should process the success result.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.OverlappedIoOperationTpioControl.OperationControlFlags.WasReadOperation">
            <summary>
            The IO operation were a read, so should be reading bytes (and zero means EOF in this case).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.SwitchFlags.IsUnwrappedOverlappedResult">
            <summary>
            Basically, (1) raw IO function call ioresult and (2) completed async call overlapped ioresult have the same errors but a few peculiarities:
             (2) Completed cannot have the PENDING status.
             On success, (1) needs to get the overlapped ioresult and switch over it again, while (2) already handles the result.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.AsyncPipeReader.SwitchFlags.IsOnAsyncCompletionCallback">
            <summary>
            Mostly used for diag.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.AsyncPipeTextLineReader">
            <summary>
            Based on the <see cref="T:JetBrains.Util.Threading.AsyncPipeReader" />, decodes text out of the raw bytes, and splits by lines.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLinesWithDeferredCallback(JetBrains.Lifetimes.Lifetime,System.Void*,System.Text.Encoding,System.Action{System.String})">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="encoding"></param>
            <param name="FOnReadLineDeferred">Reader callback. Called outside of any native callbacks, so it can be any much complex, but for the last call when EOF is encountered or lifetime is destroyed, which has to be sync.</param>
        </member>
        <member name="M:JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLinesWithDirectCallback(JetBrains.Lifetimes.Lifetime,System.Void*,System.Text.Encoding,JetBrains.Util.Threading.AsyncPipeTextLineReader.ReadLineDelegate)">
            <summary>
            Initiates async reads from the pipe, and proceeds doing that until terminated or pipe is broken.
            </summary>
            <param name="lifetime">Lifetime for the reader. Might block upon termination until the ongoing async operation can be safely interrupted. Must not be terminated from within a callback.</param>
            <param name="hPipeRead">File handle to the reader end of the pipe. MUST be opened with async support, e.g. with CreateNamedPipeW or with CreateFileW.</param>
            <param name="encoding"></param>
            <param name="FOnReadLine">Reader callback. Must not do complex operations, as might occur on the OS IO pool thread and under a lock. The buffer is temporary for the callback duration only. MUST NOT terminate lifetime in it.</param>
        </member>
        <member name="T:JetBrains.Util.Threading.IReaderWriterLock">
            <summary>
            Base API for Shell Locks  Content Model Reader-Writer Lock.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsReadAccessAllowed">
            <summary>
            True if read access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock" />
            <code>JetBrains.Application.IShellLocksEx.AssertReadAccessAllowed(JetBrains.Application.IShellLocks)</code>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsReadLockHeld">
            <summary>
            Indicates that the current thread owns the read lock
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteAccessAllowed">
            <summary>
            True if write access is allowed in the current thread.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)" />
            <code>JetBrains.Application.IShellLocksEx.AssertWriteAccessAllowed(JetBrains.Application.IShellLocks)</code>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteLockHeld">
            <summary>
            Indicates that the current thread owns the write lock
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.IsWriteLockRequested">
            <summary>
            Indicates that any thread requests for write lock, but not yet granted
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.IReaderWriterLock.Interruption">
            <summary>
            An interruption source for WriteLock.
            It will raise interrupt flag when write lock is being requested.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock">
            <summary>
             Fetches read lock - the lock which is used to control read-access to ReSharper data (such as PSI, documents, etc.) and
             is obtained by threads that perform read-operations.
            </summary>
            <remarks>
             Read lock cannot be acquired when the write lock is acquired by another thread and execution will be blocked until the write lock is released.
             You do not need to acquire read lock in the UI thread (since write operations cannot be performed in any thread different from the UI thread).
             Use <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock" /> method to release read lock.
            <b>NOTE:</b> the best way to hold read lock for a block of code is to use <code>JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie</code>
            </remarks>
            <code>JetBrains.ReSharper.Resources.Shell.Shell.ReadLockCookie</code>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock" />
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)">
            <summary>
            Fetches write lock - the lock which is used to control write-access to ReSharper data (such as PSI, documents, etc.) and
            is obtained by threads that perform write-operations.
            </summary>
            <remarks>
            Write lock cannot be acquired when the read lock is acquired by another thread and execution will be blocked until the read lock is released.
            Acquiring of the write lock is allowed only in the UI thread (and so you cannot perform any write operations from non-UI thread).
            Note that you do not have to obtain the write lock explicitly in most of cases. All low-level write methods (such as PSI or document modifications)
            obtain write lock automatically. You may need to obtain write lock if your subsystem (similar to PSI or documents) has its own data to be modified in write operations only.
            Use <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock" /> method to release write lock.
            <b>NOTE:</b> the best way to hold write lock for a block of code is to use <code>JetBrains.ReSharper.Resources.Shell.WriteLockCookie</code>
            </remarks>
            <code>JetBrains.ReSharper.Resources.Shell.WriteLockCookie</code>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock" />
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(System.String,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseReadLock">
            <summary>
             Releases read lock.
             For more information about read lock see <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock" />.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock" />
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.ReleaseWriteLock">
            <summary>
             Releases write lock.
             For more information about write lock see <see cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)" />.
            </summary>
            <seealso cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)" />
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.TryAcquireReadLock(System.Int32)">
            <summary>
             Tries to fetch read lock - the lock which is used to control read-access to ReSharper data (such as PSI, documents, etc.) and
             is obtained by threads that perform read-operations.
            </summary>
            <inheritdoc cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireReadLock"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.TryAcquireWriteLock(System.Int32,JetBrains.Util.Threading.CallerInfo)">
            <summary>
            Tries to fetch write lock - the lock which is used to control write-access to ReSharper data (such as PSI, documents, etc.) and
            is obtained by threads that perform write-operations.
            </summary>
            <inheritdoc cref="M:JetBrains.Util.Threading.IReaderWriterLock.AcquireWriteLock(JetBrains.Util.Threading.CallerInfo)"/>
        </member>
        <member name="M:JetBrains.Util.Threading.IReaderWriterLock.TryAcquireWriteLock(System.Int32,System.String,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Threading.IReaderWriterLock.TryAcquireWriteLock(System.Int32,JetBrains.Util.Threading.CallerInfo)"/>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageBase.DiagDecodeMessage(System.Byte[])">
            <summary>
              Call for diagnostic only, because it's not guaranteed to work for all messages. Set this to up-to-date message decoder when debugging.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.myQueueUnsent">
            <summary>
              If there's no space for sending more messages, they can be stacked here.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.SendMessage(System.Byte[])">
            <summary>
              Sends a message to the receiving party. If the buffer is currently full, stores it in queue and does not block.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Mmf.SharedMemoryMessageWriter.EnsureSent">
            <summary>
              Makes sure all of the messages currently on the queue get sent out, synchronously.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.SynchronizedLifetime">
            <summary>
              <para>Synchronizes lifetime-driven activities on multiple threads.</para>
              <para>If you use your component lifetime directly, it might be terminated in the middle of some background activity.</para>
              <para>
                You should rather create this object on your home thread and use its <see cref="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated(System.Action)" /> to run background-thread activities (possibly on multiple threads). It is guaranteed that as the outer lifetime starts termination, this particular lifetime will live thru until your background action is completed.
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.myDispatcher">
            <summary>
            Non-<c>Null</c> to specify the thread to which the object termination is affined.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.myLockSync">
            <summary>
              Terminates under a writer lock. All other activity goes under a reader lock.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.SynchronizedLifetime.IsTerminated">
            <summary>
            Works just like <see cref="P:JetBrains.Util.Threading.SynchronizedLifetime.Lifetime" />'s flag, gets <c>True</c> when termination has just started.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Threading.SynchronizedLifetime.Lifetime">
            <summary>
              <para>Gets the lifetime whose termination is synchronized by this object.</para>
              <para>It's not safe to call lifetime's scheduling methods unless you're running within some of the <c>Execute*</c> functions.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.op_Implicit(JetBrains.Util.Threading.SynchronizedLifetime)~JetBrains.Lifetimes.Lifetime">
            <summary>
              Gets the lifetime whose termination is synchronized by this object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated(System.Action)">
            <summary>
              <para>Executes the action unless the lifetime has already been terminated.</para>
              <para>Free-threaded <see cref="M:JetBrains.Lifetimes.Lifetime.AddAction(System.Action)" /> calls are only safe within this method.</para>
            </summary>
            <param name=""></param>
            <returns>
              Whether the lifetime is still alive (action might be prevented, aborted or completed when <c>False</c>; it's definitely been completed if <c>True</c>).
            </returns>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteIfNotTerminated``1(System.Func{``0})">
            <summary>
              Executes the action unless the lifetime has already been terminated on the main thread.
            </summary>
            <param name=""></param>
            <returns>
              If the lifetime is still alive, executes the action and returns its result. Otherwise, returns null.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Threading.SynchronizedLifetime.ExecuteSynchronizedWithTermination(System.Action)">
            <summary>
              <para>Synchronizes this action with lifetime termination on another thread.</para>
              <para>For terminations on the same thread, there're obviously no guarantees, as we cannot wait until it gets clear.</para>
              <para>But regarding termination on other threads, it's guaranteed the lifetime state is consistent and won't change within the duration of this action (either fully alive or fully terminated).</para>
            </summary>
            <param name="F"></param>
            <remarks>
            There's no flag to tell you if termination is in progress right now (but not yet complete). <see cref="P:JetBrains.Util.Threading.SynchronizedLifetime.IsTerminated" /> will be <c>True</c> when either termination is running or fully completed.
            If you need to allow some actions to execute within termination, but not with a fully dead lifetime  you must create a nested lifetime which will either be all good or all dead at that point, and use that for determination.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.TerminationThreadAffinity.Same">
            <summary>
            The outer (unsynchronized) lifetime must be terminated on the same thread as the object has been created.
            Use with component containers.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.SynchronizedLifetime.TerminationThreadAffinity.Free">
            <summary>
            A fully free-threaded scenario, termination allowed on any thread.
            Note that in this case you MUST make sure the lifetime is not terminated while this object is still being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.JetTaskEx">
            <summary>
            Local extensions to the Async Tasks.
            Some of them would be available out of the box with Netfx 45.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.IsProcessCancelled(System.Threading.Tasks.Task)">
            <summary>
            Task is faulted because of PCE
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ParseAggregateException(System.Exception@,System.AggregateException)">
            <summary>
            Try to find out OperationCanceledException in AggregateException. If no PCE but some other exception exist, return it.
            </summary>
            <param name="toUpdate">Return value that can be updated based on possibleAggregateException</param>
            <param name="possibleAggregateException">AggregateException or null</param>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.Delay(System.TimeSpan,System.Nullable{System.Threading.CancellationToken})">
            <summary>
            Creates a started tasks which will get a completed state after the specified amount of time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ContinueWhenCatchAll``1(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task{``0}},JetBrains.Util.ILogger)">
            <summary>
              <para>Proceeds with those task results which have not faulted while computing. Faults are logged and isolated.</para>
              <para>Resulting task fault policy: never faults, even if all input task fail.</para>
              <para>Resulting task cancelation policy: only cancels when ALL the input tasks have been canceled.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ContinueWhenCatchAll(System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task},JetBrains.Util.ILogger)">
            <summary>
              <para>Proceeds with those task results which have not faulted while computing. Faults are logged and isolated.</para>
              <para>Resulting task fault policy: never faults, even if all input task fail.</para>
              <para>Resulting task cancelation policy: only cancels when ALL the input tasks have been canceled.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(System.Func{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(System.Func{System.Threading.Tasks.Task{System.Boolean}},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.While(JetBrains.DataFlow.IProperty{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.AwaitNoLongerThan(System.Threading.Tasks.Task,System.String,System.TimeSpan,JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            If in the critical code we're afraid that certain tasks might never end, this imposes a time limit on them, completes the await and drops the remaining activity free (with reporting an error).
            WARNING! This does not cancel the underlying task! It's up to you to pass it a proper <see cref="T:JetBrains.Lifetimes.Lifetime" />/<see cref="T:System.Threading.CancellationToken" />. This method is to ensure that even if the task gets stuck forever and fails to obey the cancelation (in a reasonable time), your code will still be able to proceed.
            </summary>
            <param name="task">The task we wanted originally to await. Will return it in the fast case.</param>
            <param name="reason">
              <para>Will be included with the failure message to identify the point.</para>
              <para>The full failure message also reports the actual time limit.</para>
              <para>Should be a complete sentense.</para>
              <para>Example: "Timed out processing the external changes.".</para>
            </param>
            <param name="limit">The maximum amount of time to be awaiting for the task. This value will be included with the failure message.</param>
            <param name="logger">Logs time limit violations into this logger (or into the default logger if omitted).</param>
            <param name="level">Level for messages which go into the logger. Would be errors by default.</param>
            <returns>Returns the task result, if we awaited it successfully (for an overload with a result). Promotes the underlying cancelation/fault exceptions. If the underlying task isn't canceled in time and the time limit is hit, returns a canceled task.</returns>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.AwaitNoLongerThan``1(System.Threading.Tasks.Task{``0},System.String,System.TimeSpan,JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)">
            <inheritdoc cref="M:JetBrains.Util.Threading.JetTaskEx.AwaitNoLongerThan(System.Threading.Tasks.Task,System.String,System.TimeSpan,JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)" />
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.AwaitNoLongerThanCore_TimedOut(System.String,System.TimeSpan,JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            A side-task to report an error in case the time limit has been hit  if the time-limited task gets canceled, and the user task is still running.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ContinueAsync``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Makes sure that when you await the task, your awaiting code will be executed really asynchronously, not within the same call stack.
            This prevents two sync cases:
            (1) If the task is already completed, normally your code would be executed without any awaiting at all, all in one function.
            (2) When the task completes at last, your code might be executed inline with its completion, on the same call stack as the completion code. This might lead to unexpected deep recursion or unwanted execution under someone's lock (if, for example, that were a <see cref="T:System.Threading.Tasks.TaskCompletionSource`1" />::<see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetResult(`0)" /> under a lock).</summary>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.ContinueAsync(System.Threading.Tasks.Task)">
            <inheritdoc cref="M:JetBrains.Util.Threading.JetTaskEx.ContinueAsync``1(System.Threading.Tasks.Task{``0})"/>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.SelectAsyncOnTaskHostAsync``2(System.Collections.Generic.IReadOnlyCollection{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger,System.Func{``0,System.Threading.Tasks.ValueTask{``1}})">
            <summary>
            <para>A method with LINQ's <see cref="M:System.Linq.Enumerable.Select``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})"/>-like usage pattern which acts like PLinq's <see cref="M:System.Linq.ParallelEnumerable.AsParallel``1(System.Collections.Generic.IEnumerable{``0})"/> in that it executes mappers in parallel on the thread pool.</para>
            <para>Difference with LINQ: parallel execution, output items not in the same order as input. Async.</para>
            <para>Difference with PLinq: uses our task thread pool, shares with other tasks, does not overcommmit CPU regardless of how many of them you call. Batches execution of multiple cheap items on the same task unit to reduce scheduling overhead, but yields from time to time to allow other tasks execute.</para>
            <para>Shares our limited-to-numer-of-physical-threads task pool with other tasks, yields to let execute other tasks from time to time.</para>
            </summary>
            <remarks>Name intentionally different from the other overload, otherwise it tends to treat tasks as just synchronous types.</remarks>
        </member>
        <member name="M:JetBrains.Util.Threading.JetTaskEx.SelectOnTaskHostAsync``2(System.Collections.Generic.IReadOnlyCollection{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger,System.Func{``0,``1})">
            <inheritdoc cref="M:JetBrains.Util.Threading.JetTaskEx.SelectAsyncOnTaskHostAsync``2(System.Collections.Generic.IReadOnlyCollection{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger,System.Func{``0,System.Threading.Tasks.ValueTask{``1}})"/>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Low">
            <summary>
            Lowest level for background task.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.BelowNormal">
            <summary>
            Low level for non-urgent tasks.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Normal">
            <summary>
            Most common priority in system. Used in <see cref="T:JetBrains.Application.Threading.Tasks.TaskBarrier"/>. When you don't need fast response, use this activity.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal">
            <summary>
            Intermediate level. Until this priority (inclusively) tasks are executed synchronously in Unit Tests.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.High">
            <summary>
            For urgent tasks. Starting with this priority tasks are executed asynchronously (if not invoked with RunSynchronously()) in Unit Tests.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskPriority.Realtime">
            <summary>
            Highest priority
            </summary>
        </member>
        <member name="T:JetBrains.Util.Threading.Tasks.TaskSemaphore">
            <summary>
            Allows to limit the number of async activities to be executed in parallel, with asynchronous waits for the available resources.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myFreeCount">
            <summary>
            The current count of free objects, modified under <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myLockObject" />.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myWaits">
            <summary>
            The queue of waiting parties when <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myFreeCount" /> is zero and there's still demand, modified under <see cref="F:JetBrains.Util.Threading.Tasks.TaskSemaphore.myLockObject" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Tasks.TaskSemaphore.ExecuteUnderSemaphoreAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            Awaits for the semaphore resources to be available and claims one resource, then invokes the <paramref name="tasker" /> and executes its chain of tasks, then releases the semaphore and completes the returned task with the result of the <paramref name="tasker" />'s task.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Threading.Tasks.TaskSemaphore.UsingSemaphoreAsync">
            <summary>
              <para>Waits to take the semaphore, asynchronously, and yields a token to be used with the <c>using(){}</c> construct to release the semaphore.</para>
              <para>This overload supports the <c>async/await</c> syntax.</para>
            </summary>
            <example>
              <code>
            using(await sema.UsingSemaphoreAsync())
            {
              
            }
            </code></example>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ThreadSafeAttribute">
            <summary>
            Indicates that this class/method is safe for multithreaded usage. If class marked with "ImmutableAttribute" thread-safety is implicit. 
            If certain methods of class are thread-unsafe (e.g. iterators in synchronized dictionaries), you can annotate this methods with <see cref="T:JetBrains.Util.ThreadUnsafeAttribute"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.ThreadUnsafeAttribute">
            <summary>
            Indicates that class/method requires additional external synchronization
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataFlow.Extension.CollectionValidator">
            <summary>
            Validates collections by preventing certain values from being added or removed.
            Note that for the validator to attach, the original values must all pass the validation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.CreateReadonlyValidator``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token" /> as an argument.
            If the <paramref name="token" /> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="ths" /> is modified only on the given <paramref name="thread" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly collection. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureReadonly``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly list. All the legitimate modifiers must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.CollectionEvents{``0})">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.CollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ICollectionEvents{``0})">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.IListEvents{``0})">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.DictionaryEvents{``0,``1})">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.DictionaryEvents{``0,``1},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1})">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Extension.CollectionValidator.EnsureThisThread``2(JetBrains.DataFlow.IDictionaryEvents{``0,``1},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataFlow.ISignalOptionalFiring`1.IsAnyoneSinking">
            <summary>
            Gets whether anyone is sinking this signal at all.
            If not, you can skip preparing the event args and firing the event altogether.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataFlow.PropertyBoilerplate`1">
            <summary>
            A simple base implementation for <seealso cref="T:JetBrains.DataFlow.IProperty`1" /> objects which handles most of the members but for the critical ones.
            Does not support undelying properties for signals and before-change eventing.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Util.DataFlow.PropertyBoilerplate`1.AdviseCore(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}})">
            <seealso cref="M:JetBrains.DataFlow.ISignal`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})" />
        </member>
        <member name="M:JetBrains.Util.DataFlow.PropertyBoilerplate`1.GetValueCore(System.Object)">
            <seealso cref="M:JetBrains.DataFlow.IProperty`1.GetValue(System.Object)" />
        </member>
        <member name="M:JetBrains.Util.DataFlow.PropertyBoilerplate`1.SetValueCore(`0,System.Object)">
            <seealso cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0)" />
        </member>
        <member name="T:JetBrains.Util.DataFlow.Reasons`1">
            <summary>
            Collection of reasons used to allow/ suppress something.
            </summary>
            <typeparam name="T">Type of reason. Normally string is used</typeparam>
        </member>
        <member name="P:JetBrains.Util.DataFlow.Reasons`1.Name">
            <summary>
            Name of the instance. Used for debugging/ logging purposes
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataFlow.Reasons`1.AreEmpty">
            <summary>
            Property indicating if there's any active reasons. Fired on any thread.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataFlow.Reasons`1.FirstReason">
            <summary>
            First reason in the list. Used for better diagnostics. Fired on any thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Reasons`1.AddReason(JetBrains.Lifetimes.Lifetime,`0)">
            <summary>
            Adds reason for the <see cref="!:lifetime"/>
            </summary>
            <param name="lifetime">Period of time the <see cref="!:reason"/> takes place</param>
            <param name="reason">Reason itself</param>
        </member>
        <member name="M:JetBrains.Util.DataFlow.Reasons`1.GetAllReasons">
            <summary>
            Returns all the reasons active for the moment.
            </summary>
            <returns>Active reasons</returns>
        </member>
        <member name="T:JetBrains.Util.IdentityFunc`2">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IdentityFunc`1">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ValidationException">
            <summary>
            Thrown when a suggested value fails to pass the validation.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.StrongCachedValue`2">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/> that holds value forever until <see cref="M:JetBrains.Util.Caches.StrongCachedValue`2.Clear"/> method is called.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.WeakCachedValueBase`2">
            <summary>
            Base class for both <see cref="T:JetBrains.Util.Caches.WeakParametrizedCachedValue`3"/> and <see cref="T:JetBrains.Util.Caches.WeakCachedValue`2"/>
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCacheItem"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.WeakParametrizedCachedValue`3">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.IParametrizedCachedValue`2"/> that hold value on weak reference.
            Additionally, value is put into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            So weak reference will survive garbage collections until its value is evicted from cache.
            Cache is being touched not every time you invoke <see cref="M:JetBrains.Util.Caches.WeakParametrizedCachedValue`3.GetOrCreate(`1)"/>
            but every [cacheTouchFrequency] time. This allows to mix LRU and LFU policies together and inrease performance.
            </summary>
            <typeparam name="T">type of value </typeparam>
            <typeparam name="TCacheItem">Cache can contains more general type than <typeparamref name="T"/> </typeparam>
            <typeparam name="TState">Type of producer function's parameter</typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.WeakCachedValue`2">
            <summary>
            Implementation of <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/> that hold value on weak reference. Additionally, value is put into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            So weak reference will survive garbage collections until its value is evicted from cache. Cache is being touched not every time you invoke <see cref="M:JetBrains.Util.Caches.WeakCachedValue`2.GetOrCreate"/>
            but every [cacheTouchFrequency] time. This allows to mix LRU and LFU policies together and inrease performance.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCacheItem">Cache can contains more general type than <typeparamref name="T"/> </typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.CacheStatistics">
            <summary>
            Internal helper class for cache statistics gathering. To collect statictics, compile with JET_MODE_STATISTICS #define.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.DirectMappedCache`2">
            <summary>
            Fixed-size cache with only one element for bucket (hashcode % length) retained. http://en.wikipedia.org/wiki/CPU_cache
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.DirectMappedCache`2.GetOrCreate``1(``0,System.Func{``0,`1})">
            <summary>
            Trying to get element from cache. If nothing found, creates from provider.
            </summary>
            <typeparam name="TKeyInheritor">Any inheritor of <typeparamref name="TKey"/> or <typeparamref name="TKey"/> itself</typeparam>
            <param name="key">Key in cache</param>
            <param name="provider">Function that generates value in case when key isn't in cache</param>
            <returns>Value either from cache or generater by <c>producer</c></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.DirectMappedCache`2.GetOrCreate``2(``0,``1,System.Func{``0,``1,`1})">
            <summary>
            Trying to get element from cache. If nothing found, creates from provider.
            This method is useful in case when you don't want to produce additional closure and lambda for functions with 2 parameters
            </summary>
            <typeparam name="TParam">Additional producer's parameter type</typeparam>
            <typeparam name="TKeyInheritor">Any inheritor of <typeparamref name="TKey"/> or <typeparamref name="TKey"/> itself</typeparam>
            <param name="key">Key in cache</param>
            <param name="param">Additional producer's parameter</param>
            <param name="provider">Function that generates value in case when key isn't in cache</param>
            <returns>Value either from cache or generater by <c>producer</c></returns>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedValueBase`1">
            <summary>
            Wrapper over object. Typical usage is <see cref="T:JetBrains.Util.Caches.WeakCachedValue`2"/>.
            </summary>
            <typeparam name="T">type of object</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.Set(`0)">
            <summary>Set object's value</summary>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.Clear">
            <summary>Resets object's value to default</summary>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValueBase`1.TryGet">
            <summary>Get current value in wrapper. If it's null (e.g. weak reference evicted) returns null</summary>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedValue`1">
            <summary>
            Cached value with nonparameterized producer
            </summary>
            <typeparam name="T">type of object</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate">
            <summary>Get current value and if it's null then produce value (using producer func)</summary>
        </member>
        <member name="T:JetBrains.Util.Caches.IParametrizedCachedValue`2">
            <summary>
            Cached value with parameterized producer. Use it in case you don't want to create tons of closure.
            </summary>
            <typeparam name="T">type of object</typeparam>
            <typeparam name="TState">type of addtitional paramater to producer function</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.GetOrCreate(`1)">
            <summary>Get current value and if it's null then produce value (using producer func with parameter)</summary>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.GetOrCreate(`1,`0@,System.Action{`0,`1})">
            <summary>
            Version of GetOrCreate that returns boolean value which designates whether value was created by producer or obtained from cache
            </summary>
            <param name="state"></param>
            <param name="result">gotten or created result</param>
            <param name="afterCreate">Invokes after values is created and is set into cachedValue</param>
            <returns>true if value was created by producer, false - value was in cache already</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IParametrizedCachedValue`2.TryGetSync">
            <summary>Get current value, waiting if current value is being created by "GetOrCreate" method</summary>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateWeakCachedValue``2(System.Func{``0},JetBrains.Util.Caches.IWeakRefRetainerCache{``1},``0,System.Int32)">
            <summary>
            Creates wrapper that contains weak object inside.
            To prevent fast weakref eviction, newly created objects are placed into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            Cache is touched after each invocation of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>.
            If weak reference is evicted (that means object is evicted from cache too) and one invokes <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>,
            producer function is used to create object.
            </summary>
            <typeparam name="T">object's type</typeparam>
            <typeparam name="TCacheItem">type of objects in cache, can be more general than <see cref="!:T"/></typeparam>
            <param name="producer">function that creates object</param>
            <param name="cache">cache that enlarges weakref lifetime</param>
            <param name="initialValue">Optional. If present, object is set to this value.
            Otherwise, object is set to null and will be initialized by producer after first use of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/></param>
            <param name="cacheTouchFrequency"></param>
            <returns>Newly created wrapper with weak reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateWeakParametrizedCachedValue``3(System.Func{``1,``0},JetBrains.Util.Caches.IWeakRefRetainerCache{``2},``0,System.Int32)">
            <summary>
            Creates wrapper that contains weak object inside.
            To prevent fast weakref eviction, newly created objects are placed into <see cref="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1"/>.
            Cache is touched after each invocation of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>.
            If weak reference is evicted (that means object is evicted from cache too) and one invokes <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/>,
            producer function is used to create object.
            </summary>
            <typeparam name="T">object's type</typeparam>
            <typeparam name="TParam">producer parameter's type</typeparam>
            <typeparam name="TCacheItem">type of objects in cache, can be more general than <see cref="!:T"/></typeparam>
            <param name="producer">function that creates object</param>
            <param name="cache">cache that enlarges weakref lifetime</param>
            <param name="initialValue">Optional. If present, object is set to this value.
            Otherwise, object is set to null and will be initialized by producer after first use of <see cref="M:JetBrains.Util.Caches.ICachedValue`1.GetOrCreate"/></param>
            <param name="cacheTouchFrequency"></param>
            <returns>Newly created wrapper with weak reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateStrongCachedValue``1(``0)">
            <summary>
            Creates wrapper around object with hard reference.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="initialValue">Optional. Initial value of hard reference. Null by default.</param>
            <returns>Newly created wrapper with hard reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.CreateStrongParametrizedCachedValue``2(``0)">
            <summary>
            Creates wrapper around object with hard reference.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TParam"></typeparam>
            <param name="initialValue">Optional. Initial value of hard reference. Null by default.</param>
            <returns>Newly created wrapper with hard reference</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})">
            <summary>
            Returns true if cached object has value "right now" (no need to invoke producer).
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <param name="cachedValue">object's wrapper</param>
            <returns>true if <see cref="M:JetBrains.Util.Caches.ICachedValueBase`1.TryGet"/> return true</returns>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.SetIfNull``2(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1})">
            <summary>
            Sets value of object via functor only in case it's null (<see cref="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})"/> returns false). This method is thread-safe.
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <typeparam name="TInheritor">type of functor - inheritor of object's type (to support functor's covariance) </typeparam>
            <param name="cachedValue">object's caching wrapper</param>
            <param name="functor">value producer, is invoked only when current value is null</param>
        </member>
        <member name="M:JetBrains.Util.Caches.CachedValues.SetIfNull``3(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1,``2},``1)">
            <summary>
            Sets value of object via functor only in case it's null (<see cref="M:JetBrains.Util.Caches.CachedValues.HasValue``1(JetBrains.Util.Caches.ICachedValueBase{``0})"/> returns false). This method is thread-safe.
            Functor is parametrized with additional parameter to avoid construction of closure (like it would have been with <see cref="M:JetBrains.Util.Caches.CachedValues.SetIfNull``2(JetBrains.Util.Caches.ICachedValueBase{``0},System.Func{``1})"/>)
            </summary>
            <typeparam name="T">type of cached object</typeparam>
            <typeparam name="TParam">functor's additional parameter type</typeparam>
            <typeparam name="TInheritor">type of functor - inheritor of object's type (to support functor's covariance) </typeparam>
            <param name="cachedValue">object's caching wrapper</param>
            <param name="functor">value producer, is invoked only when current value is null</param>
            <param name="param">functor's additional param</param>
        </member>
        <member name="T:JetBrains.Util.Caches.IDictionaryBasedCache`2">
            <summary>
            Cache represented by fixed-size dictionary. The behavior is the same as <see cref="T:System.Collections.Generic.IDictionary`2"/> but dictionary doesn't grow infinitely.
            When cache is full, newest elements is put into it, evicting old one (latest or least frequently used, depending on policy).
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="T:JetBrains.Util.Caches.IExternalProviderCache`2">
            <summary> Usually cache gets provider (func : TKey - TValue) by constructor, but this interface contains methods that allow to specify arbitrary provider </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.ICachedBackend`2">
            <summary> Interface supports writing "through" cache (like CPU writes to RAM through its L1-L2-L3 cache) </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.ICacheBackendProvider`2">
            <summary> Usually the place from where provider takes values. Like RAM in CPU - Cache - RAM interop </summary>
        </member>
        <member name="T:JetBrains.Util.Caches.IWeakRefRetainerCache`1">
            <summary>
            Cache that has sole purpose to increase the lifetime of weak reference. Used in pair with <see cref="T:JetBrains.Util.Caches.ICachedValue`1"/>.
            You MUST dispose it by lifetime or other way
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Touch(`0)">
            <summary>
            Notify this cache that item was accessed somehow. Cache can react to this event by relocating item is LRU queue, set last access time, increase use count, etc.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Remove(`0)">
            <summary>
            Remove item from cache
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Clear">
            <summary>
            Clear cache, remove all item.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Contains(`0)">
            <summary>
            Returns true if cache contains given item.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Count">
            <summary>
            Returns current number of elements in cache
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.IWeakRefRetainerCache`1.Evict">
            <summary>
            Manually starts eviction procedure. Cache could evict entities by its own rules, (e.g. evict all items with last access time more than 30 sec)
            </summary>
            <returns>Number of elements evicted</returns>
        </member>
        <member name="T:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1">
            <summary>
            Fixed-size cache for clients which use <see cref="T:JetBrains.Util.JetWeakReference`1"/> to store values. Every time outer JetWeakReference accessed , client must invoke <see cref="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.Touch(`0)"/> method.
            This promotes given value to the head of the LRU queue. If queue is full and promoting element is new (queue hasn't cointain it before), least recently used element
            is getting removed from the queue and number of hard links to this value is decreased by one. User can start timer thread that will evict entries with too old last 
            access time.
            WARNING!!! You MUST dispose this object, because it has reference on itself by Timer thread.
            </summary>
            <typeparam name="T">Object's type. <see cref="T:JetBrains.Util.JetWeakReference`1"/> lifetime is going to be increased by this cache</typeparam>
        </member>
        <member name="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.#ctor(JetBrains.Lifetimes.Lifetime,System.Int32,System.Collections.Generic.IEqualityComparer{`0},System.Int64,System.Int32)">
            <summary>
            Creates new cache. Timer is started only when <see cref="!:invalidateTimeInMillis"/> is positive.
            </summary>
            <param name="lifetime">Lifetime of this cache</param>
            <param name="capacity">Maximum number of elements in cache</param>
            <param name="comparer">Optional.</param>
            <param name="invalidateTimeInMillis">Optional (default is zero). After given number of milliseconds, items in cache are concidered outdated and can be replaced
            either by timer thread or manual invocation of <see cref="M:JetBrains.Util.Caches.LRUWeakRefRetainerCache`1.Evict"/> method</param>
            <param name="invalidationSurvivalThreshold"> Number of items that will survive eviction even if they are outdated</param>
        </member>
        <member name="T:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2">
            <summary>
            Unlimited cache that evicts their items by inactivity time using a timer
            It stores and updates access time for each item on TryGetFromCache() and AddToCache() methods
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="E:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2.AfterItemEvicted">
            <summary>
            Called after the specified key is evicted from cache. Called from timer thread.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Caches.UnlimitedInactiveItemsEvictingCache`2.#ctor(JetBrains.Lifetimes.Lifetime,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            
            </summary>
            <param name="lifetime">Lifetime for managing timer</param>
            <param name="evictionAttemptIntervalMs">Eviction attempts interval. Min is 100 ms</param>
            <param name="itemLifetimeToEvictMs">Max age of item. If item is older it will be evicted. Min is 100 ms. Must be greater than <paramref name="evictionAttemptIntervalMs"/></param>
            <param name="comparer">custom comparer</param>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Caches.LifetimeAwareCache`2">
            <summary>
            Represents a simple thread-safe cache that stores items by key until there is any active "usage".
            Each accessor should provide usage-time <see cref="T:JetBrains.Lifetimes.Lifetime"/> to get any item by key.
            Cache guarantees item is stored in cache until all related lifetimes (item is requested with) are terminated.
            </summary>
            <typeparam name="TKey">The type of keys used to access items in cache.</typeparam>
            <typeparam name="TValue">The type of items stored in cache.</typeparam>
        </member>
        <member name="F:JetBrains.Util.DataStructures.Caches.LifetimeAwareCache`2.myCacheLifetime">
            <summary>
            The root lifetime of the cache itself.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Caches.ProlongableLifetime">
            <summary>
            Represents a union of lifetimes that is "alive" until all <see cref="T:JetBrains.Lifetimes.Lifetime"/>s of the union are terminated.
            Exposes a common lifetime for all united lifetimes.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ArrayPart`1">
            <summary>
            Represent an enumerable part of the array without creating new instance of the colleciton and copying data to it
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ArrayPart`1.#ctor(JetBrains.Util.DataStructures.IArray{`0},System.Int32,System.Int32)">
            <param name="array">Initial array.</param>
            <param name="startIndex">Represents the index in the array at which part begins.</param>
            <param name="length">The part elements number.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(JetBrains.Util.DataStructures.ChunkArray{`0},System.Int32,JetBrains.Util.DataStructures.ChunkCollectionMode)">
            <summary>
            Special ctor for <see cref="M:JetBrains.Util.DataStructures.ChunkArray`1.Resize(JetBrains.Util.DataStructures.ChunkArray{`0}@,System.Int32,JetBrains.Util.DataStructures.ChunkCollectionMode)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(System.Int32,JetBrains.Util.DataStructures.ChunkCollectionMode)">
            <summary>
            Creates chunk array of given <paramref name="length"/>.
            </summary>
            <param name="length">The count of array elements</param>
            <param name="mode">The mode how ChunkArray works <see cref="T:JetBrains.Util.DataStructures.ChunkCollectionMode"/> for details</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(System.Collections.Generic.IReadOnlyCollection{`0})">
            <summary>
            Creates chunk array from <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Creates chunk array from <see cref="T:System.Collections.Generic.IEnumerable`1"/> with optimal number of (re)allocations.
            </summary>
            <param name="source"></param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkArray`1.Resize(JetBrains.Util.DataStructures.ChunkArray{`0}@,System.Int32,JetBrains.Util.DataStructures.ChunkCollectionMode)">
            <summary>
            Resizes chunk array (actually creates new one and performs shallow copy of original content) similar to <see cref="M:System.Array.Resize``1(``0[]@,System.Int32)"/>.
            </summary>
            <remarks>
            IMPORTANT! DO NOT USE original array after resize.
            </remarks>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkCollectionMode.AntiLoh">
            <summary>
            Guaranties that any data are not allocated in Large Object Heap.
            Can lead performance losing because of using ChunkArray as internal data structure.
            
            If an array element is bigger than 84500 bytes it is allocated in LOH in any case.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.ChunkCollectionMode.Auto">
            <summary>
            Tries to keep user and internal data out of Large Object Heap but if array size is too big allocates the internal array of chunks in the LOH.
            
            If an array element is bigger than 84500 bytes it is allocated in LOH in any case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkCollectionsExtension.ToChunkList``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            If <paramref name="forceCopy"/> is false and <paramref name="enumerable"/> is <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/> returns the same instance, if no - makes a copy
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkCollectionsExtension.ToChunkArray``1(System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            If <paramref name="forceCopy"/> is false and <paramref name="enumerable"/> is <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/> returns the same instance, if no - makes a copy
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ChunkList`1">
            <summary>
            List splitted to chunks to avoid allocations in LOH.
            The size of chunk is automatically calculated depending on the size of <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.#ctor(System.Int32,System.Int32)">
            <param name="capacity">The number of elements that the new list can initially store. If '0' one chunk of automatically calculated size is created</param>
            <param name="maxChunkSizeInBytes">Maximum amount of bytes in one chunk</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Int32)">
            <param name="capacity">The number of elements that the new list can initially store. If '0' one chunk of automatically calculated size is created</param>
            <param name="enumerable">Initializes a new list that contains elements copied from the specified collection and has sufficient capacity to accommodate
            the number of elements copied.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.#ctor(System.Boolean)">
            <param name="allowDangerousOperations">If true such operations as Insert, Remove, CopyTo are allowed, they are dangerous because since ChunkList
            contains huge elements amount they can be very slow. Also CopyTo contradicts ChunkList purpose because array to copy into will be allocated in LOH. 
            </param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.Clear">
            <summary>
            Removes all elements from the <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/> 
            </summary>
            <remarks>
            <see cref="P:JetBrains.Util.DataStructures.ChunkList`1.Count"/> is set to 0, and references to other objects from elements of the collection are also released.
            Capacity remains unchanged. To reset the capacity of the <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/>, call the TrimExcess method or set the
            Capacity property directly. Decreasing the capacity reallocates memory and copies all the elements in the <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/>.
            This method is an O(n) operation, where n is Count.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.TrimExcess">
            <summary>
            Sets the capacity to the actual number of elements in the <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/>, if that number is less than a threshold value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.Resize(System.Int32)">
            <summary>
            Resizes the list to have <paramref name="count"/> elements.
            </summary>
            <remarks>
            If the list already has more than <paramref name="count"/> elements then nothing happens.<br/>
            All existing elements stay unchanged and new ones will be initialized with the default value.    
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.CopyTo(`0[],System.Int32)">
            <summary>
            DO NOT USE IT
            
            ChunkList is introduced to avoid allocations in LOH and is used to hold very big number of items, <paramref name="array"/> to store this data
            will be allocated in LOH.
            
            Unfortunatelly this method is already used in the code
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.Remove(`0)">
            <summary>
            DO NOT USE IT
            
            ChunkList is introduced to avoid allocations in LOH and is used to hold very big number of items, removing an item will be quite a slow operation.
            Unfortunatelly this method is already used in the code
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.RemoveAt(System.Int32)">
            <summary>
            DO NOT USE IT
            
            ChunkList is introduced to avoid allocations in LOH and is used to hold very big number of items, removing an item will be quite a slow operation.
            Unfortunatelly this method is already used in the code
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ChunkList`1.Insert(System.Int32,`0)">
            <summary>
            DO NOT USE IT
            
            ChunkList is introduced to avoid allocations in LOH and is used to hold very big number of items, inserting an item will be quite a slow operation.
            Unfortunatelly this method is already used in the code
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.CompactMapBase`4">
            <summary>
            Base for all space-optimized hash-maps with only 2 bits overhead for each entry. Implements so called "open-addressing" hash-maps.  
            </summary>
            <typeparam name="TKey">key class</typeparam>
            <typeparam name="TValue">value class</typeparam>
            <typeparam name="TStorage">Class of internal storage. Can be plain array of <c>TData</c> or e.g. packed array for memory optimization.</typeparam>
            <typeparam name="TData">Entry in storage.</typeparam>
        </member>
        <member name="M:JetBrains.Util.DataStructures.CompactOneToListMap`2.RemoveValues(`0,System.Collections.Generic.ICollection{`1})">
            <summary>
            Removes all specified values for given key. Effectiveness of removal depends of implementation of <see cref="!:valuesToRemove"/> - for hashset, time-complexity will be linear
            O(n), where n - number of values in map, corresponding to <see cref="!:key"/>.
            </summary>
            <param name="key"></param>
            <param name="valuesToRemove"></param>
        </member>
        <member name="T:JetBrains.Util.DataStructures.CompactSet`1">
            <summary>
            Collection of distinct (as per <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>) elements with <code>O(1+maxLoadFactor)</code>
            asymptotic time for item's addition, removal and searching and <code>O(1/maxLoadfactor)</code> space usage.
            Actual number of additional heap space for each element (not considering loadFactor's reseve) is 2 bits (comparing to 64 bits in <see cref="T:System.Collections.Generic.JetHashSet`1"/>).
            So for each element <see cref="T:JetBrains.Util.DataStructures.CompactSet`1"/> stores 32 bits for item's reference and 2 bits for state (OCCUPIED, FREE, REMOVED). This set is little bit slower than
            <see cref="T:System.Collections.Generic.JetHashSet`1"/>, so main use case is when you need to retain big set with small items (relative to number of bytes held by item) in memory for a long time 
            (e.g. caches) and you want to economize memory usage.
            </summary>
            <typeparam name="T">Type of item</typeparam>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.HashSetReader`1">
            <summary>
            HashSet wrapper which exposes only read operations .
            Use for better GC optimization.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1">
            <summary>
            A writable array accessor that can be converted into an <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> instance without allocating extra memory.
            If we have the previous results array, we can create a new builder over it, and if running the builder results in exactly the same collection, then the original one will be returned without allocating extra memory.
            </summary>
            <typeparam name="T" />
        </member>
        <member name="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myCapacityForNewBuilder">
            <summary>
            Valid until the builder has been created. Negative means default.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myOriginalArray">
            <summary>
            Valid only when <see cref="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myNewBuilder" /> is <c>NULL</c>.
            Holds the original underlying collection if so.
            All of the operations, as long as they are making the same collection as this one, make no allocations. If it keeps to the end and the count matches, then the original array is returned AS IS.
            As soon as any operation tries to set a conflicting value, or the final count does not match, <see cref="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myNewBuilder" /> gets allocated, takes the already written prefix from this collection, and this one is forgotten.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myPositionInOriginalArray">
            <summary>
            Currently written length of the <see cref="F:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.myOriginalArray" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.#ctor(System.Collections.Immutable.ImmutableArray{`0},System.Collections.Generic.IEqualityComparer{`0},System.Nullable{System.Int32})">
            <summary>
            Reuses the existing array, if given and possible.
            Capacity applies when we decide we need to create a new builder.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Capacity">
            <summary>
            Gets or sets the length of the internal array.
            If a new builder has been created, gets or sets from the builder directly.
            Otherwise, gets either the underlying array capacity or the capacity for the new builder; sets the capacity for the new builder.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Count">
            <summary>Gets or sets the number of items in the array.</summary>
            <returns>The number of items in the array.</returns>
        </member>
        <member name="P:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Item(System.Int32)">
            <summary>Gets or sets the item at the specified index.</summary>
            <param name="index">The index of the item to get or set.</param>
            <exception cref="T:System.IndexOutOfRangeException">The specified index is not in the array.</exception>
            <returns>The item at the specified index.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Add(`0)">
            <summary>Adds the specified item to the array.</summary>
            <param name="item">The object to add to the array.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>Adds the specified items to the end of the array.</summary>
            <param name="items">The items to add to the array.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange(`0[])">
            <summary>Adds the specified items to the end of the array.</summary>
            <param name="items">The items to add to the array.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange``1(``0[])">
            <summary>Adds the specified items that derive from the type currently in the array, to the end of the array.</summary>
            <param name="items">The items to add to end of the array.</param>
            <typeparam name="TDerived">The type that derives from the type of item already in the array.</typeparam>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange(`0[],System.Int32)">
            <summary>Adds the specified items to the end of the array.</summary>
            <param name="items">The items to add to the array.</param>
            <param name="length">The number of elements from the source array to add.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange(System.Collections.Immutable.ImmutableArray{`0})">
            <summary>Adds the specified items to the end of the array.</summary>
            <param name="items">The items to add to the array.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.AddRange(System.Collections.Immutable.ImmutableArray{`0},System.Int32)">
            <summary>Adds the specified items to the end of the array.</summary>
            <param name="items">The items to add to the array.</param>
            <param name="length">The number of elements from the source array to add.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Clear">
            <summary>Removes all items from the array.</summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Contains(`0)">
            <summary>Determines whether the array contains a specific value.</summary>
            <param name="item">The object to locate in the array.</param>
            <returns>
            <see langword="true" /> if the object is found; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.CopyTo(`0[],System.Int32)">
            <summary>Copies the current contents to the specified array.</summary>
            <param name="array">The array to copy to.</param>
            <param name="index">The index to start the copy operation.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.GetEnumerator">
            <summary>Gets an object that can be used to iterate through the collection.</summary>
            <returns>An object that can be used to iterate through the collection.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.IndexOf(`0)">
            <summary>Determines the index of a specific item in the array.</summary>
            <param name="item">The item to locate in the array.</param>
            <returns>The index of <paramref name="item" /> if it's found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.IndexOf(`0,System.Int32)">
            <summary>Determines the index of the specified item.</summary>
            <param name="item">The item to locate in the array.</param>
            <param name="startIndex">The starting position of the search.</param>
            <returns>The index of <paramref name="item" /> if it's found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.IndexOf(`0,System.Int32,System.Int32)">
            <summary>Determines the index of the specified item.</summary>
            <param name="item">The item to locate in the array.</param>
            <param name="startIndex">The starting position of the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The index of <paramref name="item" /> if it's found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.IndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Determines the index for the specified item.</summary>
            <param name="item">The item to locate in the array.</param>
            <param name="startIndex">The index at which to begin the search.</param>
            <param name="count">The starting position of the search.</param>
            <param name="equalityComparer">The equality comparer to use in the search</param>
            <returns>The index of <paramref name="item" /> if it's found in the list; otherwise, -1.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Insert(System.Int32,`0)">
            <summary>Inserts an item in the array at the specified index.</summary>
            <param name="index">The zero-based index at which to insert the item.</param>
            <param name="item">The object to insert into the array.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.ItemRef(System.Int32)">
            <summary>Gets a read-only reference to the element at the specified index.</summary>
            <param name="index">The item index.</param>
            <exception cref="T:System.IndexOutOfRangeException">
            <paramref name="index" /> is greater or equal to the array count.</exception>
            <returns>The read-only reference to the element at the specified index.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.LastIndexOf(`0)">
            <summary>Determines the 0-based index of the last occurrence of the specified item in this array.</summary>
            <param name="item">The item to search for.</param>
            <returns>The 0-based index where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.LastIndexOf(`0,System.Int32)">
            <summary>Determines the 0-based index of the last occurrence of the specified item in this array.</summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The starting position of the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.LastIndexOf(`0,System.Int32,System.Int32)">
            <summary>Determines the 0-based index of the last occurrence of the specified item in this array.</summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The starting position of the search.</param>
            <param name="count">The number of elements to search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.LastIndexOf(`0,System.Int32,System.Int32,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>Determines the 0-based index of the last occurrence of the specified item in this array.</summary>
            <param name="item">The item to search for.</param>
            <param name="startIndex">The starting position of the search.</param>
            <param name="count">The number of elements to search.</param>
            <param name="equalityComparer">The equality comparer to use in the search.</param>
            <returns>The 0-based index into the array where the item was found; or -1 if it could not be found.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Remove(`0)">
            <summary>Removes the specified element.</summary>
            <param name="element">The item to remove.</param>
            <returns>
            <see langword="true" /> if <paramref name="element" /> was found and removed; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.RemoveAt(System.Int32)">
            <summary>Removes the item at the specified index from the array.</summary>
            <param name="index">The zero-based index of the item to remove.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Reverse">
            <summary>Reverses the order of elements in the collection.</summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Sort">
            <summary>Sorts the contents of the array.</summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Sort(System.Comparison{`0})">
            <summary>Sorts the elements in the entire array using the specified <see cref="T:System.Comparison`1" />.</summary>
            <param name="comparison">The <see cref="T:System.Comparison`1" /> to use when comparing elements.</param>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="comparison" /> is null.</exception>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.Sort(System.Collections.Generic.IComparer{`0})">
            <summary>Sorts the contents of the array.</summary>
            <param name="comparer">The comparer to use for sorting. If comparer is <see langword="null" />, the default comparer for the elements type in the array is used.</param>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.ToArray">
            <summary>Creates a new array with the current contents of this <see cref="T:System.Collections.Immutable.ImmutableArray`1.Builder" />.</summary>
            <returns>A new array with the contents of this <see cref="T:System.Collections.Immutable.ImmutableArray`1.Builder" />.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.WithCapacityHint(System.Int32)">
            <summary>
            Hints on what size the collection is expected to have. Fluent, mutable.
            Does not alloc anything immediately until we start creating the new builder.
            Would save mem/copy if we fall off the existing array and have to create a new builder and you exactly predict its writing size. Otherwise, will alloc, but won't fail.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.WithComparer(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Allows to set a nondefault comparer. Fluent, mutable.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <summary>Returns an enumerator that iterates through the array.</summary>
            <returns>An enumerator that iterates through the array.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>Returns an enumerator that iterates through the array.</summary>
            <returns>An enumerator that iterates through the array.</returns>
        </member>
        <member name="P:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <summary>Gets a value that indicates whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</summary>
            <returns>
            <see langword="true" /> if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:JetBrains.Util.DataStructures.Collections.JetImmutableArrayBuilder.CreateNewReusingBuilder``1(System.Collections.Immutable.ImmutableArray{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Creates a new empty (!) builder which has the original array as a backing collection and keeps it as long as you're adding the same items.
            If you are creating the same array once again, there will be no new array allocated.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.ListFromArrayAndCount`1">
            <summary>
            Implementation of IList/IReadOnlyList from array and the amount of first items actually used to store the data.
            Provides support for turning various array-based collections into IList/IReadOnlyList instances
            with allocation-less implementation of enumeration.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.PooledList`1">
            <summary>
            Use this only for building array instances
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.SlimDictionary`2">
            <summary>
            Lightweight Dictionary{TKey,TValue} that do not stores hash code, assumes hash code and key equality computations are fast.
            Only keys implementing IEquatable{T} are supported.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.SlimHashSet`1">
            <summary>
            Lightweight HashSet{T} that do not stores hash code, assumes hash code and equality computations are fast.
            Only values implementing IEquatable{T} are supported.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.Collections.StackLocalList`1">
            <summary>
            Represents collection of items that doesn't create heap objects unless <see cref="F:JetBrains.Util.DataStructures.Collections.StackLocalList`1.MaxInlineCount"/> items are added.
            Should only be used in rare scenarios where it's critical to reduce the amount heap allocations to get the T[] array
            or IList/IReadOnlyList instances of the size unknown in advance.
            The indexing and enumerations operations over this collections are not efficient in terms of CPU, so it's better
            to stick with simple .Add() + .ReadonlyList()/.ToArray() scenarios.
            The type is made 'ref struct' to avoid storing it inside the field and capturing it into closures,
            however it is still possible to pass and return it by value which you should avoid give the size of the struct.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DataStructures.Collections.StackLocalList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:JetBrains.Util.DataStructures.Collections.StackLocalList`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.QuickSorter.QuickSort``1(JetBrains.Util.DataStructures.IArray{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place quick sort with random pivot and without recursion.
            </summary>
            <remarks>
            Sort is in-place, use it carefully if concurrent access to <paramref name="array"/> is possible.<br/>
            <br/>
            Due to performance reason the specific implementations for concrete types are provided:<br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/><br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/><br/>
            * <see cref="T:JetBrains.Util.DataStructures.ArrayPart`1"/><br/>
            <br/>
            See benchmarks in class comments.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.QuickSorter.QuickSort``1(JetBrains.Util.DataStructures.ChunkArray{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place quick sort with random pivot and without recursion.
            </summary>
            <remarks>
            Method is introduced for performance reason, it returns <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/> instead of <see cref="T:JetBrains.Util.DataStructures.IArray`1"/> and
            keep all subsequent calls "class" not "interface"
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.QuickSorter.QuickSort``1(JetBrains.Util.DataStructures.ChunkList{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place quick sort with random pivot and without recursion.
            </summary>
            <remarks>
            Method is introduced for performance reason, it returns <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/> instead of <see cref="T:JetBrains.Util.DataStructures.IArray`1"/> and
            keep all subsequent calls "class" not "interface"
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSort``1(JetBrains.Util.DataStructures.IArray{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort. Complexity = O(N log N) Memory = O(N)
            </summary>
            <remarks>
            Sort is in-place, use it carefully if concurrent access to <paramref name="array"/> is possible.<br/>
            Allocates additional chunked array of the same size (no LOH allocations).<br/>
            The only estimated progress is reported, not necessary reaches 100%.<br/>
            <br/>
            Due to performance reason the specific implementations for concrete types are provided:<br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/><br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/><br/>
            * <see cref="T:JetBrains.Util.DataStructures.ArrayPart`1"/><br/>
            <br/>
            See benchmarks in class comments.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSort``1(System.Collections.Generic.IList{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort. Complexity = O(N log N) Memory = O(N)
            </summary>
            <remarks>
            Sort is in-place, use it carefully if concurrent access to <paramref name="list"/> is possible.<br/>
            Allocates additional chunked array of the same size (no LOH allocations).<br/>
            <br/>
            Due to performance reason the specific implementations for concrate types are provided:<br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/><br/>
            * <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/><br/>
            * <see cref="T:System.Collections.Generic.List`1"/><br/>
            <br/>
            See benchmarks in class comments.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSort``1(JetBrains.Util.DataStructures.ChunkArray{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort. Complexity = O(N log N) Memory = O(N)
            </summary>
            <remarks>
            Method is introduced for performance reason, it returns <see cref="T:JetBrains.Util.DataStructures.ChunkArray`1"/> instead of <see cref="T:JetBrains.Util.DataStructures.IArray`1"/> and
            keep all subsequent calls "class" not "interface".
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSort``1(JetBrains.Util.DataStructures.ChunkList{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort. Complexity = O(N log N) Memory = O(N)
            </summary>
            <remarks>
            Method is introduced for performance reason, it returns <see cref="T:JetBrains.Util.DataStructures.ChunkList`1"/> instead of <see cref="T:JetBrains.Util.DataStructures.IArray`1"/> and
            keep all subsequent calls "class" not "interface".
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSort``1(System.Collections.Generic.List{``0},System.Comparison{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort. Complexity = O(N log N) Memory = O(N)
            </summary>
            <remarks>
            Method is introduced for performance reason, it returns <see cref="T:System.Collections.Generic.List`1"/> instead of <see cref="T:System.Collections.Generic.IList`1"/> and
            keep all subsequent calls "class" not "interface".
            </remarks>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSortBy``2(JetBrains.Util.DataStructures.ChunkArray{``1},System.Func{``1,``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort by keys. Complexity = O(N log N) Memory = O(N)
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.StableSortBy``2(JetBrains.Util.DataStructures.ChunkArray{``1},JetBrains.Util.DataStructures.ChunkArray{``0},JetBrains.Util.Misc.JetProgress)">
            <summary>
            In-place stable (merge) sort by keys. Complexity = O(N log N) Memory = O(N)
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.StableSorter.SetTemporaryStoreForCurrentThread(System.Object)">
            <summary>
            Sets temporary store (either ChunkArray or ChunkList) in context of current thread.
            </summary>
            <remarks>
            IMPORTANT! Caller MUST prevent provided store from being GC-ed, because internally temporary store weak referenced.<br/>
            <br/>
            This is advanced technique used for example by parallel sorter.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ObjectPool`1">
             <summary>
             Simple data structure to allow reference type object pooling to avoid memory traffic.
            
             For most of the memory traffic issues around collections use just make use of pooled
             collections like <see cref="T:JetBrains.Util.DataStructures.Collections.PooledHashSet`1"/> or <see cref="T:JetBrains.Util.DataStructures.Collections.PooledStringBuilder"/>.
            
             How to use:
             * Use <see cref="M:JetBrains.Util.DataStructures.ObjectPool`1.Allocate"/> to do the allocation via factory provided to constructor.
             * Use <see cref="M:JetBrains.Util.DataStructures.ObjectPool`1.Return(`0)"/> to return object back to the pool or <see cref="M:JetBrains.Util.DataStructures.ObjectPool`1.Forget(`0)"/>
               when you decided not to allow later reuse of the object (object became to big?).
            
             To monitor memory leaks uncomment DETECT_LEAKS and TRACE_LEAKS in this file.
             </summary>
             <typeparam name="T">The object type you need to pool</typeparam>
        </member>
        <member name="M:JetBrains.Util.DataStructures.PrimeFinder.NextPrime(System.Int32)">
             Returns a prime number which is <code>&gt;= desiredCapacity</code>
             and very close to <code>desiredCapacity</code> (within 11% if
             <code>desiredCapacity &gt;= 1000</code>).
            
             @param desiredCapacity the capacity desired by the user.
             @return the capacity which should be used for a hashtable.
        </member>
        <member name="F:JetBrains.Util.DataStructures.PrimeFinder.Table">
            <summary>
            Table of prime numbers from 2 to 10000
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.RandomAccessViewOnSequentialStreamHelpers.ReadSequentialStream``1(JetBrains.Util.dataStructures.ImmutableByteStream,System.Func{System.IO.Stream,``0})">
            <summary>
            If this immutable stream is but a view over a sequential stream, attempts to create a direct clone of the sequential stream for best-performance sequential reading (without memory caching overhead to implement seekability).
            Otherwise, just reads the immutable byte stream as it is.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.RandomAccessViewOnSequentialStreamHelpers.ReadSequentialStream(JetBrains.Util.dataStructures.ImmutableByteStream,System.Action{System.IO.Stream})">
            <inheritdoc cref="M:JetBrains.Util.DataStructures.RandomAccessViewOnSequentialStreamHelpers.ReadSequentialStream``1(JetBrains.Util.dataStructures.ImmutableByteStream,System.Func{System.IO.Stream,``0})" />
        </member>
        <member name="T:JetBrains.Util.DataStructures.ReadOnlyException">
            <summary>Represents the exception that is thrown when you try to change the value of a read-only entity.</summary>
        </member>
        <member name="T:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable">
            <summary>
            Dangerous! Takes an existing stream and guises it as if immutable. Make sure the data in the stream is really not modified, and all the clones yield the same data.
            This class assumes you can produce as many independent reading streams as needed, so it makes a new instance for each clone, and maps position directly to the implementation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.#ctor(System.Func{System.IO.Stream})">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.CanTimeout">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.Length">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.Position">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.ReadTimeout">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.CopyToAsync(System.IO.Stream,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.EndRead(System.IAsyncResult)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.Read(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.ReadAsync(System.Byte[],System.Int32,System.Int32,System.Threading.CancellationToken)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.ReadByte">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.Seek(System.Int64,System.IO.SeekOrigin)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.ShallowClone">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.ReinterpretStreamAsImmutable.WithNoLifetime">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.DataStructures.UserDataWrapper">
            <summary>
            A strongly-typed wrapper for untyped user data which is just an object. You need this when passing user data along the call chain without messing up the objects.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DataStructures.UserDataWrapper.Equals(JetBrains.Util.DataStructures.UserDataWrapper)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.UserDataWrapper.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.UserDataWrapper.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.DataStructures.UserDataWrapper.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.ArrayEqualityComparer`1.Compare(`0[],`0[])">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.ArrayEqualityComparer`1.Equals(System.Collections.Immutable.ImmutableArray{`0},System.Collections.Immutable.ImmutableArray{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.ArrayEqualityComparer`1.GetHashCode(System.Collections.Immutable.ImmutableArray{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.ArrayEqualityComparer`1.Compare(System.Collections.Immutable.ImmutableArray{`0},System.Collections.Immutable.ImmutableArray{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.MurmurHash3(System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash v3, which is a public domain algorithm.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.BinarySearch(JetBrains.Util.PersistentMap.UnsafeIntArray,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return leftmost index of found item or binary complement (~) of insertion index
            </summary>
            <param name="array">non-decreasing sorted array</param>
            <param name="lo">lower index of search (inclusive)</param>
            <param name="hi">high index of search (inclusive)</param>
            <param name="val">value to search</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.BinarySearch(JetBrains.Util.PersistentMap.UnsafeIntArray,System.Int32)">
            <summary>
            Return leftmost index of found item or binary complement (~) of insertion index
            <param name="array">non-decreasing sorted array</param>
            <param name="val">value to search</param>
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.DistinctSorted(JetBrains.Util.PersistentMap.UnsafeIntArray)">
            <summary>
            Remove duplicates if array is sorted and returns length of new array
            </summary>
            <returns>new length</returns>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.IsSorted(JetBrains.Util.PersistentMap.UnsafeIntArray,System.Boolean)">
            <summary>
            O(n)
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.WhereNotNull``1(``0[])">
            <summary>
            Returns an array which has the NULL items filtered out. If there were none such, returns the original array.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.WhereNotNull``1(System.Nullable{``0}[])">
            <summary>
            Returns an array which has the NULL items (of a nullable value type) filtered out. Lifts the nullable modifier.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.WhereNotNull``1(System.Collections.Immutable.ImmutableArray{``0})">
            <summary>
            Returns an array which has the NULL items filtered out. If there were none such, returns the original array.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.WhereNotNull``1(System.Collections.Immutable.ImmutableArray{System.Nullable{``0}})">
            <summary>
            Returns an array which has the NULL items (of a nullable value type) filtered out. Lifts the nullable modifier.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ArrayUtil.MoveOrCopyToImmutableArray``1(System.Collections.Immutable.ImmutableArray{``0}.Builder)">
            <summary>
            Reuses the builder's internal array if its size fits (like <see cref="M:System.Collections.Immutable.ImmutableArray`1.Builder.MoveToImmutable" />), or makes a new one if not.
            </summary>
        </member>
        <member name="T:JetBrains.Util.BinarySearchResult`1">
            <seealso cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)"/>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.HitIndex">
            <summary>
            Gets the index of the search hit, should there be any.
            In case of a search miss, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.HitItem">
            <summary>
            If the search found an item, returns that item. Otherwise, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex2">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            Makes stable order if you're doing binsearch with <see cref="F:JetBrains.Util.dataStructures.OfEqualItems.TakeLast" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.IsHit">
            <summary>
            Gets whether the search found any results.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotAboveTargetOrMinus1">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns -1.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTargetOrCount">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns the number of items in the list (the first free index).
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestIndexNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchResult`1.NearestItemNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)">
            <summary>
            Inserts an item into a sorted array so that to maintain the sorting order.
            </summary>
            <returns>The index the item was inserted at (equals to <see cref="P:JetBrains.Util.BinarySearchResult`1.InsertAtIndex" />).</returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)">
            <summary>
              <para>Searches a one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for a value using the binary search algorithm.</para>
              <para>The desired item is identified by its so-called key given in <paramref name="keyLookFor" />, and a transformation is defined as <paramref name="FGetKeyOfItem" /> for getting a key out of each list item. The comparison (and list sorting requirement) applies to these keys derived from the items.</para>
              <para>Optionally, the comparer could be overridden. This is recommended for custom value types to avoid boxing, unless they're <see cref="T:System.IComparable`1" />.</para>
              <para>The advantage of this method over the one using a locator, <see cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})" />, is that it can work on cached delegates/comparers and does not require creating a closure for each new location session. Also, there's no locator left-right argument confusion.</para>
            </summary>
            <typeparam name="TItem">Type of the actual items in the list.</typeparam>
            <typeparam name="TKey">Type of the so-called key by which the items are sorted and located in the list. This could be either an actual field/property of the item, or a completely synthetic value calculated on the item.</typeparam>
            <param name="list">The list of items to search. Must be sorted by their keys.</param>
            <param name="keyLookFor">Key we're looking for. If it is equal to a key of some item in the list, that item is returned as a search result. If no items correspond to the key, the result points in between array items, see return value members for telling this cases apart or using the found location, for example, <see cref="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)" />.</param>
            <param name="index">Starting index of the list range to search in. <c>0</c> is the default.</param>
            <param name="length">Length of the list range to search in. <c>-1</c> is the default and means that the whole list must be searched.</param>
            <param name="FGetKeyOfItem">
              <para>A transformation which produces a key for any of the list items. Items are sorted by these keys, and keys are used for locating items. This could be either an actual field/property of the item, or a completely synthetic value calculated on the item.</para>
              <para>In performance-critical scenarios, cache this delegate. Normally it's a static method and thus does not require a new closure each time.</para>
            </param>
            <param name="keycomparer">A custom comparer over item keys, if needed. If omitted, the <see cref="P:System.Collections.Generic.Comparer`1.Default">standard comparer</see> is used.</param>
            <param name="which">If there're multiple equal items in the list, which one of them should be taken for a hit.</param>
            <returns>The search result which can tell you if any item was hit, at which index to insert the new item, what's the closest index before/after the search target, and so on.</returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},``0,System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)">
            <summary>
              <para>Searches a one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for a value using the binary search algorithm.</para>
              <para>This overload does comparison right on the items. If the list is sorted by just one property of the item, use the overload with item-key metaphor.</para>
              <para>Optionally, the comparer could be overridden. This is recommended for custom value types to avoid boxing, unless they're <see cref="T:System.IComparable`1" />.</para>
              <para>The advantage of this method over the one using a locator, <see cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})" />, is that it can work on cached delegates/comparers and does not require creating a closure for each new location session. Also, there's no locator left-right argument confusion.</para>
            </summary>
            <typeparam name="TItem">Type of the actual items in the list. They're the sorting keys of the list as well.</typeparam>
            <param name="list">The list of items to search. Must be sorted by their keys.</param>
            <param name="itemLookFor">Item we're looking for, which itself is also the sorting/search key. If it is equal to some item in the list, that item is returned as a search result. If no items are hit, the result points in between array items, see return value members for telling this cases apart or using the found location, for example, <see cref="M:JetBrains.Util.BinarySearchResult`1.InsertAt(`0)" />.</param>
            <param name="index">Starting index of the list range to search in. <c>0</c> is the default.</param>
            <param name="length">Length of the list range to search in. <c>-1</c> is the default and means that the whole list must be searched.</param>
            <param name="keycomparer">A custom comparer over items, if needed. If omitted, the <see cref="P:System.Collections.Generic.Comparer`1.Default">standard comparer</see> is used.</param>
            <param name="which">If there're multiple equal items in the list, which one of them should be taken for a hit.</param>
            <returns>The search result which can tell you if any item was hit, at which index to insert the new item, what's the closest index before/after the search target, and so on.</returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},System.Int32,System.Int32,JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="index"></param>
            <param name="length"></param>
            <param name="locator">The comparer to use when comparing elements. Locator should return: -1 when its argument is less than expected, 0 when equal, 1 when greater</param>
            <returns>The index of the specified value in the specified array, if value is found. If value is not found and value is less than one or more elements in array, a negative number which is the bitwise complement of the index of the first element that is larger than value. If value is not found and value is greater than any of the elements in array, a negative number which is the bitwise complement of (the index of the last element plus 1). </returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearch``1(System.Collections.Generic.IList{``0},JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="locator">The comparer to use when comparing elements. Locator should return: -1 when its argument is less than expected, 0 when equal, 1 when greater</param>
            <returns>The index of the specified value in the specified array, if value is found. If value is not found and value is less than one or more elements in array, a negative number which is the bitwise complement of the index of the first element that is larger than value. If value is not found and value is greater than any of the elements in array, a negative number which is the bitwise complement of (the index of the last element plus 1). </returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearchEx``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for the index of a specific value.
            </summary>
            <typeparam name="TItem">The type of the elements of the list.</typeparam>
            <param name="ths">The sorted list to search.</param>
            <param name="item">The item to find.</param>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.BinarySearchEx``1(System.Collections.Generic.IList{``0},JetBrains.Util.Locator{``0})">
            <summary>
            Searches an entire one-dimensional sorted <see cref="T:System.Collections.Generic.IList`1" /> for a value using the specified <paramref name="locator">comparer</paramref>.
            </summary>
            <typeparam name="T">The type of the elements of the list.</typeparam>
            <param name="list">The sorted list to search.</param>
            <param name="locator">The comparer to use when comparing elements. Delegate should compare its parameter to the item you're looking for. Locator should return: -1 when its argument is less than expected, 0 when equal, 1 when greater</param>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.GetOrCreateValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Func{``1})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list).
            Returns the found item.
            If not found, creates a new item, insers into the list on the proper position to maintain sorting, and returns this new item.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="FCreateIfMissing">If the item is not found, this functor is called to create a new item.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.RemoveValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list), and removes it.
            Returns whether the item was found.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtil.TryGetValue``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0})">
            <summary>
            Looks up an item in a binary-search-ready (sorted) list which is being used as a dictionary (values stored in the list are associated with some kind of keys which you use for comparing items in the list).
            Returns the found item.
            If not found, returns <c>Null</c> coerced to the item type.
            </summary>
            <typeparam name="TValue"></typeparam>
            <typeparam name="TKey"></typeparam>
            <param name="list">Sorted list.</param>
            <param name="FGetKeyOfItem">The transformation for getting a key ot of an item stored in the list.</param>
            <param name="key">The key whose item you would like to find in the list.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.BinarySearchUtilReadonlyList">
            <summary>
            Clone of <see cref="T:JetBrains.Util.BinarySearchUtil" /> for the <see cref="T:System.Collections.Generic.IReadOnlyList`1" /> case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchRo``2(System.Collections.Generic.IReadOnlyList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)">
            <inheritdoc cref="M:JetBrains.Util.BinarySearchUtil.BinarySearch``2(System.Collections.Generic.IList{``1},``0,System.Func{``1,``0},System.Collections.Generic.IComparer{``0},System.Int32,System.Int32,JetBrains.Util.dataStructures.OfEqualItems)" />
        </member>
        <member name="T:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1">
            <seealso cref="!:BinarySearchUtilReadonlyList.BinarySearch&lt;TKey,TItem&gt;" />
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.HitIndex">
            <summary>
            Gets the index of the search hit, should there be any.
            In case of a search miss, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.HitItem">
            <summary>
            If the search found an item, returns that item. Otherwise, throws.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.InsertAtIndex">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.InsertAtIndex2">
            <summary>
            If you're maintaining a sorted array, use this index for inserting new elements.
            Makes stable order if you're doing binsearch with <see cref="F:JetBrains.Util.dataStructures.OfEqualItems.TakeLast" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.IsHit">
            <summary>
            Gets whether the search found any results.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotAboveTargetOrMinus1">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns -1.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotBelowTargetOrCount">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns the number of items in the list (the first free index).
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestIndexNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestItemNotAboveTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestItemNotAboveTargetOrFirst">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item below the target.
            If the first item in the list is above the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestItemNotBelowTarget">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, throws an exception.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BinarySearchUtilReadonlyList.BinarySearchResultRo`1.NearestItemNotBelowTargetOrLast">
            <summary>
            The target, if the search had a hit.
            Otherwise, the nearest item above the target.
            If the last item in the list is below the target, returns that item anyway. Throws on an empty list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Peek``1(System.Collections.Generic.IList{``0})">
            <summary>Stack-like peek operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Pop``1(System.Collections.Generic.IList{``0})">
            <summary>Stack-like pop operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Push``1(System.Collections.Generic.IList{``0},``0)">
            <summary>Stack-like push operation for lists.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AssertEquivalentTo(System.Collections.IEnumerable,System.Collections.IEnumerable,JetBrains.Util.OnError)">
            <summary>
            Asserts the collections have the same set of items (in any order).
            Similar to NUnit's <c>CollectionAssert.AreEquivalent</c>, but shows some readable output (the former would just dump both collections, and go guess the diff).
            </summary>
            <param name="ths">The collection to validate.</param>
            <param name="expected">The expected set of items.</param>
            <param name="onerror">Throw, collect, etc.</param>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AssertEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},JetBrains.Util.OnError,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Asserts the collections have the same set of items (in any order).
            Similar to NUnit's <c>CollectionAssert.AreEquivalent</c>, but shows some readable output (the former would just dump both collections, and go guess the diff).
            </summary>
            <param name="ths">The collection to validate.</param>
            <param name="expected">The expected set of items.</param>
            <param name="onerror">Throw, collect, etc.</param>
            <param name="itemcomparer">Custom strategy for items equality.</param>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEquivalentTo``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Equivalent means distinct collections (discarding duplicates) are equals as sets (disregarding order)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EqualItemsContainedIn``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.ICollection{``0})">
            <summary>
            This method is dangerous in two ways:
            * Quadratic complexity if <paramref name="set2"/> instance do not implements fast <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
              operation. Only ISet instance are safe to be passed as <paramref name="set2"/> argument.
            * Only checks that all <paramref name="set1"/> items are contained in <paramref name="set2"/>, but not the other way around.
              Yes, 'new[] { 1, 1 }.EqualItemsContainedIn(new[] { 1, 2 })' returns 'true'.
            </summary>
            <remarks>Generally, you should use <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/> instead of this method.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EqualItemsContainedInReadOnly``1(System.Collections.Generic.IReadOnlyCollection{``0},System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
            This method is dangerous in two ways:
            * Quadratic complexity if <paramref name="set2"/> instance do not implements fast <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
              operation. Only ISet instance are safe to be passed as <paramref name="set2"/> argument.
            * Only checks that all <paramref name="set1"/> items are contained in <paramref name="set2"/>, but not the other way around.
              Yes, 'new[] { 1, 1 }.EqualItemsContainedInReadOnly(new[] { 1, 2 })' returns 'true'.
            </summary>
            <remarks>Generally, you should use <see cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})"/> instead of this method.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Tries to determine the number of elements in <paramref name="enumerable"/> in <c>O(1)</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast(System.Collections.ICollection)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetCountFast(System.String)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if length of <paramref name="enumerable"/> can be checked fast and this check gives <c>0</c>.
            Otherwise returns <c>false</c> (it does not necessarily mean that <paramref name="enumerable"/> is not empty)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast(System.Collections.ICollection)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenEmptyFast(System.String)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if length of <paramref name="enumerable"/> can be checked fast and this check does not give <c>0</c>.
            Otherwise return <c>false</c> (it does not necessarily mean that <paramref name="enumerable"/> is empty!)
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast``1(System.Collections.Generic.ICollection{``0})">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast(System.Collections.ICollection)">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CanBeProvenNonEmptyFast(System.String)">
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> is empty (has no elements).
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(JetBrains.Util.LocalList{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsEmpty``1(System.Collections.Generic.Queue{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> is empty (has no elements).
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(JetBrains.Util.LocalList{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.Stack{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.Queue{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> is empty (has no elements).
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsSingle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has exactly 1 element.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.IsSingle``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has exactly 1 element.
            </summary>
            <remarks>
            Static overload to prevent runtime type checks.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has <paramref name="minimumCount"/> elements or more.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has <paramref name="minimumCount"/> elements or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasAtLeast(System.String,System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has <paramref name="minimumCount"/> characters or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has 2 elements or more.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple``1(System.Collections.Generic.ICollection{``0})">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has 2 elements or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMultiple(System.String)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has 2 characters or more.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="enumerable"/> has more than <paramref name="exclusiveLowerBound"/> elements.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="collection"/> has more than <paramref name="exclusiveLowerBound"/> elements.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.HasMoreThan(System.String,System.Int32)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="str"/> has more than <paramref name="exclusiveLowerBound"/> characters.
            </summary>
            <remarks>Static overload to prevent runtime type checks.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CountIs``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CountIs(System.String,System.Int32)">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.FirstNotNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns first not null element. If collection is empty or all elements are null, returns null
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.FirstNotNull``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>
            Returns first not null element. If collection is empty or all elements are null, returns null
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns element of the single-item sequence or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when sequence contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(System.Collections.Generic.IList{``0},``0)">
            <summary>
            Returns element of the single-item list or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when list contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SingleItem``1(``0[],``0)">
            <summary>
            Returns element of the single-item array or default(T) value otherwise.
            Just like .SingleOrDefault(), but doesn't throws when array contains multiple items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SelectNotNull``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Nullable{``1}})">
            <summary>
            Projects each element of a sequence into a new form of a nullable value type,
            and yields the values out of those nullables which are not <c>NULL</c>.
            </summary>
            <remarks>Once this used to return still a nullable type, but it's logical to coerce
            to the real value type if we're throwing away NULLs, and inspecting usages confirmed this.</remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AddRangeFluent``2(``1,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Fluent <c>AddRange</c>, returns the collection, can be used in chains and in field initializers.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.RemoveRange``2(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Removes given elements from collection using <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/> method.
            For source collection implemented as list time will be O(n*m), for hashset - O(m)
            where n - number of elements in source collection, m - number of elements in remove-list.
            </summary>
            <typeparam name="TTarget"></typeparam>
            <typeparam name="TSource"></typeparam>
            <param name="collection"></param>
            <param name="items"></param>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AsReadOnly``1(JetBrains.Util.JetReadOnlyCollection{``0})">
            <summary>Static overload to prevent runtime type checks.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AsReadOnly``2(System.Collections.ObjectModel.ReadOnlyDictionary{``0,``1})">
            <summary>Static overload to prevent runtime type checks.</summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Sort``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IComparer{``0})">
            <summary>
            WARNING: Sometimes it sorts collection in-place
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyDfs``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Depth-First Search, does not use additional memory, but puts a strain on the call stack.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyBfs``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Breadth-First Search, does not use call stack, but allocates some additional memory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.EnumerateRecursivelyBfsDistinct``1(``0,System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Enumerates the tree structure recursively. The tree includes the root element <paramref name="root"/> itself,
            its children, as gotten from <paramref name="getChildren"/>, and the children of those children, and so on.
            The walk uses Breadth-First Search, does not use call stack, but allocates some additional memory.
            The results are collected in a hash set, so infinite recursion is processed correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that silently returns <c>null</c>
            when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.TryGetValueNullable``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that silently returns <c>null</c>
            when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.String)">
            <summary>
            A <see cref="!:IDictionary&lt;TKey,TValue&gt;.Item"/> version that throws the explicit <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            exception text when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetValue``3(System.Collections.Generic.IDictionary{``0,``1},``0,System.String,``2)">
            <summary>
            A <see cref="!:IDictionary&lt;TKey,TValue&gt;.Item"/> version that throws the explicit <see cref="T:System.Collections.Generic.KeyNotFoundException"/>
            exception text when the <paramref name="key"/> is not present in the <paramref name="dictionary"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given by <paramref name="factory"/> in this case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``0,``1})">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given by <paramref name="factory"/> in this case.
            </summary>
            <remarks>
            This version takes a function of the key to allow caching the value-creation delegate without creating a new closure each time,
            as <see cref="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,System.Func{``1})"/> would do.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.GetOrCreateValue``2(System.Collections.Generic.IDictionary{``0,``1},``0,``1)">
            <summary>
            A <see cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)"/> version that adds a new entry the <paramref name="key"/>
            is not present in the <paramref name="dictionary"/>. The new value is given as <paramref name="altValue"/> in this case.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.String,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.Text.StringBuilder,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AggregateString``2(System.Collections.Generic.IEnumerable{``0},System.Text.StringBuilder,System.String,System.Func{System.Text.StringBuilder,``0,System.Text.StringBuilder},System.Func{System.Text.StringBuilder,``1})">
            <summary>
            Aggregates a number of items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings
            when concatenating. Use its <see cref="M:System.Text.StringBuilder.AppendFormat(System.String,System.Object[])"/> method as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayUnion``1(``0[],``0)">
            <summary>
            <para>Creates a new array that is the old array plus one new item.</para>
            <para>If the item is already present in the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to add.</param>
            <returns>The new array, if item added; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayUnion``1(``0[],``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            <para>Creates a new array that is the old array plus one new item.</para>
            <para>If the item is already present in the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to add.</param>
            <param name="comparer">Item equality.</param>
            <returns>The new array, if item added; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayExcept``1(``0[],``0)">
            <summary>
            <para>Creates a new array that is the old array except the given item.</para>
            <para>If the item is not on the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="ths">Original array (will not be modified).</param>
            <param name="item">The item to remove.</param>
            <returns>The new array, if item removed; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ArrayExcept``1(``0[],``0,System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            <para>Creates a new array that is the old array except the given item.</para>
            <para>If the item is not on the list, returns the old array.</para>
            <para>This method is useful for implementing the copy-on-write scenarios a bit more effectively (compared to old.Concat(item).ToArray()).</para>
            </summary>
            <typeparam name="T">Item type.</typeparam>
            <param name="array">Original array (will not be modified).</param>
            <param name="item">The item to remove.</param>
            <param name="comparer">Item equality.</param>
            <returns>The new array, if item removed; the old array, if no change.</returns>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Add``1(System.Collections.Generic.ICollection{``0},JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            Temporarily adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>,
            for the period of time defined by the <paramref name="lifetime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AddLocked``1(System.Collections.Generic.ICollection{``0},JetBrains.Lifetimes.Lifetime,System.Func{System.IDisposable},``0)">
            <summary>
            Temporarily adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"/>,
            for the period of time defined by the <paramref name="lifetime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.AddRange``1(System.Collections.Generic.ICollection{``0},JetBrains.Lifetimes.Lifetime,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Temporarily adds the elements of the specified collection to the end of the <see cref="T:System.Collections.Generic.ICollection`1"/>,
            for the period of time defined by the <paramref name="lifetime"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.Deconstruct``2(System.Linq.IGrouping{``0,``1},``0@,System.Collections.Generic.IEnumerable{``1}@)">
            <summary>
            A helper that allows enumerating IGrouping values like if the groupings
            were represented with '(TKey key, IEnumerable{TValue} values)' tuple.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.CopyTo``1(System.Collections.Generic.IEnumerable{``0},``0[],System.Int32)">
            <summary>
            A helper for quickly implementing <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)" /> on a collection class which already can do enumeration.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.SafeOfType``1(System.Collections.IEnumerable)">
            <summary>
            <para>A less-throwing version of <see cref="M:System.Linq.Enumerable.OfType``1(System.Collections.IEnumerable)"/>.</para>
            <para>Accepts <c>Null</c> input, yielding an empty collection.</para>
            <para>Drops exceptions in <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>.</para>
            <para>Does not mitigate exceptions in <see cref="M:System.Collections.IEnumerator.MoveNext"/> / <see cref="P:System.Collections.IEnumerator.Current"/>, though.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.CollectionUtil.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
             <summary>
             This extension method sucks in many ways:
            
             * We all familiar with C# statements like 'foreach', 'using', 'if' and other. If you are dealing with booleans,
               why would you define If(() => condition, () => then, () => else) method? Typical 'foreach' loops are no different,
               we already have a language construct to do the iteration and there is no real need to "virtualize" the language.
            
             * '.ForEach()' is easier to type than the 'foreach' statement - this is no longer true thanks to '.foreach' postfix
               template available in ReSharper out-of-box. Also, generally it's not a good idea to do _imperative_ '.ForEach()' loop
               in the end of multi-line _declarative_ LINQ query. Having separate variable for LINQ sequence + imperative 'foreach'
               loop below is a better choice and a bit easier to debug (you can see the sequence contents).
            
             * Inside imperative loops C-like languages do supports 'continue;' and 'break;' statements we all familiar with. Well,
               '.ForEach()' extension kinda supports 'continue;' too, but it is represented with 'return;' inside lambda expression -
               not very clear, right? This also means you can't do 'return' from containing method out of '.ForEach()' loop.
            
             * You just can't do enumeration with '.ForEach()' over all the things C#'s 'foreach' statement can enumerate,
               including our LocalList{T} collection or old non-generic collections.
            
             And if performance matters for you, avoiding '.ForEach()' is even more solid choice:
            
             * Usages of '.ForEach()' method often produce unnecessary closures (since to do something useful inside a loop
               you have to capture something in lambda). Closures introduce additional GC pressure just to do such a basic task
               of iterating over the enumerable sequence.
            
             * With '.ForEach()' method you are basically throwing away all the optimizations C# 'foreach' statement performs
               for popular collection types like List{T}. Ordinary 'foreach' over List{T} would not allocate heap memory AT ALL +
               most of List{T}.Enumerator member invocations would be inlined. For contrast, '.ForEach()' call would normally make
               1 allocation for delegate instance + 1 allocation for closure class + 1 allocation of IEnumerator{T} instance + ~n*2
               interface calls via IEnumerator{T} interface.
            
             * CLR performs "inline caching" technique to perform fast(er) calls of interface members. If some 'foreach' loop iterates
               over IEnumerable{T}s that are always List{T} instances at runtime, the inline cache for method containing this 'foreach'
               loop will take advantage of this invariant and would produce faster MoveNext()/Current calls.
            
             </summary>
             <remarks>You can use "To foreach statement" context action to rewrite usages of this method into 'foreach' statement.</remarks>
        </member>
        <member name="T:JetBrains.Util.Collections.CollectionUtilSafeOfTypeEnumerable`1">
            <summary>
            Implementation detail for <see cref="M:JetBrains.Util.CollectionUtil.SafeOfType``1(System.Collections.IEnumerable)"/>.
            Originally were known as a separate <c>SafeEnumerable</c> class, but then was turned into a LINQ-style method.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.Comparer">
            <summary>
            Factory for anonymous <see cref="T:System.Collections.Generic.IComparer`1" /> implementations based on delegates provided.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.Comparer.Create``1(System.Comparison{``0})">
            <summary>
            Returns comparer implementation from comparison delegate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Collections.Comparer.Create``2(System.Func{``0,``1},System.Collections.Generic.IComparer{``1})">
            <summary>
            Returns comparer implementation projecting values to some keys using the delegate rule provided
            and comparing those keys with custom or default relation comparer for key type.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.EnumeratorEnumerable">
            <summary>
            If we can only get an enumerator, wraps it with an enumerable to allow for using LINQ and so on.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.HashMap`2">
            <summary>
            Reimplementation of Dictionary.
            </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:JetBrains.Util.Collections.HashMap`2.Entry.PrevEntryIndex">
            <summary>
            Index of previous entry in the chain of keys with the same hashcodes (modulo size), -1 means first
            </summary>
        </member>
        <member name="T:JetBrains.Util.Collections.IFreezable">
            <summary>
            Freezable pattern: allows to use serializers which require writable members (e.g. XAML) and then still have a readonly object.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyList`1">
            <summary>
            Reuses the single instance of an empty list (one per type). This instance is read-only and reuses singleton enumerator.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptySet`1">
            <summary>
            Reuses the single instance of an empty set (one per type). This instance is read-only and reuses singleton enumerator.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FrugalLocalHashSet`1">
            <summary>
            <para>A frugal version of a generic hash set.</para>
            <para>Properties:</para>
            <para> Is a value type (non-POD though), thus merges into the memory of the owning type.</para>
            <para> Stores first item within own memory.</para>
            <para> Stores the remaining items, if any, in a hash set. If there aren't any more items, the hash set is not created.</para>
            <typeparam name="T"></typeparam>
            </summary>
        </member>
        <member name="T:JetBrains.Util.LocalHashSet`1">
            <summary>
            Lazily instantiates the hash set.
            Just FrugalLocalLazy{JetHashSet}.
            Use FrugalLocalHashSet for better GC optimization.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.LocalList`1">
            <summary>
            Represents collection of items that doesn't create heap objects unless items are added
            List is presented as array with capacity increasing as fibonacci numbers.
            To obtain <c>IList</c> invoke <c>ResultingList()</c>
            </summary>
        </member>
        <member name="P:JetBrains.Util.LocalList`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:JetBrains.Util.LocalList`1"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Locator`1">
            <summary>
            A delegate for a <see cref="M:System.Collections.Generic.IComparer`1.Compare(`0,`0)"/>-like method, but with the right side of the comparison assumed to be already known by the method. The item you get is the left side of the comparison.
            </summary>
        </member>
        <member name="P:JetBrains.Util.OneToSetMap`2.Values">
            <summary>
            Gets the collection of values contained in all of the keys. Duplicates are preserved.
            All the operations are slow on this collection, especially including the <see cref="P:JetBrains.Util.OneToSetMap`2.ValuesCollection.Count"/> property.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OneToSetMap`2.GetReadonlyValue(`0)">
            <summary>
            Use this method to avoid additional boxing and memory allocations in calling code
            </summary>
        </member>
        <member name="T:JetBrains.Util.OneToSetMap`2.ValuesCollection">
            <summary>
            Exposes all of the values as a single collection.
            If some value is held by more than one key, it's returned twice.
            </summary>
        </member>
        <member name="T:JetBrains.Util.JetWeakReference`1">
            <summary>
            Represents a typed weak reference which can be compared by target
            </summary>
        </member>
        <member name="T:JetBrains.Util.WeakHolder`1">
            <summary>
            Represents a typed weak reference which can be compared by target
            </summary>
        </member>
        <member name="T:JetBrains.Util.IUserDataHolder">
            <summary>
            Represents the "user data holder" aka "property bag" pattern.
            Mutable collection of the values, associated with keys of type <see cref="T:JetBrains.Util.Key`1"/>.
            All operations are guaranteed to be thread-safe.
            </summary>
            <example> Example of usage:
            <code>
              private const Key{MyDataType} KEY = new Key{MyDataType}("descriptor");
              ...
              {
                MyDataType dataToStore = ...;
                holder.PutData(KEY, dataToStore);
                ...
                MyDataType restoredData = holder.GetData(KEY);
              }
            </code></example>
            <seealso cref="T:JetBrains.Util.Key`1"/>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.GetData``1(JetBrains.Util.Key{``0})">
            <summary>
            Retrieves the value associated with given <paramref name="key"/>.
            Returns <c>null</c> when no value is associated.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.PutData``1(JetBrains.Util.Key{``0},``0)">
            <summary>
            Stores the given <paramref name="value"/> by specified <paramref name="key"/>.
            Use <code>PutData(key, null)</code> to remove the association.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.GetOrCreateDataUnderLock``1(JetBrains.Util.Key{``0},System.Func{``0})">
            <summary>
            Tries to retrieve the value associated with given key, invoking <paramref name="factory"/> delegate
            in the case of no value associated, storing and returning the resulted value.
            Guarantees that the <paramref name="factory"/> will only be invoked once for the given key
            Most implementations simply take lock per whole <see cref="T:JetBrains.Util.IUserDataHolder"/> instance,
            so avoid doing much work in <paramref name="factory"/>.
            WARNING: If associated value is absent and the factory is executed by some thread, other threads
            are only guaranteed to lock until factory is completed when using <see cref="T:JetBrains.Util.IUserDataHolder"/>
            instance through 'GetOrCreateDataUnderLock' family of methods. In other words, consistency is not
            guaranteed between 'GetData'/'PutData' methods and 'GetOrCreateDataUnderLock' overloads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IUserDataHolder.GetOrCreateDataUnderLock``2(JetBrains.Util.Key{``0},``1,System.Func{``1,``0})">
            <summary>
            Tries to retrieve the value associated with given key, invoking <paramref name="factory"/> delegate
            in the case of no value associated, storing and returning the resulted value.
            Guarantees that the <paramref name="factory"/> will only be invoked once for the given key
            Most implementations simply take lock per whole <see cref="T:JetBrains.Util.IUserDataHolder"/> instance,
            so avoid doing much work in <paramref name="factory"/>.
            WARNING: If associated value is absent and the factory is executed by some thread, other threads
            are only guaranteed to lock until factory is completed when using <see cref="T:JetBrains.Util.IUserDataHolder"/>
            instance through 'GetOrCreateDataUnderLock' family of methods. In other words, consistency is not
            guaranteed between 'GetData'/'PutData' methods and 'GetOrCreateDataUnderLock' overloads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.UserDataHolderExtensions.PutKey(JetBrains.Util.IUserDataHolder,JetBrains.Util.Key{System.Object})">
            <summary>
            Stores the given <paramref name="key"/> in specified <see cref="T:JetBrains.Util.IUserDataHolder"/> using itself as an associated value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.UserDataHolderExtensions.HasKey``1(JetBrains.Util.IUserDataHolder,JetBrains.Util.Key{``0})">
            <summary>
            Checks for associations with given <paramref name="key"/> in specified <see cref="T:JetBrains.Util.IUserDataHolder"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.UserDataHolderExtensions.RemoveKey``1(JetBrains.Util.IUserDataHolder,JetBrains.Util.Key{``0})">
            <summary>
            Removes the association with given <paramref name="key"/> in specified <see cref="T:JetBrains.Util.IUserDataHolder"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.UserDataHolderExtensions.GetOrCreateDataNoLock``2(JetBrains.Util.IUserDataHolder,JetBrains.Util.Key{``0},``1,System.Func{``1,``0})">
            <summary>
            Lambda-lifted overload: use a cached delegate instead of creating a new closure object on each call.
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc.True">
            <summary>
            Function that always returns True
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc.False">
            <summary>
            Function that always returns False
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.True">
            <summary>
            Function that always returns True
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.False">
            <summary>
            Function that always returns False
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.Identity">
            <summary>
            Identity function that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFunc`1.IdentityConverter">
            <summary>
            Identity converter that always returns the same value that was used as its argument.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Key">
            <summary>
            Class to be used for keys in <see cref="T:JetBrains.Util.IUserDataHolder"/>. May also be used in other places
            where unique keys are needed. Instances of this class are constructed with String parameter
            but use it only to return in <see cref="!:Key.ToString()"/> method.
            This class does not override <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>
            and therefore all instances of this class are considered to be different.
            <seealso cref="T:JetBrains.Util.IUserDataHolder"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Key`1">
            <summary>
            Strongly types key. <see cref="T:JetBrains.Util.Key"/>
            This class does not override <see cref="M:System.Object.Equals(System.Object)"/> and <see cref="M:System.Object.GetHashCode"/>
            and therefore all instances of this class are considered to be different.
            <seealso cref="T:JetBrains.Util.IUserDataHolder"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Lazy">
            <summary>
            Set of factories for creation <see cref="T:System.Lazy`1"/> instances.
            </summary>
            <remarks>
            *** PLEASE, DO NOT USE LAZY{T} IN INTERRUPTIBLE ACTIVITIES!! ***
            BCL's implementation of Lazy{T} type stores the exception thrown by value factory,
            even the <see cref="T:System.OperationCanceledException"/> used to stop interruptible activities.
            As a result, you may experience infinite cyclic restarts of activities like R#'s daemon.
            Use the <see cref="T:JetBrains.Util.Concurrency.InterruptibleLazy`1"/> type in such cases.
            </remarks>
        </member>
        <member name="T:JetBrains.Util.SafeDisposable">
            <summary>
            By extending this class you ensures that object will be disposed by finalizer. If one forget to invoke <see cref="M:JetBrains.Util.SafeDisposable.Dispose"/>,
            resources will be released by finalizer but <see cref="M:JetBrains.Util.Logging.Logger.LogError(System.String)"/> is called in this case. If one invoked dispose second time error would be logger too
            (this behavior could be suppressed by overriding <see cref="P:JetBrains.Util.SafeDisposable.WarnOnSecondDispose"/> in inheritors). The finalizer works only in Development mode (JET_MODE_ASSERT). In
            Production mode this class is much like <see cref="T:System.IDisposable"/> with checks for second dispose.
            </summary>
        </member>
        <member name="M:JetBrains.Util.SafeDisposable.DisposeIfNecessary(System.Object)">
            <summary>
            Dispose object only if its class implements <see cref="T:System.IDisposable"/>
            </summary>
            <param name="o">object to dispose</param>
        </member>
        <member name="P:JetBrains.Util.StringSlice.Length">
            <summary>
            String length
            </summary>
        </member>
        <member name="P:JetBrains.Util.StringSlice.Item(System.Int32)">
            <summary>
            Char in result string
            </summary>
            <param name="i"> index in result string</param>
            <returns>Char at pos <see cref="!:i"/> in result string</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char)">
            <summary>
            Reports the index of the first occurrence of the specified UTF-16LE character in result string.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified UTF-16LE character in result string. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or specifies a position beyond the end of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified character in this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> + <paramref name="startIndex"/> specifies a position beyond the end of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> specifies a position not within this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence of the specified <see cref="T:System.String"/> in this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> plus <paramref name="startIndex"/> specify a position not within this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. A parameter specifies the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The zero-based index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative, or specifies a position that is not within this instance. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the first occurrence of the specified string in the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The zero-based index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param><param name="startIndex">The search starting position. </param><param name="count">The number of character positions to examine. </param><param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param><exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> plus <paramref name="startIndex"/> specify a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[])">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[],System.Int32)">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters. The search starts at a specified character position.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> is greater than the number of characters in this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.IndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reports the index of the first occurrence in this instance of any character in a specified array of UTF-16LE characters. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The zero-based index position of the first occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="count"/> + <paramref name="startIndex"/> is greater than the number of characters in this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.Char,System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of the specified UTF-16LE character in a substring within this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <param name="count">The number of character positions to examine. </param><exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero, or greater than or equal to the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> is less than zero.</exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance.
            </summary>
            
            <returns>
            The zero-based index position of <paramref name="value"/> if that character is found, or -1 if it is not.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param><exception cref="T:System.ArgumentNullException">
            <paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of a specified UTF-16LE character within this instance. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence of the specified UTF-16LE character in a substring within this instance. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of <paramref name="value"/> if that character is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="value">A UTF-16LE character to seek. </param>
            <param name="startIndex">The starting position of a substring within this instance. </param><param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero, or greater than or equal to the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> is less than zero.</exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the index of the last occurrence of a specified string within the current <see cref="T:System.String"/> object. A parameter specifies the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is the last index position in this instance.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.StringComparison)">
            <summary>
            Reports the index of the last occurrence of a specified string within the current <see cref="T:System.String"/> object. Parameters specify the starting search position in the current string, and type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> is less than zero or specifies a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOf(System.String,System.Int32,System.Int32,System.StringComparison)">
            <summary>
            Reports the index position of the last occurrence of a specified <see cref="T:System.String"/> object within this instance. Parameters specify the starting search position in the current string, the number of characters in the current string to search, and the type of search to use for the specified string.
            </summary>
            
            <returns>
            The index position of the <paramref name="value"/> parameter if that string is found, or -1 if it is not found or if the current instance equals <see cref="F:System.String.Empty"/>. If <paramref name="value"/> is <see cref="F:System.String.Empty"/>, the return value is <paramref name="startIndex"/>.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <param name="comparisonType">One of the <see cref="T:System.StringComparison"/> values. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- <paramref name="startIndex"/> is greater than the length of this instance.-or-<paramref name="startIndex"/> + 1 - <paramref name="count"/> specifies a position that is not within this instance. </exception><exception cref="T:System.ArgumentException"><paramref name="comparisonType"/> is not a valid <see cref="T:System.StringComparison"/> value.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[])">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[],System.Int32)">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array. The search starts at a specified character position.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; otherwise, -1 if no character in <paramref name="anyOf"/> was found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> specifies a position not within this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LastIndexOfAny(System.Char[],System.Int32,System.Int32)">
            <summary>
            Reports the index position of the last occurrence in this instance of one or more characters specified in a UTF-16LE array. The search starts at a specified character position and examines a specified number of character positions.
            </summary>
            
            <returns>
            The index position of the last occurrence in this instance where any character in <paramref name="anyOf"/> was found; -1 if no character in <paramref name="anyOf"/> was found or if the current instance equals <see cref="F:System.String.Empty"/>.
            </returns>
            <param name="anyOf">A UTF-16LE character array containing one or more characters to seek. </param>
            <param name="startIndex">The search starting position. </param>
            <param name="count">The number of character positions to examine. </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="anyOf"/> is null. </exception><exception cref="T:System.ArgumentOutOfRangeException">The current instance does not equal <see cref="F:System.String.Empty"/>, and <paramref name="count"/> or <paramref name="startIndex"/> is negative.-or- The current instance does not equal <see cref="F:System.String.Empty"/> and <paramref name="startIndex"/> minus <paramref name="count"/> specifies a position that is not within this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Substring(System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position.
            </summary>
            
            <returns>
            A <see cref="T:JetBrains.Util.StringSlice"/> object equivalent to the substring that begins at <paramref name="startIndex"/> in this instance, or <see cref="F:System.String.Empty"/> if <paramref name="startIndex"/> is equal to the length of this instance.
            </returns>
            <param name="startIndex">The zero-based starting character position of a substring in this instance. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> is less than zero or greater than the length of this instance. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Substring(System.Int32,System.Int32)">
            <summary>
            Retrieves a substring from this instance. The substring starts at a specified character position and has a specified length.
            </summary>
            
            <returns>
            A <see cref="T:JetBrains.Util.StringSlice"/> equivalent to the substring of length <paramref name="length"/> that begins at <paramref name="startIndex"/> in this instance, or <see cref="F:System.String.Empty"/> if <paramref name="startIndex"/> is equal to the length of this instance and <paramref name="length"/> is zero.
            </returns>
            <param name="startIndex">The zero-based starting character position of a substring in this instance. </param>
            <param name="length">The number of characters in the substring. </param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="startIndex"/> plus <paramref name="length"/> indicates a position not within this instance.-or- <paramref name="startIndex"/> or <paramref name="length"/> is less than zero. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Contains(System.String)">
            <summary>
            Returns a value indicating whether the specified <see cref="T:System.String"/> object occurs within this string.
            </summary>
            
            <returns>
            true if the <paramref name="value"/> parameter occurs within this string, or if <paramref name="value"/> is the empty string (""); otherwise, false.
            </returns>
            <param name="value">The <see cref="T:System.String"/> object to seek. </param><exception cref="T:System.ArgumentNullException"><paramref name="value"/> is null. </exception>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Contains(System.Char)">
            <summary>
            Returns a value indicating whether the specified <see cref="T:System.Char"/> value occurs within this string.
            </summary>
            
            <returns>
            true if the <paramref name="value"/> parameter occurs within this string; otherwise, false.
            </returns>
            <param name="value">The <see cref="T:System.Char"/> value to seek. </param>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Util.StringSlice.StartsWith(System.String,System.StringComparison)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlice.StartsWith(JetBrains.Util.StringSlice,System.StringComparison)">
            <summary>
            Determines whether the beginning of this string instance matches the specified string when compared using the specified comparison option.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlice.EndsWith(System.String,System.StringComparison)">
            <summary>
            Determines whether the end of this string instance matches the specified string when compared using the specified comparison option.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split(System.Char[])">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array. 
            </summary>
            
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator"/>.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split2(System.Char[])">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split(System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array. 
            Parameter specify whether to return empty array elements.
            </summary>
            
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator"/>.
            </returns>
            <param name="separator">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries"/> to omit empty array elements from the array returned, 
            or <see cref="F:System.StringSplitOptions.None"/> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Split2(System.Char[],System.StringSplitOptions)">
            <summary>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by elements of a specified UTF-16LE character array.
            Parameter specify whether to return empty array elements.
            </summary>
            <returns>
            Returns an enumerable of sting slices that contains the substrings in this string that are delimited by one or more characters in <paramref name="separator" />.
            </returns>
            <param name="separator">An array of UTF-16LE characters that delimit the substrings in this string, an empty array that contains no delimiters, or null.</param>
            <param name="options"><see cref="F:System.StringSplitOptions.RemoveEmptyEntries" /> to omit empty array elements from the array returned,
            or <see cref="F:System.StringSplitOptions.None" /> to include empty array elements in the array returned. </param>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Equals(System.String)">
            <summary>
            Indicates whether the current substing is equal to another string.
            </summary>
            <param name="otherString">A string to compare with this substring.</param>
            <returns>
            true if the current string is equal to the <paramref name="otherString"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Equals(System.String,System.StringComparison)">
            <summary>
            Indicates whether the current substing is equal to another string.
            </summary>
            <param name="otherString">A string to compare with this substring.</param>
            <param name="comparisonRule">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            true if the current string is equal to the <paramref name="otherString"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.Equals(JetBrains.Util.StringSlice,System.StringComparison)">
            <summary>
            Indicates whether the current substing is equal to another substring.
            </summary>
            <param name="otherStringSlice">A string slice to compare with this substring.</param>
            <param name="comparisonRule">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            true if the current string is equal to the <paramref name="otherStringSlice"/> parameter; otherwise, false.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.CompareTo(System.String)">
            <summary>
            Compares the current substing with string.
            </summary>
            <param name="otherString">An other string to compare with this substring.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            - Value Meaning Less than zero This object is less than the <paramref name="otherString"/> parameter;
            - Zero This object is equal to <paramref name="otherString"/>;
            - Greater than zero This object is greater than <paramref name="otherString"/>. 
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.CompareTo(System.String,System.StringComparison)">
            <summary>
            Compares the current substing with string.
            </summary>
            <param name="otherString">An other string to compare with this substring.</param>
            <param name="comparisonRule">One of the enumeration values that specifies the rules for the comparison.</param>
            <returns>
            A value that indicates the relative order of the objects being compared.
            The return value has the following meanings:
            - Value Meaning Less than zero This object is less than the <paramref name="otherString"/> parameter;
            - Zero This object is equal to <paramref name="otherString"/>;
            - Greater than zero This object is greater than <paramref name="otherString"/>. 
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlice.ProcessString``2(``0,JetBrains.Util.StringSlice.ProcessStringDelegate{``0,``1})">
            <summary>
            Processes a string as a fixed pointer to the char array.
            This char array is NOT zero-terminated!! It MUST NOT be modified. It's a subrange of some other runtime string object.
            </summary>
            <typeparam name="TContext">A user-defined context which allows to use non-closure lambdas.</typeparam>
            <typeparam name="TResult">Processing result.</typeparam>
            <param name="context">A user-defined context which allows to use non-closure lambdas.</param>
            <param name=""></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.StringSlice.StringSliceEqualityComparer">
            <summary>
            This equality comparer primary goal is to avoid boxing the string slice when casting to <see cref="T:System.IEquatable`1" /> when passing to datastructs.
            </summary>
        </member>
        <member name="T:JetBrains.Util.StringSlice.LowLevelAccess">
            <summary>
            Optimization methods without which you can semantically do, but which can speed up hot tracks in the code.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlice.LowLevelAccess.IsWholeString(JetBrains.Util.StringSlice)">
            <summary>
            Gets whether this slice covers the whole underlying managed string object, so calling <see cref="M:JetBrains.Util.StringSlice.ToString" /> won't make an allocation.
            </summary>
            <param name="stringSlice"></param>
        </member>
        <member name="T:JetBrains.Util.StringSlicesEnumerable">
            <summary>
            Enumerates substrings of the <see cref="T:System.String"/> value using one or many delimiters.
            Does not produce any new <see cref="T:System.String"/> or other reference type object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringSlicesEnumerable.mySource">
            <summary>
            The source string to be delimited with <see cref="F:JetBrains.Util.StringSlicesEnumerable.mySeparator"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringSlicesEnumerable.mySeparator">
            <summary>
            The unicode character that delimit the substrings of <see cref="F:JetBrains.Util.StringSlicesEnumerable.mySource"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separator"/>.</param>
            <param name="separator">A unicode character that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.#ctor(System.String,System.Char[],System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separators"/>.</param>
            <param name="separators">A unicode characters that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.IndexOf(System.String,System.StringComparison)">
            <summary>
            Reports the zero-based index of the first occurrence of the specified substring in source string.
            </summary>
            <param name="substringToSeek">The substring to seek.</param>
            <param name="comparison">One of the enumeration values that specifies the rules for the search.</param>
            <returns>The zero-based index number of <paramref name="substringToSeek"/> if that substring is found, or -1 if it is not. 
            If value is <see cref="F:System.String.Empty"/>, the return value is 0.
            </returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Single">
            <summary>
            Returns the only element of a sequence, and throws an exception if more than one such element exists.
            </summary>
            <returns>The single element of the input sequence.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Single(System.String,System.String)">
            <summary>
            Returns the only element of a sequence, and throws an exception if more than one such element exists.
            </summary>
            <param name="sExceptionMessageEmpty">The message for an exception to be thrown if the sequence is empty.</param>
            <param name="sExceptionMessageAmbiguous">The message for an exception to be thrown if the sequence contains more than one element.</param>
            <returns>The single element of the input sequence.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.IsSingle">
            <summary>
            Gets if the sequence has exactly one item.
            </summary>
        </member>
        <member name="P:JetBrains.Util.StringSlicesEnumerable.FirstOrEmpty">
            <summary>
            Gets the first item of the sequence, or empty value in case of no items.
            </summary>
        </member>
        <member name="P:JetBrains.Util.StringSlicesEnumerable.LastOrEmpty">
            <summary>
            Gets the last item of the sequence, or empty value in case of no items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.ToStringEnumerable">
            <summary>
            Returns allocated strings from sequence.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.ToStringArray">
            <summary>
            Returns array of allocated strings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.AsEnumerable">
            <summary>
            Returns the yield-based implementation of <see cref="T:System.Collections.Generic.IEnumerable`1" /> to use with LINQ methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.ToList">
            <summary>
            Creates a new <see cref="T:System.Collections.Generic.IList`1" /> with the items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.ToArray">
            <summary>
            Creates a new <see cref="T:System.Array" /> with the items.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Count">
            <summary>
            Returns count of items in the sequence 
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Select``1(System.Func{JetBrains.Util.StringSlice,``0})">
            <summary>Projects each element of a sequence into a new form.</summary>
            <param name="selector">A transform function to apply to each element.</param>
            <typeparam name="TResult">The type of the value returned by <paramref name="selector" />.</typeparam>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> whose elements are the result of invoking the transform function on each element of sequence.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Any(System.Func{JetBrains.Util.StringSlice,System.Boolean})">
            <summary>Determines whether any element of a sequence satisfies a condition.</summary>
            <param name="predicate">A function to test each element for a condition.</param>
            <returns>
            <see langword="true" /> if any elements in the source sequence pass the test in the specified predicate; otherwise, <see langword="false" />.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="predicate" /> is <see langword="null" />.</exception>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Take(System.Int32)">
            <summary>Returns a specified number of contiguous elements from the start of a sequence.</summary>
            <param name="count">The number of elements to return.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the specified number of elements from the start of the input sequence.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Join(System.String)">
            <summary>
            Calls <see cref="M:JetBrains.Util.StringSlicesEnumerable.AggregateString(System.String)"/> to get a single string, which uses the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings when concatenating.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.AggregateString(System.String)">
            <summary>
            Aggregates items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings when concatenating.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.AggregateString(System.String,System.String,System.Func{System.Text.StringBuilder,JetBrains.Util.StringSlice,System.Text.StringBuilder})">
            <summary>
            Aggregates items into a single string, using the <see cref="T:System.Text.StringBuilder"/> to avoid creating excessive strings when concatenating.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Contains(System.String,System.StringComparison)">
            <summary>Determines whether a sequence contains a specified element.</summary>
            <param name="value">The value to locate in the sequence.</param>
            <param name="comparison">One of the enumeration values that specifies the rules for the search.</param>
            <returns>
            <see langword="true" /> if the source sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.Contains(JetBrains.Util.StringSlice,System.StringComparison)">
            <summary>Determines whether a sequence contains a specified element.</summary>
            <param name="value">The value to locate in the sequence.</param>
            <param name="comparison">One of the enumeration values that specifies the rules for the search.</param>
            <returns>
            <see langword="true" /> if the source sequence contains an element that has the specified value; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the substring of source string.
            </summary>
            <returns>
            A <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> that can be used to iterate through the substrings of source string.
            </returns>
        </member>
        <member name="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator">
            <summary>
            Iterates through the substing of the source string delimited by specified character.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separator"/>.</param>
            <param name="separator">A unicode character that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="M:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator.#ctor(System.String,System.Char[],System.Boolean)">
            <summary>
            Creates a new instance of hte <see cref="T:JetBrains.Util.StringSlicesEnumerable.StringSlicesEnumerator"/> structure with source string to "split" and separator.
            </summary>
            <param name="source">A source string to be delimited with <paramref name="separators"/>.</param>
            <param name="separators">A unicode characters that delimit the substrings of <paramref name="source"/> <see cref="T:System.String"/>.</param>
            <param name="skipEmptyEntries">A <see cref="T:System.Boolean"/> value indicating whether to skip empty substrings.</param>
        </member>
        <member name="T:JetBrains.Util.TypeOf">
            <summary>
            Caches <see cref="F:JetBrains.Util.TypeOf.Type"/> instances for popular types.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AssertionModeInitializer.Init">
            <summary>
            This constant propagates to the JetBrains/Rd dependency (Lifetimes/RdFramework), which compiled without conditional compilation symbols.
            </summary>
        </member>
        <member name="T:JetBrains.Util.CannotDeleteTempEntityException">
            <summary>
            Used to wrap a real exception thrown by temporary file system object deletion, so that it can be processed as an error or a warning depending on the context.
            </summary>
        </member>
        <member name="T:JetBrains.Util.DirectoryEntryData">
            <summary>
            Data object for the advanced <c>GetChild*</c> methods family on a file system path.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DirectoryEntryData.BaseDir">
            <summary>
            The base dir for <see cref="P:JetBrains.Util.DirectoryEntryData.RelativePath" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.DirectoryEntryData.RelativePath">
            <summary>
            Path of this item, relative to <see cref="P:JetBrains.Util.DirectoryEntryData.BaseDir" />. Will only have more than one component if recursive.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileModificationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileCreationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.FileAccessTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.Attributes">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.DirectoryEntryData.Length">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DirectoryEntryData.GetAbsolutePath">
            <summary>
            Concats into the abs path.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.DirectoryEntryData.Existence">
            <summary>
            Tells files from dirs, if you're enumerating for both.
            </summary>
        </member>
        <member name="M:JetBrains.Util.DirectoryEntryData.WithBaseDir(JetBrains.Util.FileSystemPath)">
            <summary>
            Rebases onto another base dir and updates the relative path.
            Does not allow the relative path to go upwards (have two-dot components).
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemDefinition.PathDelimiterChar">
            <summary>
              Symbol to delimit PATH environment variable
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemDefinition.PathDelimiterString">
            <summary>
              String to delimit PATH environment variable
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemDefinition.EnvironmentVariableNameForNoCleanup">
            <summary>
            Name of the environment variable which suppresses various cleanup of temporary entities so that to leave them behind for investigation.
            Should parse as a boolean value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemDefinition.myIsEnvironmentVariableForNoCleanup">
            <summary>0 lazy delayed, 1 yes, -1 no</summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.GetTempPath">
            <summary>
            Returns the path of the current system's temporary folder. 
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemDefinition.IsEnvironmentVariableForNoCleanup">
            <summary>
            If <see cref="F:JetBrains.Util.FileSystemDefinition.EnvironmentVariableNameForNoCleanup"/> env var is set, cached.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.TryParse(System.String)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.Parse(System.String)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.TryParseVirtualPath(System.String,JetBrains.Util.IInteractionContext)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemDefinition.ParseVirtualPath(System.String,JetBrains.Util.IInteractionContext)">
            <summary>
            Parses a relative or absolute path.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEvent.OldName">
            <summary>
            Old path for rename event, relative to watched directory
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEvent.ErrorMessage">
            <summary>
            Error message if Type is WatcherError
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatcherError">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatcherEventsBufferOverflow">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatchedDirectoryDeleted">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemEventType.WatchedDirectoryAborted">
            <summary>
            JetFileSystemWatcher is automatically disposed right after delivering this event
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemInteraction.DeleteDirectoryNonRecursive(JetBrains.Util.FileSystemPath,System.Int32,System.Exception@)">
            <summary>
            Attempts to delete the directory object without recursing inside.
            Might return an exception in <paramref name="ex" /> instead of throwing out, so that in cases where we expect regular failures (like with deleting recursive folders) it were not causing too many exceptions.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPath">
            <summary>
            This class represents a path in the file system. It provides necessary methods for
            dealing with paths, and is more convenient for clients than raw strings, since it handles
            different separator characters, case etc
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.GetShortPath">
            <summary>
            Shrinks name components to their short form in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.CreateByCanonicalPath(System.String,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.TryParse(System.String,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Creates <see cref="T:JetBrains.Util.FileSystemPath"/> from string or <see cref="F:JetBrains.Util.FileSystemPath.Empty"/> if fails
            </summary>
            <param name="path">String to be converted into <see cref="T:JetBrains.Util.FileSystemPath"/></param>
            <param name="internStrategy">If the path needs to be interned</param>
            <returns>Created path or <see cref="F:JetBrains.Util.FileSystemPath.Empty"/></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.Parse(System.String,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath"/> from string. Throws exceptions if fails.
            </summary>
            <param name="path">Path string</param>
            <param name="internStrategy">If the path needs to be interned</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath"/></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path"/> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser"/> for details</exception>
        </member>
        <member name="M:JetBrains.Util.FileSystemPath.ParseRelativelyTo(System.String,JetBrains.Util.FileSystemPath)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath" /> from string. Throws exceptions if fails.
            If the string represents an absolute path, just parses it as with <see cref="M:JetBrains.Util.FileSystemPath.Parse(System.String,JetBrains.Util.FileSystemPathInternStrategy)" />.
            If the string represents a relative path, treats it as relative to <see cref="!:basePathForRelativeStrings" /> to make an absolute path.
            This is the same as calling <see cref="M:JetBrains.Util.FileSystemDefinition.Parse(System.String)" /> and then <see cref="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)" /> (you can use the same path to get an analogy for <see cref="M:JetBrains.Util.FileSystemPath.TryParse(System.String,JetBrains.Util.FileSystemPathInternStrategy)" />).
            </summary>
            <param name="path">Path string</param>
            <param name="basePathForRelativeStrings">If <paramref name="path" /> represents a relative path, it's relative to this base.</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath" /></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path" /> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser" /> for details</exception>
        </member>
        <member name="T:JetBrains.Util.FileSystemPath.Existence">
            <summary>
            Determines whether the file system entity exists as a file or as a directory
            (if it does not exist at all, we cannot tell whether it's a file or a directory).
            You can check for any existence by comparing the value to zero (missing value is <c>0</c>).
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.Missing">
            <summary>
            The file system entity represented by this <see cref="T:JetBrains.Util.FileSystemPath"/> does not exist in the file system,
            or is invalid (e.g. <see cref="!:FileSystemPath.IsEmpty"/>).
            This is the zero value of the enum.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.File">
            <summary>
            This is a file that actually exists in the file system.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPath.Existence.Directory">
            <summary>
            This is a directory that actually exists in the file system.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPathEx">
            <summary>
            Extension methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetParentDirectories``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Gets the parent directories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetThisAndParentDirectories``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Gets the current directory and its parent directories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildDirectories``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.String,JetBrains.Util.PathSearchFlags,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Gets the child directories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildren``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.String,JetBrains.Util.PathSearchFlags)">
            <summary>
            Gets the child files or directories, or recurses into subdirectories.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildFiles``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.String,JetBrains.Util.PathSearchFlags,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Gets the child files.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.GetChildFiles``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Int32,System.String,JetBrains.Util.PathSearchFlags,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Gets the child files with limited search depth 
            <param name="maxDepth">The maximum search depth</param>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded(JetBrains.Util.RelativePath)">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.QuoteIfNeeded(JetBrains.Util.BackSlashSeparatedRelativePath)">
            <summary>
            Returns the full path, quoted if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.ToAbsolutePath``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Returns an absolute path.
            If the given path is already absolute (<see cref="!:FileSystemPath.IsAbsolute"/>), leaves it as is.
            If the given path is relative, 
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.ToAbsolutePath``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Returns an absolute path.
            If the given path is already absolute (<see cref="!:FileSystemPath.IsAbsolute"/>), leaves it as is.
            If the given path is relative, 
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathEx.FromDataAnonymousAssembly">
            <summary>
            See mono_image_open_from_data_with_name from image.c
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.TryGetPath(System.Reflection.Assembly)">
            <summary>
            For a file-based assembly, returns its path.
            If the assembly is not file-based, or the path could not be retrieved, returns <see cref="F:JetBrains.Util.FileSystemPath.Empty" />.
            </summary>
            <param name="this"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.Copy``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Boolean,System.Collections.Generic.ICollection{``0})">
            <summary>
            Copies either a file or a directory to the new location.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.String,System.Text.Encoding)">
            <summary>
            If the file already has this text (any encoding, ignores insignificant difference), won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.Byte[])">
            <summary>
            If the file already has these bytes, won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.IO.Stream)">
            <summary>
            If the file already has these bytes, won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.WriteIfDirtyWithMoveAside(JetBrains.Util.FileSystemPath,System.Func{JetBrains.Lifetimes.Lifetime,System.IO.Stream})">
            <summary>
            If the file already has these bytes, won't touch it.
            Otherwise moves the file aside if it's in use, ensures the parent directory exists, and writes the new content.
            </summary>
            <param name="path">Target file path. Must be a valid disk path in the current OS. OK if it or its parents do not exist yet.</param>
            <param name="streamer">Opens the stream: once if the target file of a proper size does not exist, or twice if the file exists, has the right size but the wrong content and we need to overwrite. To support non-seekable but renewable streams, we open it for the second time instead of seeking. It is guaranteed that lifetimes are sequential.</param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.Delete``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Int32)">
            <summary>
            Deletes the item (directory or file).
            In case of directory deletes recursively
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.Delete``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Deletes the item (directory or file).
            In case of directory deletes recursively
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteChildren``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            On a folder, deletes its children.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.CleanUpChildren(JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{JetBrains.Util.FileSystemPath})">
            <summary>
            On a folder, deletes its children.
            Does not fail if some file directory or file is failed to be removed (method return 'false' in this case)
            In case of all directories/files were removed, returns 'true' 
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.CleanUpDirectory(JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{JetBrains.Util.FileSystemPath})">
            <summary>
            Recursively deletes directory. Does exactly the same as <c>CleanUpChildren</c> but also deletes itself
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.IsValidAndExistFile``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Func{JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Boolean})">
            <summary>
            Check IsEmpty, IsAbsolute, IsValidOnCurrentOs and ExistsFile
            </summary>
            <param name="path"></param>
            <param name="existFile">if existFile is null, then FileSystemPath.ExistsFile used </param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.IsValidAndExistDirectory``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Func{JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Boolean})">
            <summary>
            Check IsEmpty, IsAbsolute, IsValidOnCurrentOs and ExistsDirectory
            </summary>
            <param name="path"></param>
            <param name="existDirectory">if existDirectory is null, then FileSystemPath.ExistsDirectory used </param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteWithMoveAside(JetBrains.Util.FileSystemPath)">
            <summary>
            Deletes the file or directory.
            In case of directory deletes recursively
            Does not fail if there is no such file or directory.
            Locked files are moved aside if they cannot be deleted.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DeleteFileWithMoveAside(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Deletes the file. If the file is in use and cannot be deleted right now, moves it aside. This allows to still use the file name for writing the new file without immediately affecting the already-running process.
            </summary>
            <param name="path">The file to delete-with-move-aside.</param>
            <param name="dirMoveAsideDestination">Optionally, the folder into which the file should be moved-aside (by default, it's the file's original directory). This folder must be on the same volume for the move of a locked file to be successful.</param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathEx.DoMoveAside(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Fn which does the MoveAside if nothing else worked.
            </summary>
            <param name="path"></param>
            <param name="dirMoveAsideDestination">Optionally, the folder into which the file should be moved-aside (by default, it's the file's original directory). This folder must be on the same volume for the move of a locked file to be successful.</param>
        </member>
        <member name="M:JetBrains.Util.IFileSystemPathBaseIntern`3.TryGet(System.String)">
            <summary>
            Returns <see cref="T:JetBrains.Util.FileSystemPath"/> if it is interned, null otherwise. Used in <see cref="F:JetBrains.Util.FileSystemPathInternStrategy.TRY_GET_INTERNED_BUT_DO_NOT_INTERN"/>
            </summary>
            <param name="path">Path string to find <see cref="T:JetBrains.Util.FileSystemPath"/></param>
            <returns>Interned path or null</returns>
        </member>
        <member name="M:JetBrains.Util.IFileSystemPathBaseIntern`3.GetOrCreate(System.String,JetBrains.Util.IInteractionContext,System.Boolean,System.Func{System.String,JetBrains.Util.IInteractionContext,System.Boolean,`0})">
            <summary>
            Returns interned <see cref="T:JetBrains.Util.FileSystemPath"/> for specified <see cref="!:path"/> if it exists, creates and stores new <see cref="T:JetBrains.Util.FileSystemPath"/> otherwise. Used in <see cref="F:JetBrains.Util.FileSystemPathInternStrategy.INTERN"/>
            </summary>
            <param name="path">Path string to be interned</param>
            <param name="isPathAlreadyCanonical">If the path is already normalized</param>
            <param name="createDelegate">Func to create <see cref="T:JetBrains.Util.FileSystemPath"/></param>
            <returns>Interned path</returns>
        </member>
        <member name="M:JetBrains.Util.IFileSystemPathBaseIntern`3.Clear">
            <summary>
            Clears interned paths
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathInternByConcurrentDictionaryBase`3.PathContainer.myApproximatePathCount">
            <summary>
            We need to check the number of cached paths
            every time this strategy is accessed so that to make sure
            that it doesn't overfill.
            However, accessing <code>Count</code> property
            is too expensive, because it acquires all locks in the collection.
            That's why keep track of the collection size separately.
            Since we avoid locking here, this field might be reset a bit later than the collection itself,
            thus deviating slightly from the actual collection size,
            but after that it will keep track of its approximate size just fine.
            After all, we don't need exact values here.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathInternParameters.DEFAULT_PATH_LENGTH_LIMIT">
            <summary>
            Paths that are this long are very unlikely to be real.
            They probably only appear once from some suspicious source such as user code output,
            hence we refuse to intern them.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathInternParameters.DEFAULT_ABSOLUTE_PATH_COUNT_LIMIT">
            <summary>
            Path interning can cause troubles when there are numerous attempts
            to parse text that was not supposed to be parsed, for example, user code output.
            To protect our interned path pool from that, we limit the number of paths that can be interned.
            In our (huge) solution with 613 projects, there are about 120'000 interned paths,
            so this upper bound seems to be reasonable.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathInternParameters.DEFAULT_RELATIVE_PATH_COUNT_LIMIT">
            <summary>
            This upper bound is based on same logic as <see cref="F:JetBrains.Util.FileSystemPathInternParameters.DEFAULT_ABSOLUTE_PATH_COUNT_LIMIT"/>.
            Text that was not supposed to be parsed as path at all
            is much more likely to be parsed as relative path, hence we store it separately.
            </summary>
        </member>
        <member name="F:JetBrains.Util.FileSystemPathInternParameters.DEFAULT_INITIAL_POOL_SIZE">
            <summary>
            According to Ilya Usov, even the default 'Hello world' application
            causes creation of 10000 different paths, so it makes sense
            to initialize the intern pool with this size
            </summary>
        </member>
        <member name="T:JetBrains.Util.FileSystemPathOpenEx">
            <summary>
            FSP ext methods specifically related to opening underlying files for reading/writing/etc.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForAppend``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens the file, keeps the content, rewinds to the end, allows any concurrent operations on this same file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForAppendDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens the file, keeps the content, rewinds to the end, denies alien writes, allows alien reads.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReading``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReadingDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForReadingExclusive(JetBrains.Util.FileSystemPath)">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWriting``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens a stream on this file system path for writing, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Opens a stream on this file system path for writing, preventing all other parties from writing the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingExclusive``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from reading or writing the stream at the same time. </para>
              <para>Most often you'd like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.OpenFileForWritingDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenStreamWithWaitingOnLock(JetBrains.Util.FileSystemPath,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Nullable{System.TimeSpan})">
            <summary>
            Opens a stream on this file system path. If the file is currently opened with access which conflicts with us, awaits for the file to get released for some time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ExecuteIoOperationWithRetryAsync``1(JetBrains.Lifetimes.Lifetime,System.Nullable{System.TimeSpan},JetBrains.Application.Threading.Tasks.ITaskHost,System.Func{``0})">
            <summary>
            Retries an arbitrary IO operation if it's unavailable at the moment, based on the exception code thrown out of the try function.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.OpenStreamWithWaitingOnLockAsync(JetBrains.Util.FileSystemPath,JetBrains.Lifetimes.Lifetime,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare,System.Nullable{System.TimeSpan},JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Opens a stream on this file system path. If the file is currently opened with access which conflicts with us, awaits for the file to get released for some time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadAllText2``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Text.Encoding)">
            <summary>
            If encoding is not specified, uses the smart detection algorithm of Visual Studio which has a good sense of when to treat a non-ASCII non-BOM file as UTF-8 or ANSI.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadBinaryStream``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.BinaryReader})">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadBinaryStream``4(JetBrains.Util.FileSystemPathBase{``1,``2,``3},System.Func{System.IO.BinaryReader,``0})">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStream``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStream``4(JetBrains.Util.FileSystemPathBase{``1,``2,``3},System.Func{System.IO.Stream,``0})">
            <summary>
            Opens a stream on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadStreamExclusive``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for reading, preventing all other parties from writing to the stream at the same time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadTextStream``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.StreamReader},System.Text.Encoding)">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.ReadTextStream``4(JetBrains.Util.FileSystemPathBase{``1,``2,``3},System.Func{System.IO.StreamReader,``0},System.Text.Encoding)">
            <summary>
            Opens a stream-reader on this file system path for reading, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteBinaryStreamDenyWrite(JetBrains.Util.FileSystemPath,System.Action{System.IO.BinaryWriter})">
            <summary>
            Opens a binary-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStream``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
            Opens a stream on this file system path for writing, requesting minimum permissions and trying to be as non-blocking as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from writing the stream at the same time.</para>
              <para>Most often you would like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamExclusive``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})">
            <summary>
              <para>Opens a stream on this file system path for writing, preventing all other parties from reading or writing the stream at the same time.</para>
              <para>Most often you would like to use <see cref="M:JetBrains.Util.FileSystemPathOpenEx.WriteStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.Stream})" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteTextStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Action{System.IO.StreamWriter})">
            <summary>
            Opens a stream-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteTextStreamDenyWrite``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Text.Encoding,System.Action{System.IO.StreamWriter})">
            <summary>
            Opens a stream-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.WriteTextStreamDenyWriteAsync``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.Text.Encoding,System.Func{System.IO.StreamWriter,System.Threading.Tasks.Task})">
            <summary>
            Opens a stream-writer on this file system path for writing, erases contents, prevents alien writes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathOpenEx.EnsureFileDirectory``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Before writing a file, make sure its directory actually exists.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.Normalize(System.String,JetBrains.Util.IInteractionContext,System.Boolean)">
            <summary>
            xplat compromise/invariant:
            <ul>
            <li>path satisfying "[a-zA-Z]:" or [a-zA-Z]:\.*" are treated as absolute paths on all platforms (Unix/Windows)</li>
            <li>"[not alphabet char]:" are treated as valid relative paths on Unix</li>
            <li>".:[any char except '/', '\'].+" are treated as valid relative paths on linux. On Windows - relative to a current drive paths</li>
            </ul>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.IsPathAbsolute(System.String,JetBrains.Util.IInteractionContext,System.Boolean)">
            <summary>
            Determines that <paramref name="path"/> is absolute.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.IsPathRelativeToDriveRoot(System.String,JetBrains.Util.IInteractionContext,System.Boolean)">
            <summary>
            Determines that <paramref name="path"/> is relative to drive root path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathParser.TryConvertToRelativePath(System.String,System.String,System.Boolean,System.Char)">
            <summary>
            Note: valid arguments are relative both or absolute both or unc both. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetDirectoryNameOfFileAbove(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="sMarkerFileName">Name of the file to look for.</param>
            <returns>The folder which has the file. Throws an exception if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.TryGetDirectoryNameOfFileAbove``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},System.String)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="sMarkerFileName">Name of the file to look for.</param>
            <returns>The folder which has the file. <c>Null</c> if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetDirectoryNameOfItemAbove``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.RelativePath)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given file in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="markerPath">Name of the item to look for  (may be file or folder).</param>
            <returns>The folder which has the file. Throws an exception if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.TryGetDirectoryNameOfItemAbove``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2},JetBrains.Util.RelativePath)">
            <summary>
              <para>
                Mimics the MSBuild's <c>GetDirectoryNameOfFileAbove</c> property function.
              </para>
              <para>Looks for the given item in the containing folders, starting with the current one.</para>
              <para>Possible use is to locate the product home directory starting with any unspecified point within its directory structure.</para>
            </summary>
            <param name="pathStartingPoint">The folder or file to start looking from (moving up).</param>
            <param name="markerPath">Name of the item to look for (may be file or folder).</param>
            <returns>The folder which has the item. <c>Null</c> if not found.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemUtil.GetPathOnDiskWithCorrectCase``3(JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
              Looks for the path on disk regardless of given case, works on all platforms.
              Unc paths are not supported. Throws <see cref="T:System.ArgumentException"/> if several entries
              match given path.
            </summary>
            <param name="path">The path to look for, should be absolute</param>
            <returns>The path on disk if it exists. <c>Null</c> if not found.</returns>[CanBeNull]
        </member>
        <member name="T:JetBrains.Util.JetFileSystemWatcher">
            <summary>
            Better managed API for watching file system changes
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFileSystemWatcher.DefaultEventsBufferSize32">
            <summary>
            Default size of the events buffer 
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFileSystemWatcher.DefaultEventsBufferSize64">
            <summary>
            Default size of the events buffer 
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFileSystemWatcher.MaxEventsBufferSize">
            <summary>
            Maximum size of the events buffer
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFileSystemWatcher.TotalBuffers">
            <summary>
            Total number of buffers allocated
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetFileSystemWatcher.TotalAllocatedSize">
            <summary>
            Total size of alive buffers
            </summary>
        </member>
        <member name="P:JetBrains.Util.JetFileSystemWatcher.BufferSize">
            <summary>
            Size of the events buffer if applicable
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.GetCanonicalPath(System.String,JetBrains.Util.IInteractionContext)">
            <summary>
            Gets the canonical path, returns <c>""</c> in case of a failure.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.ExtensionNoDot">
            <summary>
            Gets the file extension, without the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>bat</c></example>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.ExtensionWithDot">
            <summary>
            Gets the file extension, including the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>.bat</c></example>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.Name">
            <summary>
            Gets the local name of the file/directory (the component after the last separator).
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.ToDirectoryUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.ToUri">
            <summary>
            Creates a system <see cref="T:System.Uri"/> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="T:System.Empty"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.Parent">
            <summary>
            Gets the parent directory of the current file or directory using <see cref="F:JetBrains.Util.FileSystemPathInternStrategy.INTERN"/>
            In case when different intern strategy is needed use <see cref="M:JetBrains.Util.FileSystemPathBase`3.GetParent(JetBrains.Util.FileSystemPathInternStrategy)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.GetParent(JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Gets the parent directory of the current file or directory using specified intern strategy
            </summary>
            <param name="internStrategy">Intern strategy to use</param>
            <returns>Path to parent folder.</returns>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.Combine(System.String,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.GetDriveName">
            <summary>
            Gets the drive letter, if the path is rooted under a Windows drive.
            For convenience, the letter will be returned in uppercase.
            If the path has no drive char, a zero value will be returned.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.GetRootDir">
            <summary>
            Takes the first <see cref="P:JetBrains.Util.FileSystemPathBase`3.Components">path components</see>, as many as needed for a meaningful root dir. Would be <c>\\Server\Share\</c> for UNC, <c>/usr/</c> for Unix, and so on.
            The returned string has the trailing path separator.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.Directory">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.Exists">
            <summary>
            Gets whether this path exists in the file system, and whether it is a directory or a file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.Info">
            <summary>
            Gets various information about file or directory in one system call. Throws on I/O errors.
            </summary>
            <returns>File/directory information if entity exists, null if not</returns>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.ExistsDirectory">
            <summary>
            Gets whether this instance points to a directory, and that directory exists on disk.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.ExistsFile">
            <summary>
            Gets whether this instance points to a file, and that file exists on disk.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.FileModificationTimeUtc">
            <summary>
            Gets the last write time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.FileCreationTimeUtc">
            <summary>
            Gets the creation time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.FileLastAccessedTimeUtc">
            <summary>
            Gets the last accessed time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.FileAccessPath">
            <summary>
            Special path for passing to functions working with GetInteraction()
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.IsHidden">
            <summary>
            Gets whether this file system path is a hidden file or folder.
            Returns <c>False</c> for nonexistent paths.
            </summary>
        </member>
        <member name="P:JetBrains.Util.FileSystemPathBase`3.IsSystem">
            <summary>
            Gets whether this file system path is a system file or folder.
            Returns <c>False</c> for nonexistent paths.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.DeleteFile">
            <summary>
            Does not fail if there is no such file. Throws exception for directory
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.DeleteFile(System.Boolean@,System.Int32)">
            <summary>
            Does not fail if there is no such file.
            </summary>
            <param name="isDirectory">return true if it is a directory</param>
            <param name="nAttempts"></param>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.DeleteDirectoryNonRecursive(System.Int32)">
            <summary>
            Deletes just an empty directory.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FileSystemPathBase`3.GetLongPath">
            <summary>
            Expands short name components in existing path
            </summary>
        </member>
        <member name="P:JetBrains.Util.IDirectoryEntryData`1.BaseDir">
            <summary>
            The base dir for <see cref="P:JetBrains.Util.IDirectoryEntryData`1.RelativePath" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.IDirectoryEntryData`1.RelativePath">
            <summary>
            Path of this item, relative to <see cref="P:JetBrains.Util.IDirectoryEntryData`1.BaseDir" />. Will only have more than one component if recursive.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IDirectoryEntryData`1.GetAbsolutePath">
            <summary>
            Concats into the abs path.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.PathSearchFlags">
            <summary>
            Controls how <see cref="T:JetBrains.Util.FileSystemPath"/> looks for its sub-paths.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.RecurseIntoSubdirectories">
            <summary>
            If set, includes items in subfolders with the search. Otherwise looks among immediate children only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeHidden">
            <summary>
            Excludes items that have <see cref="F:System.IO.FileAttributes.Hidden"/> attribute set.
            In recursive mode will not exclude files in hidden directories.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeFiles">
            <summary>
            Does not return paths that point to files.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PathSearchFlags.ExcludeDirectories">
            <summary>
            Does not return paths that point to directories.
            </summary>
        </member>
        <member name="T:JetBrains.Util.BackSlashSeparatedRelativePath">
            <summary>
            It represents registry-like paths or any relative path with back-slash as separator.
            Notes: Allows any printable characters as pathname except back-slash.
            Don't allow conversion from/to URI.
            You're not able to combine it with absolute path.
            </summary>
        </member>
        <member name="P:JetBrains.Util.BackSlashSeparatedRelativePath.Parent">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.CreateByCanonicalPath(System.String)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.Combine(System.String)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.BackSlashSeparatedRelativePath.JetBrains#Util#IPath#TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.BackSlashSeparatedRelativePath.Empty" />.
            </summary>
        </member>
        <member name="T:JetBrains.Util.FilesInUse">
            <summary>
            Helps getting info on who's locking the files-in-use which cannot be opened, moved, or deleted.
            </summary>
        </member>
        <member name="M:JetBrains.Util.FilesInUse.QueryFilesInUse(JetBrains.Util.FileSystemPath[])">
            <summary>
            Tries to get the info on who's locking the files.
            </summary>
            <param name="files"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.FileSystemCompression">
            <summary>
            Allows to manipulate the file system to have its files compressed.
            </summary>
        </member>
        <member name="T:JetBrains.Util.IPath">
            <summary>
              Base API for path-like entities.
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.Empty">
            <summary>
              Returns an empty instance of the same kind (which replaces NULL in our model).
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.ExtensionNoDot">
            <summary>
              Gets the file extension, without the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>bat</c></example>
        </member>
        <member name="P:JetBrains.Util.IPath.ExtensionWithDot">
            <summary>
              Gets the file extension, including the leading dot.
            </summary>
            <example><c>C:\autoexec.bat</c> -> <c>.bat</c></example>
        </member>
        <member name="P:JetBrains.Util.IPath.Name">
            <summary>
              Gets the local name of the file/directory (the component after the last separator).
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.Parent">
            <summary>
              Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.Parse(System.String)">
            <summary>
              Creates a new instance of the same kind from text.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.ToDirectoryUri">
            <summary>
              Creates a system <see cref="T:System.Uri" /> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.ToUri">
            <summary>
              Creates a system <see cref="T:System.Uri" /> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPath.TryCombine(System.String)">
            <summary>
              Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.FileSystemPath.Empty" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.IPath.Components">
            <summary>
            Splits the path by path separator without any special treatment, i.e. you're getting two leading empty path components for UNC paths,
            but returns empty enumerator in case of <see cref="P:JetBrains.Util.IPath.IsEmpty"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)">
            <summary>
            Returns an absolute path: if <see cref="T:JetBrains.Util.IPath" /> is already absolute, then it's left untouched. If relative, it's applied to <see cref="!:pathBaseForRelative" /> to get the absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.MakeAbsoluteBasedOn``3(JetBrains.Util.IPath,JetBrains.Util.FileSystemPathBase{``0,``1,``2})">
            <summary>
            Returns an absolute path: if <see cref="T:JetBrains.Util.IPath" /> is already absolute, then it's left untouched. If relative, it's applied to <see cref="!:pathBaseForRelative" /> to get the absolute path.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath)">
            <summary>
            Returns an absolute path if <see cref="T:JetBrains.Util.IPath" /> is absolute; otherwise, <c>NULL</c> or empty.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AssertAbsolute(JetBrains.Util.IPath)">
            <summary>
            Asserts the path is absolute and casts it to <see cref="T:JetBrains.Util.FileSystemPath" />; throws on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AsRelative(JetBrains.Util.IPath)">
            <summary>
            Returns an relative path if <see cref="T:JetBrains.Util.IPath" /> is relative; otherwise, <c>NULL</c> or empty.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.AssertRelative(JetBrains.Util.IPath)">
            <summary>
            Asserts the path is absolute and casts it to <see cref="T:JetBrains.Util.FileSystemPath" />; throws on failure.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IPathEx.TryGetTopmostPathWithName``1(``0,System.String)">
            <summary>
            Try to get topmost folder from <paramref name="path"/> and it's parents 
            </summary>
            <returns>Path with Name equals to <paramref name="name"/>, or empty path</returns>
        </member>
        <member name="M:JetBrains.Util.IPathEx.TryGetBottommostPathWithName``1(``0,System.String)">
            <summary>
            Try to get bottommost folder from <paramref name="path"/> and it's parents 
            </summary>
            <returns>Path with Name equals to <paramref name="name"/>, or empty path</returns>
        </member>
        <member name="T:JetBrains.Util.RelativePath">
            <summary>
            A relative path.
            </summary>
            <remarks>As the <see cref="T:JetBrains.Util.FileSystemPath" /> should only represent paths applicable to the file system, i.e. absolute paths, this class allows to store and perform path operations on relative paths.</remarks>
        </member>
        <member name="M:JetBrains.Util.RelativePath.#ctor(System.String)">
            <summary>
            Creates new instance.
            The constructor is left for backward compatibility only. Use <see cref="M:JetBrains.Util.FileSystemPath.Parse(System.String,JetBrains.Util.FileSystemPathInternStrategy)" /> or <see cref="M:JetBrains.Util.FileSystemPath.TryParse(System.String,JetBrains.Util.FileSystemPathInternStrategy)" /> instead.
            </summary>
            <param name="path">String that represents path</param>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws invalid path exception in case of invalid characters found.</exception>
        </member>
        <member name="P:JetBrains.Util.RelativePath.Parent">
            <summary>
            Gets the parent directory of the current file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.Parse(System.String)">
            <summary>
            Create new instance from string. Throws exceptions if fails.
            </summary>
            <param name="path">Path string</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath" /></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path" /> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser" /> for details</exception>
        </member>
        <member name="M:JetBrains.Util.RelativePath.TryParse(System.String)">
            <summary>
            Creates <see cref="T:JetBrains.Util.FileSystemPath" /> from string or <see cref="F:JetBrains.Util.RelativePath.Empty" /> if fails
            </summary>
            <param name="path"></param>
            <returns>Created path ot <see cref="F:JetBrains.Util.RelativePath.Empty" /></returns>
        </member>
        <member name="M:JetBrains.Util.RelativePath.CreateByCanonicalPath(System.String)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.Combine(System.String)">
            <summary>
            Combines a path with one or more path components. Throws on failure.
            </summary>
            <remarks>
            Returns itself if component is null.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.RelativePath.ToDirectoryUri">
            <summary>
            Creates a system <see cref="T:System.Uri" /> object from this instance, making sure it ends in a slash.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.ToUri">
            <summary>
            Creates a system <see cref="T:System.Uri" /> object from this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RelativePath.JetBrains#Util#IPath#TryCombine(System.String)">
            <summary>
            Does not throw on failure, just silently returns <see cref="F:JetBrains.Util.RelativePath.Empty" />.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ReparsePoints">
            <summary>
            Wraps Windows NT APIs for working with NTFS reparse points. The first implementation supports Directory Junctions (aka Mount Points).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Paths.SoftLinks">
            <summary>
            Manages cross-platform interfaces to soft links, which are directory junction reparse points on WinNT and supposedly symbolic links on *nix.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Paths.SoftLinks.CreateNewSoftLinkForDirectory(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath,System.Boolean)">
            <summary>
            Creates a new soft link for target dir.
            </summary>
            <param name="targetDir"></param>
            <param name="linkDir"></param>
            <param name="canRewriteOldLink"></param>
        </member>
        <member name="M:JetBrains.Util.Paths.SoftLinks.SetDirectorySoftLink(JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath)">
            <summary>
            </summary>
            <param name="sourcedir">LINK directory</param>
            <param name="targetdir">ORIGIN directory</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Util.UnixFileSystemInteraction.GetFileAccessPathCore(JetBrains.Util.FileSystemPath)">
            <summary>
            UNIX file access path is the same as the canonical path.
            </summary>
        </member>
        <member name="T:JetBrains.Util.VirtualDirectoryEntryData">
            <summary>
            Data object for the advanced <c>GetChild*</c> methods family on a file system path.
            </summary>
        </member>
        <member name="P:JetBrains.Util.VirtualDirectoryEntryData.BaseDir">
            <summary>
            The base dir for <see cref="P:JetBrains.Util.VirtualDirectoryEntryData.RelativePath" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.VirtualDirectoryEntryData.RelativePath">
            <summary>
            Path of this item, relative to <see cref="P:JetBrains.Util.VirtualDirectoryEntryData.BaseDir" />. Will only have more than one component if recursive.
            </summary>
        </member>
        <member name="F:JetBrains.Util.VirtualDirectoryEntryData.FileModificationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.VirtualDirectoryEntryData.FileCreationTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.VirtualDirectoryEntryData.FileAccessTimeUtc">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.VirtualDirectoryEntryData.Attributes">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="F:JetBrains.Util.VirtualDirectoryEntryData.Length">
            <summary>
            Prefetched file attributes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.VirtualDirectoryEntryData.GetAbsolutePath">
            <summary>
            Concats into the abs path.
            </summary>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Util.VirtualDirectoryEntryData.Existence">
            <summary>
            Tells files from dirs, if you're enumerating for both.
            </summary>
        </member>
        <member name="M:JetBrains.Util.VirtualDirectoryEntryData.WithBaseDir(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Rebases onto another base dir and updates the relative path.
            Does not allow the relative path to go upwards (have two-dot components).
            </summary>
        </member>
        <member name="M:JetBrains.Util.VirtualFileSystemPath.CreateByCanonicalPath(System.String,JetBrains.Util.IInteractionContext,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Should be used with care, in special cases only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.VirtualFileSystemPath.TryParse(System.String,JetBrains.Util.IInteractionContext,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Creates <see cref="T:JetBrains.Util.FileSystemPath"/> from string or <see cref="T:System.Empty"/> if fails
            </summary>
            <param name="path">String to be converted into <see cref="T:JetBrains.Util.FileSystemPath"/></param>
            <param name="internStrategy">If the path needs to be interned</param>
            <returns>Created path or <see cref="T:System.Empty"/></returns>
        </member>
        <member name="M:JetBrains.Util.VirtualFileSystemPath.Parse(System.String,JetBrains.Util.IInteractionContext,JetBrains.Util.FileSystemPathInternStrategy)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath"/> from string. Throws exceptions if fails.
            </summary>
            <param name="path">Path string</param>
            <param name="internStrategy">If the path needs to be interned</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath"/></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path"/> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser"/> for details</exception>
        </member>
        <member name="M:JetBrains.Util.VirtualFileSystemPath.ParseRelativelyTo(System.String,JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Create new <see cref="T:JetBrains.Util.FileSystemPath" /> from string. Throws exceptions if fails.
            If the string represents an absolute path, just parses it as with <see cref="M:JetBrains.Util.VirtualFileSystemPath.Parse(System.String,JetBrains.Util.IInteractionContext,JetBrains.Util.FileSystemPathInternStrategy)" />.
            If the string represents a relative path, treats it as relative to <see cref="!:basePathForRelativeStrings" /> to make an absolute path.
            This is the same as calling <see cref="M:JetBrains.Util.FileSystemDefinition.Parse(System.String)" /> and then <see cref="M:JetBrains.Util.IPathEx.AsAbsolute(JetBrains.Util.IPath,JetBrains.Util.FileSystemPath)" /> (you can use the same path to get an analogy for <see cref="M:JetBrains.Util.VirtualFileSystemPath.TryParse(System.String,JetBrains.Util.IInteractionContext,JetBrains.Util.FileSystemPathInternStrategy)" />).
            </summary>
            <param name="path">Path string</param>
            <param name="basePathForRelativeStrings">If <paramref name="path" /> represents a relative path, it's relative to this base.</param>
            <returns>Created <see cref="T:JetBrains.Util.FileSystemPath" /></returns>
            <exception cref="T:System.ArgumentNullException">Throws ArgumentNullException if <see cref="!:path" /> is Null</exception>
            <exception cref="T:JetBrains.Util.InvalidPathException">Throws InvalidPathException if input string contains invalid characters. See <see cref="T:JetBrains.Util.FileSystemPathParser" /> for details</exception>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.DeleteFile(JetBrains.Util.FileSystemPath,System.Boolean@,System.Int32)">
            <summary>
            Does not fail if there is no such file.
            </summary>
            <param name="ths"></param>
            <param name="isDirectory">return true if it is a directory</param>
            <param name="nAttempts"></param>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.DeleteDirectoryNonRecursive(JetBrains.Util.FileSystemPath,System.Int32,System.Exception@)">
            <summary>
            Deletes just an empty directory.
            Does not fail if there is no such file or directory.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetLongPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Expands short name components in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetShortPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Shrinks name components to their short form in existing path
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetExists(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets whether this path exists in the file system, and whether it is a directory or a file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetInfo(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets various information about file or directory in one system call. Throws on I/O errors.
            </summary>
            <returns>File/directory information if entity exists, null if not</returns>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileModificationTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the last write time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileCreationTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the creation time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileLastAccessedTimeUtc(JetBrains.Util.FileSystemPath)">
            <summary>
            Gets the last accessed time of the file represented by this instance. Throws if there is no such file.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemInteraction.GetFileAccessPath(JetBrains.Util.FileSystemPath)">
            <summary>
            Special path for passing to Windows API functions
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemPathUtils.GetGuidVolumeRootPath(System.Char)">
            <summary>
            Where <paramref name="drive" /> is a drive letter, gets the volume GUID path for it, e.g. <c>\\?\Volume{DD6AB3D2-C882-4293-BC64-53BFCC07B2B4}</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemPathUtils.UnblockZoneIdentifier(JetBrains.Util.FileSystemPath)">
            <summary>
            Remove NTFS stream with sandboxing data.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Win32FileSystemPathUtils.UnblockZoneIdentifier(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Remove NTFS stream with sandboxing data.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.AnonymousLogger">
            <summary>
            An anonymous delegate-based implementation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.AnonymousLogger.#ctor(JetBrains.Diagnostics.LoggingLevel,System.String,System.Action{JetBrains.Util.LogEvent})">
            <summary>
            Anon implementation for the logger.
            </summary>
            <param name="category">This category does not take part in the logging, just gets reported to clients (and they can create log events with it).</param>
            <param name="log">Callback when an event is logged.</param>
            <param name="maxLoggingLevel">How to tell clients if logging is enabled for a level when they ask in <see cref="M:JetBrains.Diagnostics.ILog.IsEnabled(JetBrains.Diagnostics.LoggingLevel)" /> (they'd skip rendering messages if not). All levels same or more prioritized (more prioritized means a lower integer value for a logging level) are enabled.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.AnonymousLogger.#ctor(System.String,System.Action{JetBrains.Util.LogEvent},System.Func{JetBrains.Diagnostics.LoggingLevel,System.Boolean})">
            <summary>
            Anon implementation for the logger.
            </summary>
            <param name="category">This category does not take part in the logging, just gets reported to clients (and they can create log events with it).</param>
            <param name="log">Callback when an event is logged.</param>
            <param name="FIsEnabled">Callback to tell clients if logging is enabled for this level (they'd skip rendering messages if not). NULL means all is enabled.</param>
        </member>
        <member name="F:JetBrains.Util.Logging.LogConfig.Updating">
            <summary>
            Special log config when the config is being build
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.LogManager.DisableFileAutoUpdates">
            <summary>
            When true, no new configuration is beeing read from file
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.LogManager.AddOmnipresentLogger(JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogEventListener,JetBrains.Diagnostics.LoggingLevel,JetBrains.Util.Logging.IFilter[])">
            <summary>
            Note! Client API should use <see cref="M:JetBrains.Util.Logging.Logger.AttachRootListener(JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogEventListener,JetBrains.Diagnostics.LoggingLevel,JetBrains.Util.Logging.IFilter[])"/> or <see cref="M:JetBrains.Util.Logging.Logger.AttachListener``1(JetBrains.Lifetimes.Lifetime,System.Func{``0},System.String,System.String)"/> that simply delegates here.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.LogManager.SetConfig(JetBrains.Util.Logging.XmlLogConfigModel,System.Boolean)">
            <summary>
            Programming API for set hierarchical logger. Given model will be processed by all transformations from <see cref="F:JetBrains.Util.Logging.LogManager.myTransformations"/>
            </summary>
            <param name="model"></param>
            <param name="forceSet">Set even if <see cref="!:model"/> is equal to current <see cref="P:JetBrains.Util.Logging.LogManager.Model"/></param>
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.CacheOnException(JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData[],System.Exception)">
            <summary>
            Caches the given framedata on an exception (it's not possible to retrieve stack frame info for an exception that's not freshly-caught).
            Skips if the data is empty, assuming we'd rather try again another time.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.EnrichStackTraceStringWithIlOffsets(System.String,JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData[],System.Boolean,System.Boolean)">
            <summary>
            Given a stack trace string, as of an <see cref="T:System.Exception" />'s <see cref="P:System.Exception.StackTrace" />, enriches the stack frames which are missing the line number information by trying to lookup the relevant IL Offset values in the given <see cref="T:System.Diagnostics.StackFrame" />s (which are supposed to be created off the same exception).
            The offsets info could be use to look up the exact exception stop either in DotPeek or in the IL Viewer tool window in the IDE.
            We can't just recreate the stack trace text from stack frames, even though tempting, because with async task continuations the stack trace gets recorded frames from the previous location, which we cannot recreate here.
            </summary>
            <param name="strace">The original stack trace text from the exception.</param>
            <param name="stackFramesSorted">The frames, created from the same exception as a <see cref="T:System.Diagnostics.StackFrame" /> collection and extracted as <see cref="T:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData" />, to supply the il offset info. NOTE that it might not be possible to extract this info from a non-freshly-caught exception.</param>
            <param name="isReplaceExistingLineInfo">Whether to wipe all line numbers already in the stack trace and replace with IL offsets. When False, will only add to lines which are missing the offset information.</param>
            <param name="isAddMvid">Whether to add a small prefix piece of the assembly MVID together with the IL offset, to check whether the correct version of the DLL is used for matching those offsets.</param>
            <returns>The stack trace string, enriched. Use in place of <paramref name="strace" />.</returns>
        </member>
        <member name="T:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData">
            <summary>
            Extracted from <see cref="T:System.Diagnostics.StackFrame" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData.#ctor(System.String[],System.Int32,System.Nullable{System.Guid})">
            <summary>
            Extracted from <see cref="T:System.Diagnostics.StackFrame" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData.Equals(JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData.FromException(System.Exception)">
            <summary>
            This would only work if the exception is freshly caught. A stored exception won't give its frames in this form.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ExceptionStackTraceHelpers.FrameData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Util.Logging.Filters.BurstFilter.BurstLimitForDistinctExceptions">
            <summary>
            Stop taking new exceptions with distinct prefixes of <see cref="F:JetBrains.Util.Logging.Filters.BurstFilter.PrefixLength" /> within <see cref="F:JetBrains.Util.Logging.Filters.BurstFilter.BurstPeriodMs" /> after this number.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Filters.BurstFilter.BurstLimitForSimilarExceptions">
            <summary>
            Of exceptions with the same prefix of <see cref="F:JetBrains.Util.Logging.Filters.BurstFilter.PrefixLength" /> within <see cref="F:JetBrains.Util.Logging.Filters.BurstFilter.BurstPeriodMs" />, allow only as many.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Filters.BurstFilter.BurstPeriodMs">
            <summary>
            All metrics reset after this time.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Filters.BurstFilter.PrefixLength">
            <summary>
            If exceptions differ in this many first chars, apply looser rate limit (e.g. a row of identical exceptions and then something unique).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ILayout.FormatUnsafe(JetBrains.Serialization.UnsafeWriter,JetBrains.Util.LogEvent)">
            <summary>
            For optimized usages
            </summary>
            <param name="writer"></param>
            <param name="logEvent"></param>
        </member>
        <member name="T:JetBrains.Util.Logging.PatternLayout.PatternLayoutParser">
            <summary>
            A class which incapsulates lazy-creation of the pattern parsing system.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredMetric_Documentation(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)">
            <summary>
            Logs a measurement from outside.
            </summary>
            <param name="logger">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="message">Optional message with extra data</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasurement(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,JetBrains.Util.Logging.MetricUnit,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredMetric_Documentation(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <param name="value">Value to log, measured in <paramref name="unit"/></param>
            <param name="unit">Unit of <paramref name="value"/></param>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasurement(JetBrains.Util.ILogger,System.String,System.Int64,JetBrains.Util.Logging.MetricUnit,System.String,System.Nullable{System.Int64})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasurement(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,JetBrains.Util.Logging.MetricUnit,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredTime(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredMetric_Documentation(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <remarks>
            Use in case you aggregate your measurement over several intervals or if it comes form outside, or you manually pre-collected values to log.
            Otherwise prefer to use StopwatchCookie or HotspotWatchdog
            </remarks>
            <param name="timeMs">Time to log, in milliseconds</param>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredTime(JetBrains.Util.ILogger,System.String,System.Int64,System.String,System.Nullable{System.TimeSpan})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredTime(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)"/>
            <remarks>
            Use in case you aggregate your measurement over several intervals or if it comes form outside, or you manually pre-collected values to log.
            Otherwise prefer to use StopwatchCookie or HotspotWatchdog/>
            Defaults to VERBOSE level
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredSize(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredMetric_Documentation(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <param name="bytes">Data size to log, in bytes</param>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredSize(JetBrains.Util.ILogger,System.String,System.Int64,System.String,System.Nullable{System.Int64})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredSize(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredCount(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredMetric_Documentation(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <param name="count">Count to log</param>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredCount(JetBrains.Util.ILogger,System.String,System.Int64,System.String,System.Nullable{System.Int64})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredCount(JetBrains.Diagnostics.LogWithLevel,System.String,System.Int64,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredData(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)">
            <summary>
            Log any measurement data from outside
            </summary>
            <param name="logger">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="data">Data you would like to store</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> or <paramref name="data"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredData(JetBrains.Util.ILogger,System.String,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.LogMeasuredData(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.StructuredMarker(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)">
            <summary>
            Puts a simple marker into log, that can be used to relate events before it or after it to some greater things
            </summary>
            <param name="logger">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="message">Optional message with extra data</param>
            <exception cref="T:System.ArgumentNullException">if <paramref name="key"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.StructuredMarker(JetBrains.Util.ILogger,System.String,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.StructuredMarker(JetBrains.Diagnostics.LogWithLevel,System.String,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.Action)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String,System.Action)"/>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoCalculation``1(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.Func{``0})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.DoCalculation``1(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String,System.Func{``0},System.Func{``0,System.String})"/>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String,System.Action)">
            <summary>
            Measures execution time of lambda, logs success/canceled/exception.
            </summary>
            <param name="logger">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="message">Optional message with extra data</param>
            <param name="action">Code to execute</param>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoCalculation``1(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String,System.Func{``0},System.Func{``0,System.String})">
            <summary>
            Measures execution time of lambda, logs success/canceled/exception.
            </summary>
            <param name="logWithLevel">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="message">Optional message with extra data</param>
            <param name="action">Code to execute</param>
            <param name="report">Code to dump result into Finish record</param>
            <returns>Result of <paramref name="action"/> invocation</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(JetBrains.Util.ILogger,System.String,System.String,System.Action)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.Action)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.DoCalculation``1(JetBrains.Util.ILogger,System.String,System.String,System.Func{``0})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.DoActivity(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.Action)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.StopwatchCookie(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String)">
            <summary>
            Returns a cookie that, when disposed, logs time from creation to disposal.
            </summary>
            <param name="logger">Logger to use</param>
            <param name="key">Sub-key. Avoid duplication with logger category.</param>
            <param name="message">Optional message with extra data</param>
            <returns>The cookie</returns>
            <exception cref="T:System.ArgumentNullException">If <paramref name="key"/> is null</exception>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.StopwatchCookie(JetBrains.Util.ILogger,System.String,System.String,System.Nullable{System.TimeSpan})">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.StopwatchCookie(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String)"/>
            <remarks>Defaults to VERBOSE level</remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.LoggerStructuredEx.PerformanceCookie(JetBrains.Util.ILogger,System.String)">
            <inheritdoc cref="M:JetBrains.Util.Logging.LoggerStructuredEx.StopwatchCookie(System.Nullable{JetBrains.Diagnostics.LogWithLevel},System.String,System.String)"/>
            <remarks>Defaults to VERBOSE level and passes performanceMetric further to be processed by PerformanceTestAttribute</remarks>
        </member>
        <member name="T:JetBrains.Util.Logging.DebugOutputLogEventListener">
            <summary>
            Listens for the <see cref="T:JetBrains.Util.Logging.Logger"/> events and reports them into the Debug stream.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.#ctor(System.String)">
            <summary>
            Constructs the listener.
            </summary>
            <param name="prefix">A prefix that will be prepended to each of the output lines.</param>
        </member>
        <member name="F:JetBrains.Util.Logging.DebugOutputLogEventListener.OptionDontWriteDebugStream">
            <summary>
            Helper flag to prevent the logger messages from being emitted as traces when it's known that the message will get into the traces with some other means.
            Eg when capturing Trace::WriteLine into the Logger, the logger should be prevented from emitting it to the Debug stream, as it will be a duplicate.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.WriteDebugStream(System.String,System.String)">
            <summary>
            Writes a <paramref name="body"/> string to the Debug output stream.
            Appends the <paramref name="prefix"/> to the beginning of each line for the filtering needs.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.DebugOutputLogEventListener.CombinePrefices(System.String)">
            <summary>
            Combines the predefined object prefix with the given prefix. Both might be empty.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener">
            <summary>
            Listens to the Logger events and writes them down into a <see cref="T:System.IO.TextWriter" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.CreateFileLogger(System.String)">
            <summary>
            Creates a logger that logs to a file. Starts listening to the events immediately, dispose of to stop.
            </summary>
            <param name="identity">Helps distinguish the file name. Should be filename-friendly.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.PushToLogger(JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Adds self to the logger, removes when this object is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Listeners.TextWriterLogEventListener.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Util.Logging.Logger">
            <summary>
            This is entry point for all ReSharper logging methods
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.Logger.FileLoggingLevel">
            <summary>
            Specified via `resharper.loglevel INFO(/VERBOSE/TRACE/etc.)` cmdline switch.
            Defines the threshold of messages that would be logged into file. If `null` file is configured according LogConfig.xml
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.Logger.LogFileName">
            <summary>
            Warning! Please don't use it outside of <c>ApplyCommandLineKeysToLogger</c>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.LogFileNamePrefix">
            <summary>
            Prefix of the log file name, in case it's generated automatically.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.LogsSubfolderName">
            <summary>
            Subfolder inside the user's temp where the log files are stored.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Annotate(System.Action,System.Action{System.Exception})">
            <summary>
            <para>Executes the <paramref name="F">nested action</paramref>.</para>
            <para>If the action fails with an exception, allows to annotate the exception with additional context info in <paramref name="FCommentException"/>.</para>
            <para>The choices for the annotation are:</para>
            <list type="numbered">
            <item><description>To refine the context information, call the <see cref="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})"/> fluent method on the exception object you're given.</description></item>
            <item><description>To add one more level of context, throw a new exception nesting the orignial one as an <see cref="P:System.Exception.InnerException"/>.</description></item>
            </list>
            </summary>
            <param name="F">The worker code whose exceptions will be annotated.</param>
            <param name="FCommentException">Called only when the <paramref name="F">worker code</paramref> throws an exception. Allows to add context-related information to the exception.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Assert(System.Boolean,System.String)">
            <summary>
            Invokes <see cref="M:JetBrains.Util.Logging.Logger.Fail(System.String)"/> if the <paramref name="condition"/> is <c>False</c>.
            This method do not break the execution flow, use Assertion::Assert if that is what's intended.
            </summary>
            <remarks>
            DO NOT ANNOTATE THIS METHOD WITH [AssertionMethod] OR [ContractAnnotation("bool->halt")].
            DON'T DO THIS. PLEASE. THIS IS WRONG. THIS METHOD DO NOT BREAK THE EXECUTION FLOW.
            PLEASE, FOR THE LOVE OF THE UNIVERSE, STOP DOING THIS. PLEASE, USE ASSERTION.ASSERT.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Assert(System.Boolean,System.String,System.Object[])">
            <summary>
            Invokes <see cref="M:JetBrains.Util.Logging.Logger.Fail(System.String)"/> if the <paramref name="condition"/> is <c>False</c>.
            This method do not break the execution flow, use Assertion::Assert if that is what's intended.
            </summary>
            <remarks>
            DO NOT ANNOTATE THIS METHOD WITH [AssertionMethod] OR [ContractAnnotation("bool->halt")].
            DON'T DO THIS. PLEASE. THIS IS WRONG. THIS METHOD DO NOT BREAK THE EXECUTION FLOW.
            PLEASE, FOR THE LOVE OF THE UNIVERSE, STOP DOING THIS. PLEASE, USE ASSERTION.ASSERT.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.Action,System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="func"/> and returns its result or default value if exception happens.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch``1(System.String,System.Func{``0})">
            <summary>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Catch(System.String,System.Action)">
            <summary>
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnore(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnore``1(System.Func{``0},``0)">
            <summary>
            Executes the <paramref name="F"/>. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all of the exceptions, suppresses them (logs silently), and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent``1(System.Func{``0},``0)">
            <summary>
            Executes the <paramref name="func"/>. Catches all of the exceptions, reports them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchSilent``2(``0,System.Func{``0,``1},``1)">
            <summary>
            Executes the <paramref name="func"/>. Catches all of the exceptions, reports them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreException``2(System.Func{``0},``0)">
            <summary>
            Executes the <paramref name="F"/>. Catches all exceptions except the ones that should be ignored
            (OperationCanceledException for instance, these are silently suppressed), logs them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreException``1(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all exceptions except the ones that should be ignored
            (OperationCanceledException for instance, these are silently suppressed), logs them and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchButOperationCanceledException``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="f"/>. Catches all exceptions, but rethrow OperationCanceledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreButOperationCanceledException``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="f"/>. Catches all exceptions, but rethrow OperationCanceledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchIgnoreButOperationCanceledException(System.Action)">
            <summary>
            Executes the <paramref name="f"/>. Catches all exceptions, but rethrow OperationCanceledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CatchButOperationCanceledException(System.Action)">
            <summary>
            Executes the <paramref name="action"/>. Catches all exceptions, but rethrow OperationCanceledException
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CleanupOldLogFiles">
            <summary>
            Logs are stored for a week. Old log files are deleted by this function. In default log folder.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.CleanupOldLogFiles(JetBrains.Util.FileSystemPath)">
            <summary>
            Logs are stored for a week. Old log files are deleted by this function. In custom folder.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.DropException(System.Exception)">
            <summary>
            Drops the exception by doing nothing with it, not even logging it silently (unlike <see cref="M:JetBrains.Util.Logging.Logger.LogExceptionSilently(System.Exception)"/>).
            Use it to:
            (1) Stub catch-alls to avoid "empty general catch clause" warnings.
            (2) Explicitly mark such exception-hiding places for the later reviewing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Fail(System.String)">
            <summary>
            Logs the exception made from <paramref name="messageText"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Fail(System.String,System.Object[])">
            <summary>
            Logs the exception made from <paramref name="format"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.FormatStringSafe(System.String,System.Object[])">
            <summary>
            Invokes <see cref="M:System.String.Format(System.String,System.Object[])"/>, if it throws, falls back to appending the args as strings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Init">
            <summary>
            Initializes file logging. This method shouldn't be used by user.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.Init(JetBrains.Lifetimes.Lifetime,System.Nullable{JetBrains.Diagnostics.LoggingLevel})">
            <summary>
            Initializes file logging bound to specified lifetime. This method shouldn't be used by user.
            </summary>
            <remarks>
            In some cases might be necessary to close file logging deterministically.<br/>
            <br/>
            For example: console tool which logs something big and immediately exits.<br/>
            File logger is asynchronous and flushing its content in the background thread. On exit .NET runs file stream finalizer in the finalizer thread.
            Here we can get a race condition: Flush called from FileStream-s finalizer and Flush called from file logger.
            To prevent this we should terminate lifetime explicitly before exit.
            </remarks>
            <param name="lifetime">Terminates the handling when this ends. REQUIRED for short-running processes, otherwise the messages still on the async pipeline will be lost.</param>
            <param name="filelogginglevel">Allows to specify the file logging level instead of setting properties. If non-NULL, will set the level and turn on <see cref="P:JetBrains.Util.Logging.Logger.IsFileLoggingEnabled"/>, both require for this method doing anything at all. If NULL, would do whatever <see cref="P:JetBrains.Util.Logging.Logger.IsFileLoggingEnabled"/> and <see cref="P:JetBrains.Util.Logging.Logger.FileLoggingLevel"/> say.</param>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogError(System.String)">
            <summary>
            Invokes all the listeners for logging the message as an error.
            Then constructs an exception and logs it (again invoking the listeners, but for logging an exception this time).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogError(System.String,System.Object[])">
            <summary>
            Invokes all the listeners for logging the message as an error.
            Then constructs an exception and logs it (again invoking the listeners, but for logging an exception this time).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)">
            <summary>
            Writes the exception to the log and notifies the listeners about it.
            The executing stack trace is also written .
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogException(System.String,System.Exception)">
            <summary>
            Writes the exception to the log and notifies the listeners about it.
            The executing stack trace is also written.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogExceptionSilently(System.Exception)">
            <summary>
            Logs the exception without notifying the registered listeners about it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(JetBrains.Diagnostics.LoggingLevel,System.String)">
            <summary>
            Logs a message if it is not too verbose.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(JetBrains.Diagnostics.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs a message if it is not too verbose.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(System.String)">
            <summary>
            Logs a message if it is not <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE"/>.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.LogMessage(System.String,System.Object[])">
            <summary>
            Logs a message if it is not <see cref="F:JetBrains.Diagnostics.LoggingLevel.INFO"/>.
            The message is prepended with a timestamp and written to the log. The listeners are notified.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Logging.Logger.Interface">
            <summary>
            Gets this logger as an interface.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Logging.Logger.Root">
            <summary>
            Get logger with empty category. Almost always you should use <see cref="M:JetBrains.Util.Logging.Logger.GetLogger``1"/> or <see cref="M:JetBrains.Util.Logging.Logger.GetLogger(System.String)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.GetLogger``1">
            <summary>
            Gets or creates logger <see cref="P:System.Type.FullName"/>
            </summary>
            <returns>Logger with category <see cref="P:System.Type.FullName"/></returns>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.GetLogger(System.Type)">
            <summary>
            Gets or creates logger <see cref="P:System.Type.FullName"/>
            </summary>
            <param name="callerType">Use this type's FQN as category</param>
            <returns>Logger with category <see cref="P:System.Type.FullName"/></returns>
        </member>
        <member name="M:JetBrains.Util.Logging.Logger.GetLogger(System.String)">
            <summary>
            Gets or creates logger with category = <c>"fullClassName"</c>
            </summary>
            <returns>Logger with category <c>"fullClassName"></c></returns>
        </member>
        <member name="T:JetBrains.Util.Logging.LoggerContext">
            <summary>
            Allows to specify some contextual (static) information for log messages. Analogue of log4net MDC (message diagnostics context). 
            So you can set some <code>LoggerContext.GlobalContext["key"] = value</code> and then log message with log pattern <c>%X{key}</c> to print context.
            See <see cref="T:JetBrains.Util.Logging.PatternLayout"/> for more details 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Logging.ConfiguredLogger.BreakOnAllErrors(JetBrains.Util.LogEvent)">
            <summary>
            All logged errors and assertions and exceptions should pass through this method. Place your breakpoint here if you want to break on all errors.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Logging.Loggers.IndentedLogger">
            <summary>
            An wrapper around <see cref="T:JetBrains.Util.ILogger"/> to support log indenting.
            </summary>
        </member>
        <member name="T:JetBrains.Util.CompoundException">
            <summary>
            Aggregates multiple exceptions.
            </summary>
        </member>
        <member name="P:JetBrains.Util.CompoundException.Exceptions">
            <summary>
            All of the recorded exceptions in this object. See also <see cref="M:JetBrains.Util.CompoundException.GetDistinctExceptions" />.
            </summary>
        </member>
        <member name="P:JetBrains.Util.CompoundException.Message">
            <summary>
            Gets a message that describes the current exception.
            </summary>
            <returns>
            The error message that explains the reason for the exception, or an empty string("").
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="P:JetBrains.Util.CompoundException.OnError">
            <summary>
            Gets an OnError object which would record reported exceptions into this compound exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CompoundException.ExtractException">
            <summary>
            If there were no exceptions, returns <c>NULL</c>.
            If there were only one exception, returns exactly that exception.
            If there were multiple exceptions, returns this compound object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CompoundException.ThrowIfFailed">
            <summary>
            Throws if there were no exceptions.
            The original exception is never thrown because that would rewrite its stack trace.
            </summary>
        </member>
        <member name="M:JetBrains.Util.CompoundException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <filterpriority>1</filterpriority>
            <PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*" /></PermissionSet>
        </member>
        <member name="M:JetBrains.Util.CompoundException.GetDistinctExceptions">
            <summary>
            Executes Distinct->ToList on <see cref="P:JetBrains.Util.CompoundException.Exceptions" /> every time you call this method.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer">
            <summary>
            Renders exceptions by extracting as much data as possible (including inner exceptions in nonstandard properties,
            like <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" />, and special parameters like <see cref="P:System.ArgumentException.ParamName" />),
            and presents them in human-readable and machine-readable format and in a reasonable order of inner exceptions.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HiddenExceptionDataNameSubstring">
            <summary>
            Prevents exception data members from being rendered to output.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.RenderedExceptionSealedKey">
            <summary>
            Forbids invalidation of rendered exception text. Used for pre-rendered exceptions from other processes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.GetAllNestedExceptions(System.Exception)">
            <summary>
            Looks up all of the exceptions in the exception tree. Checks for the <see cref="P:System.Exception.InnerException" />,
            other possible exception properties (eg <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" />), and data bag.
            The original exception is too included with the collection.
            </summary>
            <param name="ex">The exception to look into.</param>
            <returns>The <paramref name="ex" /> plus all of the nested exceptions.</returns>
            <remarks>This method is slow somewhat and does not cache the results.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderException(System.Exception,System.Collections.Generic.IDictionary{System.Object,System.Collections.Generic.IList{System.Object}},System.Nullable{System.Boolean})">
            <summary>
              <para>Renders a string representation of the exception by collecting all of the data about the original exception and all of the inner/related exceptions in the tree.</para>
              <para>Explicitly outlines the relation between the exceptions, like which is whose inner and where they're coming from in the inner-exception tree.</para>
              <para>Note that <see cref="P:System.Exception.Message" /> plus <see cref="P:System.Exception.StackTrace" /> might miss the custom fields of the exception, and <see cref="M:System.Exception.ToString" /> ignores related exceptions that are not exactly inners (eg <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" />).</para>
            </summary>
            <param name="exception">The exception to render.</param>
            <param name="customData"></param>
            <param name="renderSensitiveData">Add sensitive data to the text or not. By default uses <see cref="F:JetBrains.Util.ExceptionRenderer.ForceRenderSensitiveData"/> value</param>
            <returns>
              <para>A string containing all of the meaningful messages of all the inner exceptions.</para>
              <para>A string with the above message plus stack traces and any other associated data.</para>
            </returns>
            <remarks>This method might be slow, but it caches the rendered data on the exception after the first call.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderOuterExceptionMessageAndData(System.Exception)">
            <summary>
            Renders the exception message that includes all of the additional data fields, but of the outermost exception only.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.IsBusy">
            <summary>
            Per-thread recursion prevention flag. Might be leading to a <see cref="T:System.StackOverflowException"/> if happens.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.NoiseExceptionMessages">
            <seealso cref="M:JetBrains.Util.ExceptionRenderer.IsExceptionMessageNoise(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.CollectExDatas(System.Exception,System.Boolean)">
            <summary>
            Traverses the inner exceptions tree and extracts atomic datas ready for printing out.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.GetExceptionDataCached(System.Exception,System.String,System.Func{System.String})">
            <summary>
            Gets the value cached on the exception object.
            Calculates and caches if missing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.PrintExDatas(System.Collections.Generic.IList{JetBrains.Util.ExceptionRenderer.ExData})">
            <summary>
            All of the data is collected, entries are atomic, render them (just resolve the exception index references).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.PrintExceptionMessage(System.Collections.Generic.ICollection{JetBrains.Util.ExceptionRenderer.ExData})">
            <summary>
              <para>Extracts the exception message out of the exceptions.</para>
              <para>In case the inner exceptions message is omitted from the outer exception, tries to collect all such messages too.</para>
              <para>For meaningless exception messages (usually, wrapper or multiplexor exceptions), tries to resuce the noise.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.RenderSingleExceptionObject(JetBrains.Util.ExceptionRenderer.ExData,System.Boolean)">
            <summary>
            Starts rendering an exception object, walks into expandable properties depth-first.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.IsExceptionMessageNoise(System.String)">
            <summary>
              <para>Gets if this exception message text is useless and, if there're other exception messages in the graph, should be omitted to have a clearer total message.</para>
              <para>Examples:</para>
              <para> One or more errors occurred.</para>
              <para> Exception has been thrown by the target of an invocation.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.myParentStorage">
            <summary>
            Parent, for simplicity just an array.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.Lines">
            <summary>
            Exception data lines in the Name=Value form.
            In case an exception is encountered among data values, a new <see cref="T:JetBrains.Util.ExceptionRenderer.ExData" /> is created
            and a reference to it is written in a special form into the data lines (<see cref="T:JetBrains.Util.ExceptionRenderer.ExData.InnerExceptionReference" />).
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.AllPaths">
            <summary>
            Dot-separated paths from root at which this excepiton is observed in inners and data. Sorted.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.ShortestPath">
            <summary>
            Of <see cref="F:JetBrains.Util.ExceptionRenderer.ExData.AllPaths"/>, the preferred one for display as the primary location of this exception.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.ExData.Guid">
            <summary>
            Uniquely identifies the exception, allows to reference it from parent exceptions (ref inner from outer).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.AddInnerException(System.String,System.Exception)">
            <summary>
            Reports an inner exception of the current exception.
            </summary>
            <param name="relprefix">Path relative to the current object.</param>
            <param name="exIn">The inner exception to register.</param>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.AddPathLines">
            <summary>
            For every entry in the <see cref="N:JetBrains.Util.Paths" />, adds a line to the head of the <see cref="F:JetBrains.Util.ExceptionRenderer.ExData.Lines" /> list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.DemoteLine(System.String)">
            <summary>
            Moves a line with the given name to be the last in the list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.PromoteLine(System.String)">
            <summary>
            Moves a line with the given name to be the first in the list.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.ExData.WithLineByName(System.String,System.Action{JetBrains.Util.ExceptionRenderer.Line,System.Int32})">
            <summary>
            Find the line, exec if OK.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry">
            <summary>
            Storage class which represents a named data entry when traversing exception data recursively,
            either an object which can be further expanded, or a leaf data which should be reported to the full exception text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Value">
            <summary>
            The value of this entry, either primitive or expandable, see <see cref="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKind" />.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Name">
            <summary>
            The full hierarchical name of the entry, root's being empty.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Depth">
            <summary>
            Current depth, root's being 0, tracked recursively to prevent infinite loops in exception data.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.myAddSensitiveData">
            <summary>
            Traverse sensitive data too
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Root(System.Exception,System.Boolean)">
            <summary>
            Starts enumeration with the root, which is always an exception.
            If an exception is at the root, it's expandable.
            If deeper, then it would be treated as a reference to another exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.DetectEntryKind(System.Object,System.Boolean)">
            <summary>
            Detects how this node should be treated  expanded into children, rendered as a primitive, dropped out, treated as a reference to an exception, etc.
            Detects by the value type.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKind">
            <summary>
            The <see cref="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.DetectEntryKind(System.Object,System.Boolean)">detected</see> kind of the entry.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.MaxDepth">
            <summary>
            Limits walking down expandable nodes to this many.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.MaxItems">
            <summary>
            Takes only so many items from a collection.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Parent">
            <summary>
            The parent data entry, if available. This entry has been created while expanding its value.
            Normally, the root entry is the exception, and nodes are expandable entities, such as arrays, collections, dictionaries, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.GetChildren">
            <summary>
            Expands into child entries, if this one is of an expandable kind.
            Otherwise, yields empty.
            Applies recursion and item count limitations.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice">
            <summary>
            Tells how this node should be treated  expanded into children, rendered as a primitive, dropped out, treated as a reference to an exception, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Empty">
            <summary>
            Empty entry, should not be rendered.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Primitive">
            <summary>
            This entry is not expandable and would be rendered as a primitive value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Expandable">
            <summary>
            This entry should be expanded into child entries.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.EntryKindChoice.Exception">
            <summary>
            This entry is a nested exception, so a reference to another exception instance should be rendered instead of going deep into the actual exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.Render(JetBrains.Util.ExceptionRenderer.ExData)">
            <summary>
            Renders as an exception data line, if applicable (a primitive or a reference to an exception).
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionRenderer.HierarchicalDataEntry.CoerceToString(System.Object)">
            <summary>
            Save to-string conversion using the type/value converters where available.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.ExceptionText">
            <summary>
            Result of rendering an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionText.#ctor(System.String,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object"/> class.
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionText.FullText">
            <summary>
            <para>String representation of the exception rendered by collecting all of the data about the original exception and all of the inner/related exceptions in the tree.</para>
            <para>A more detailed and well-organized counterpart for <see cref="T:System.Exception"/>'s <see cref="M:System.Exception.ToString"/> method.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.ExceptionText.Message">
            <summary>
            <para>Message of the exception, into which all of the inner exceptions' messages are also included.</para>
            <para>A more detailed counterpart for <see cref="T:System.Exception"/>'s <see cref="P:System.Exception.Message"/> property.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.ILogEventListener">
            <summary>
            Consumes the activities reported to the <see cref="T:JetBrains.Util.Logging.Logger"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Util.ILogger">
            <summary>
            Interface to the logger which can be passed to subsystems to replace the default logger in them.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.Lifetimes.Lifetime,JetBrains.Diagnostics.LoggingLevel,System.String)">
            <summary>
            Logs the same message twice, with Opening and Closing prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="level"></param>
            <param name="message"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.Lifetimes.Lifetime,JetBrains.Diagnostics.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs the same message twice, with Opening and Closing prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="level"></param>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogBracket(JetBrains.Util.ILogger,JetBrains.Lifetimes.Lifetime,JetBrains.Diagnostics.LoggingLevel,JetBrains.Util.Pair{System.String,System.String})">
            <summary>
            Logs a pair of messages (no prefix added) when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.UsingLogBracket(JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel,System.String,System.Object[])">
            <summary>
            Logs the same message twice, with Opening and Closing prefix, when entering and leaving the lifetime.
            NOTE: the closing bracket message won't be logged if the logger were not enabled at the time of the opening one.
            NOTE: Prefer overload with lifetime unless you are in a using clause
            </summary>
            <param name="ths"></param>
            <param name="level"></param>
            <param name="message"></param>
            <param name="args"></param>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.LogExceptionSilently(JetBrains.Util.ILogger,System.Exception)">
            <summary>
            Logs the exception without notifying the registered listeners about it.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch(JetBrains.Util.ILogger,System.Action,JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchAsync(JetBrains.Util.ILogger,System.Func{System.Threading.Tasks.Task},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchAsync``1(JetBrains.Util.ILogger,System.Func{System.Threading.Tasks.Task{``0}},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch(JetBrains.Util.ILogger,System.Action,JetBrains.Util.ExceptionOrigin,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch(JetBrains.Util.ILogger,System.Func{System.Threading.Tasks.Task},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch``1(JetBrains.Util.ILogger,System.Func{System.Threading.Tasks.Task{``0}},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.Catch``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchNullable``1(JetBrains.Util.ILogger,System.Func{``0},JetBrains.Util.ExceptionOrigin)">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.WhenInfo(JetBrains.Util.ILogger)">
            <summary>
            A pattern to reduce memory allocation for string.Format in logger. For Trace and Verbose use <see cref="M:JetBrains.Diagnostics.LogEx.WhenVerbose(JetBrains.Diagnostics.ILog)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.ErrorIfNotCanceled(JetBrains.Util.ILogger,System.Exception,System.String)">
            <summary>
            <para>EXPERIMENTAL.</para>
            <para>An error-logging routine for async contexts, where an <see cref="T:System.OperationCanceledException" /> (<see cref="T:System.Threading.Tasks.TaskCanceledException" />) is not an error but a special situation.</para>
            <para>OCE would get dropped and would not propagate (because this is what you'd expect from logger members).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.ErrorThrowCanceled(JetBrains.Util.ILogger,System.Exception,System.String)">
            <summary>
            <para>EXPERIMENTAL.</para>
            <para>An error-logging routine for async contexts, where an <see cref="T:System.OperationCanceledException" /> (<see cref="T:System.Threading.Tasks.TaskCanceledException" />) is not an error.</para>
            <para>OCE would not get logged and re-thrown transparently, as is customary for async contexts where it tells the caller to cancel.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchSilent(JetBrains.Util.ILogger,System.Action)">
            <summary>
            Executes the <paramref name="action" />. Catches all of the exceptions, suppresses them (logs silently), and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchSilent``1(JetBrains.Util.ILogger,System.Func{``0})">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchIgnore(JetBrains.Util.ILogger,System.Action)">
            <summary>
            Executes the <paramref name="action" />. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.CatchIgnore``1(JetBrains.Util.ILogger,System.Func{``0})">
            <summary>
            Executes the <paramref name="F" />. Catches all of the exceptions, suppresses them without logging, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ILoggerEx.DropException(JetBrains.Util.ILogger,System.Exception)">
            <summary>
            Drops the exception by doing nothing with it, not even logging it silently (unlike <see cref="M:JetBrains.Util.ILoggerEx.LogExceptionSilently(JetBrains.Util.ILogger,System.Exception)" />).
            Use it to:
            (1) Stub catch-alls to avoid "empty general catch clause" warnings.
            (2) Explicitly mark such exception-hiding places for the later reviewing.
            </summary>
        </member>
        <member name="M:JetBrains.Util.LogEvent.CreateStructuredForPlayback(System.String,JetBrains.Diagnostics.LoggingLevel,System.String)">
            <summary>
            Use only for playback perf metrics
            </summary>
            <param name="category"></param>
            <param name="level"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.LoggerException">
            <summary>
            A version of the Internal Error Exception that was created within the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.LoggerException.#ctor(System.String,System.Exception,System.Nullable{System.Int32},JetBrains.Util.LoggerException.ToStringBehavior,System.String)">
            <summary>
            Creates a new logger exception.
            </summary>
            <param name="message">Optional. Exception message. If omitted, <paramref name="innerException" />'s message will be used. If both are omitted, the default message will be used.</param>
            <param name="innerException">Optional. An inner exception. If the explicit <paramref name="message" /> is not defined, the message of this exception will be used.</param>
            <param name="ignoreFrames"><c>Null</c> to use the exception-default stack trace capture behavior (from throw-point to catch-point). A non-negative number to capture the full stack trace at exception consturction point (usually same as throw-point). This is useful for the outermost exception to have the full stack traces from the thread entry point, as opposed to the default .NET behavior, which does not give us the context. A non-zero number skips top stack frames.</param>
            <param name="toStringBehavior">How to render <see cref="M:JetBrains.Util.LoggerException.ToString" /> on this exception instance.</param>
            <param name="sOverrideStackTrace">Allows to set the stack trace string manually, e.g. when unmarshalling an exception from a string form.</param>
        </member>
        <member name="M:JetBrains.Util.LoggerException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            When overridden in a derived class, sets the <see cref="T:System.Runtime.Serialization.SerializationInfo"/> with information about the exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.LoggerException.ToString">
            <summary>
            Creates and returns a string representation of the current exception.
            </summary>
            <returns>
            A string representation of the current exception.
            </returns>
            <filterpriority>1</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*"/></PermissionSet>
        </member>
        <member name="F:JetBrains.Util.LoggerException.ToStringBehavior.RenderExceptionFullText">
            <summary>
            Uses <see cref="T:JetBrains.Util.ExceptionRenderer"/> to yield the full formatted text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.LoggerException.ToStringBehavior.BaseException">
            <summary>
            Just calls default exception string formatting.
            </summary>
        </member>
        <member name="T:JetBrains.Util.CountingLogger">
            <summary>
            Counts the number of processed events (forwarded to the underlying logger) without storing a copy of them.
            </summary>
        </member>
        <member name="P:JetBrains.Util.CountingLogger.Category">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.RecordAndThrowLogger">
            <summary>
            Records all of the exceptions, throws them out when object lifetime is terminated.
            Messages are dropped.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RecordAndThrowLogger.#ctor(JetBrains.Lifetimes.Lifetime,System.Boolean)">
            <summary>
            Lifetime version. Throws when the lifetime terminates. Must not be disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.Util.RecordAndThrowLogger.#ctor(System.Boolean)">
            <summary>
            Disposable version. Throws when disposed of. Must be disposed of eventually.
            </summary>
        </member>
        <member name="T:JetBrains.Util.RecordingLogger">
            <summary>
            Intercepts all of the logger submissions, does not escalate them to any outer loggers.
            </summary>
        </member>
        <member name="P:JetBrains.Util.RecordingLogger.Category">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.ThrowWhatYouCanLogger">
            <summary>
            For any <see cref="M:JetBrains.Util.IExceptionThrowingLogger.LogOrThrowException(System.Exception,JetBrains.Util.ExceptionOrigin)" />, does the throw thing. All other stuff is forwarded to the underlying logger.
            </summary>
        </member>
        <member name="P:JetBrains.Util.ThrowWhatYouCanLogger.Category">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions">
            <summary>
            Collects all of the exceptions logged while the object is alive.
            When the object is disposed of, or <see cref="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions" /> is manually called, throws out all of the recorded exceptions as a composite exception.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.myFCreateExceptionContainer">
            <summary>
            Allows to customize the container.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.#ctor">
            <summary>
            Records all of the logged exceptions. Throws them all out either on <see cref="M:System.IDisposable.Dispose" /> or <see cref="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions" />.
            </summary>
            <remarks>
            A lifetimed version was removed and should be used. A lifetime would intercept all of the exceptions upon termination. Thus, everything we throw in Dispose would be lost (as there's no other logger listener after we're removed on Dispose).
            Install this object with C# using(){} construct outside any lifetime creation.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.#ctor(System.Func{JetBrains.Util.CompoundException})">
            <param name="FCreateExceptionContainer">
            Allows to customize the container.
            </param>
        </member>
        <member name="P:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.LoggedExceptions">
            <summary>
            Exceptions logged during the session.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.Dispose(System.Boolean)">
            <summary>
            Forces the finalizable objects to check whether their <see cref="M:System.IDisposable.Dispose" /> contract was fulfilled.
            Reports all of the exceptions that have occurred within the listener's life.
            Detaches from the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.RecycleLoggedExceptions">
            <summary>
            Returns the current <see cref="P:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.LoggedExceptions" /> object, and creates a new (empty) one instead of it.
            Does not actually throw the exception.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions">
            <summary>
            If there are any logged exceptions, throws them out.
            Cleans up the exceptions store for further uses.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.ThrowLoggedExceptions_ThrowSpecial(JetBrains.Util.CompoundException)">
            <summary>
            Allows to extract any nested exceptions of a special type (like, test framework "Ignore Test"), and throw them in a special manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Tests.ThrowsAccumulatedLoggerExceptions.Dispose">
            <summary>
            Reports all of the exceptions that have occurred within the listener's life.
            Detaches from the logger.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Graphs.BiparititeGraphAlgorithms.MaximalMatching``2(JetBrains.Util.Graphs.IBipartiteGraph{``0,``1})">
            <summary>
            Finds maximal matching in bipartite graph using Hopcroft Karp algorithm
            http://en.wikipedia.org/wiki/Hopcroft-Karp_algorithm
            </summary>
        </member>
        <member name="M:JetBrains.Util.Graph.DirectedGraph`1.AddDependency(`0,`0)">
            <summary>
            Sets a directed edge between nodes. Does not fail if it's already set.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Graph.DirectedGraph`1.Nodes">
            <summary>
            Nodes as a collection.
            Allows effective <see cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/> lookup, and adding/removing nodes consistently with dependencies.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Graph.DirectedGraphVirtualized`1">
            <summary>
            <para>An implementation of the <see cref="T:JetBrains.Util.Graph.IDirectedGraph`1" /> interface which does not store all of the dependencies and items inside, but delegates to lookup methods </para>
            instead.
            <para>Useful if you got a projection from some other data structure which is better to calculate on demand instead of loading all of the relations into the structure beforehand.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate`1">
            <summary>
            A callback that we're passing a node on the way down (before processing its children).
            </summary>
            <param name="node">The current node.</param>
            <param name="visit">Whether we're visiting the node for the first time.</param>
            <param name="path">The current path how we got here, starting with the initial node of the search. The same list is reused for each call, take care!</param>
            <returns>How to go further.</returns>
        </member>
        <member name="M:JetBrains.Util.Graph.GraphAlgorithms.DepthFirstSearch``1(JetBrains.Util.Graph.IDirectedGraph{``0},``0,JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate{``0},System.Action{``0},System.Action{``0})">
            <summary>
            A non-recursive DSF version suitable for bigger sets.
            Goes in the Outgoing direction. If you want the other direction, call the implementing utility function manually.
            </summary>
            <typeparam name="TNode"></typeparam>
            <param name="graph"></param>
            <param name="start">Initial point.</param>
            <param name="FEnteringOnWayDown">Will be called each time we're about to enter a node, for the first time or not. Allows to control whether to go further, inspect the path, etc.</param>
            <param name="FPassingOnWayDownSimple">Called when we're passing the node on the way down, before doing its children. By default, won't enter the same node for the second time (unless told to by <paramref name="FEnteringOnWayDown" />).</param>
            <param name="FPassingOnWayUp">Called when we're passing the node on the way up, after doing its children.</param>
        </member>
        <member name="M:JetBrains.Util.Graph.GraphAlgorithms.DepthFirstSearch``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``0}},JetBrains.Util.Graph.GraphAlgorithms.PassingOnWayDownDelegate{``0},System.Action{``0},System.Action{``0})">
            <summary>
            A non-recursive DSF version suitable for bigger sets.
            Operates on abstract graph structures.
            </summary>
            <typeparam name="TNode"></typeparam>
            <param name="rootcollection">Initial nodes.</param>
            <param name="FGetLinkedNodes">Walks the directional graph by getting the nodes linked to the given one.</param>
            <param name="FEnteringOnWayDown">Will be called each time we're about to enter a node, for the first time or not. Allows to control whether to go further, inspect the path, etc.</param>
            <param name="FPassingOnWayDownSimple">Called when we're passing the node on the way down, before doing its children. By default, won't enter the same node for the second time (unless told to by <paramref name="FEnteringOnWayDown" />).</param>
            <param name="FPassingOnWayUp">Called when we're passing the node on the way up, after doing its children.</param>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoDownIfFirstTime">
            <summary>
            The default behavior for non-looping DFS: walk children if they haven't been visited yet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoDown">
            <summary>
            Proceed walking the node children, even if the node has already been visited. Take care of looping infinitely, but might be useful if you want to see all the paths for reaching the node.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.GoUp">
            <summary>
            Don't go into node's children at all, go up instead. The passing-on-way-up callback won't be called in this case.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Graph.GraphAlgorithms.WalkInstruction.Abort">
            <summary>
            Don't walk anything else, exit immediately.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.ReadOnlySpan{System.Byte},System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86``1(System.ReadOnlySpan{``0},System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.Byte*,System.UInt32,System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.Byte*,System.UInt32,JetBrains.Util.Maths.OWORD)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64(System.ReadOnlySpan{System.Byte},System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64``1(System.ReadOnlySpan{``0},System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64(System.Byte*,System.UInt32,System.UInt32)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
            <remarks>
            Speed estimation data.
            AMD64 native process:
                 128bit hash x64 version  1x
                 128bit hash x86 version  0.5x
                 32bit  hash              0.5x
            AND64 WoW6432 process:
                 128bit hash x64 version  0.1x
                 128bit hash x86 version  0.3x
                 32bit  hash              0.5x
            If you have WoW as an option, would better use the x86 version.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x64(System.Byte*,System.UInt32,JetBrains.Util.Maths.OWORD)">
            <summary>
              <para>Murmur Hash v3, which is a public domain algorithm, a non-cryptographic hash function suitable for general hash-based lookup.</para>
              <para>The x86 and x64 versions do _not_ produce the same results, as the algorithms are optimized for their respective platforms. You can still compile and run any of them on any platform, but your performance with the non-native version will be less than optimal.</para>
            </summary>
            <remarks>
            Speed estimation data.
            AMD64 native process:
                 128bit hash x64 version  1x
                 128bit hash x86 version  0.5x
                 32bit  hash              0.5x
            AND64 WoW6432 process:
                 128bit hash x64 version  0.1x
                 128bit hash x86 version  0.3x
                 32bit  hash              0.5x
            If you have WoW as an option, would better use the x86 version.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_128_x86(System.String)">
            <summary>
            Murmur Hash, which is a public domain algorithm. String helper.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3(System.String)">
            <summary>
            Murmur Hash, which is a public domain algorithm. String helper.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3_Parts(System.Byte*,System.Int32,System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash, which is a public domain algorithm.
            This version works on a buffer split into two parts.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.Hashes.MurmurHash3(System.Byte*,System.Int32,System.UInt32)">
            <summary>
            Murmur Hash v3, which is a public domain algorithm.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Maths.OWORD">
            <summary>
            Wrapper for octawords  unsigned 128 bit integers.
            It has 128 bits, or 16 bytes, or 8 WORDs (hence octaword), or 4 DWORDs (four double words), or 2 QWORDs (two quad words), or 1 OWORD (octaword).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Maths.OWORD.ToString">
            <summary>
            Makes a fully padded hexadecimal representation of this octaword.
            </summary>
        </member>
        <member name="T:JetBrains.Util.PersistentMap.UnsafeStructAsIsMarshaller`1">
            <summary>
            Does not work with generic types! 
            This class is example of work with raw bytes.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Util.PersistentMap.UnsafePairMarshaller`2">
            <summary>
            Marshalls generic pairs
            </summary>
            <typeparam name="T1">Type of the first element of the pair</typeparam><typeparam name="T2">Type of the second element of the pair</typeparam>
        </member>
        <member name="T:JetBrains.Util.PersistentMap.ComparableStringMarshaller">
            <summary>
            Uses zero-terminated string to make binary search possible on strings
            </summary>
        </member>
        <member name="F:JetBrains.Util.PersistentMap.ComparableStringMarshaller.IgnoreCase">
            <summary>
            By using this marshaller you agree to remove casing from your string during marshalling.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadBlittable``1(JetBrains.Serialization.UnsafeReader)">
            <summary>
            Reading a blittable struct from memory bytes of the unsafe reader.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadIfNull(JetBrains.Serialization.UnsafeReader)">
            <summary>
            Reads a boolean flag if the value written by <see cref="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteIfNull``1(JetBrains.Serialization.UnsafeWriter,``0)" /> were NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadManyBlittable``1(JetBrains.Serialization.UnsafeReader)">
            <summary>
            Reading an array of blittable structs from memory bytes of the unsafe reader, preceded with their number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadRd``1(JetBrains.Serialization.UnsafeReader,JetBrains.Rd.SerializationCtx)">
            <summary>
            Deserializes a value of type <typeparamref name="TValue" /> or of a derived type (polymorphic serialization) using the set of known serializers registered with the Rd's <see cref="T:JetBrains.Rd.ISerializers" /> of your context.
            </summary>
            <typeparam name="TValue">Base type of the value.</typeparam>
            <param name="this">Reader.</param>
            <param name="ctx">The serialization context in which you are operating. When working in Rd world, you can declare serializer method overloads which take this as a parameter.</param>
            <returns>A value deserialized out of the byte stream.</returns>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteBlittable``1(JetBrains.Serialization.UnsafeWriter,``0)">
            <summary>
            Writing a blittable struct to memory bytes of the unsafe writer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteCollection``2(JetBrains.Serialization.UnsafeWriter,System.Collections.Generic.IReadOnlyCollection{``0},``1,JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteDelegate{``0,``1})">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteIfNull``1(JetBrains.Serialization.UnsafeWriter,``0)">
            <summary>
            Writes a boolean flag if the value is a NULL reference (of a reference type and equal to NULL). Value types are never treated as NULL, even when set to all NULLs.
            </summary>
            <returns>Whether we wrote the value to be NULL and would read it as such later.</returns>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteManyBlittable``1(JetBrains.Serialization.UnsafeWriter,System.ReadOnlySpan{``0})">
            <summary>
            Writing an array of blittable structs to memory bytes of the unsafe writer, preceded with their number.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteRd``1(JetBrains.Serialization.UnsafeWriter,JetBrains.Rd.SerializationCtx,``0)">
            <summary>
            Serializes a value of type <typeparamref name="TValue" /> or of a derived type (polymorphic serialization) using the set of known serializers registered with the Rd's <see cref="T:JetBrains.Rd.ISerializers" /> of your context.
            </summary>
            <typeparam name="TValue">Base type of the value.</typeparam>
            <param name="this">Writer.</param>
            <param name="ctx">The serialization context in which you are operating. When working in Rd world, you can declare serializer method overloads which take this as a parameter.</param>
            <param name="value">Value to be serialized into bytes.</param>
        </member>
        <member name="F:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ProtocolGlobalInternRootKey">
            <summary>
            Magic value to attach to the global ever-existing intern root. Hardcoded in Rd/Protocol as private const.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            A more deterministic version of <see cref="M:JetBrains.Rd.SerializationCtx.ReadInterned``1(JetBrains.Serialization.UnsafeReader,System.String,JetBrains.Rd.CtxReadDelegate{``0})"/>/<see cref="M:JetBrains.Rd.SerializationCtx.WriteInterned``1(JetBrains.Serialization.UnsafeWriter,``0,System.String,JetBrains.Rd.CtxWriteDelegate{``0})"/>.
            * Would not silently revert to writing full body values in case smth didn't match, eg an intern root is not registered at that level. Make this an assertion for now, as we need intern to work reliably. Also, bind to the protocol-global instance, which avoids registering it manually. Cons: uses the default poly serializer.
            * Does not skip interning transparently on "invalid id", also an assertion.
            * Does not take manual serializers which would only be used in part of the scenarios. This one only uses default serializers registered with the global protocol root (polymorphic). 
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.WriteForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,``0)">
            <inheritdoc cref="M:JetBrains.Util.PersistentMap.UnsafeReaderWriterEx.ReadForceInterned``1(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)"/>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriterEx.Alloc2(JetBrains.Serialization.UnsafeWriter,System.UInt32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Do not use the <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> value obtained before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" /> to address the space because doing this preallocation might realloc the whole memory area.
            Use the returned buffer to access the memory correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriterEx.Alloc2``1(JetBrains.Serialization.UnsafeWriter)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Do not use the <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> value obtained before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" /> to address the space because doing this preallocation might realloc the whole memory area.
            Use the returned buffer to access the memory correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriterEx.AllocMany``1(JetBrains.Serialization.UnsafeWriter,System.UInt32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            Do not use the <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> value obtained before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" /> to address the space because doing this preallocation might realloc the whole memory area.
            Use the returned buffer to access the memory correctly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.PersistentMap.UnsafeWriterEx.AsSpan(JetBrains.Serialization.UnsafeWriter.Cookie)">
            <summary>
            Gets access to all the data currently written to the unsafe cookie.
            NOTE that any new writes could potentially invalidate this range by reallocating.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AppDomainAssembliesResolver.AssemblyByIdentity">
            <summary>
            Cache assemblies by their shortname and Major.Minor version.
            3rd/4th version numbers are insignificant in our standard versioning policy (they're binary compatible, and there shouldn't be running more than one at a time).
            Major.Minor should probably be respected in case we might want to run more than one product with quite different versions of some assembly  resolver shouldn't mix them up.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AppDomainAssembliesResolver.Install(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Installs the current resolver instance into the appdomain's <see cref="E:System.AppDomain.AssemblyResolve" /> event.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="T:JetBrains.Util.Reflection.AssemblyNameInfoParseException">
            <summary>
            <para>A distinct exception type for assembly name parse errors.</para>
            <para>Catch <see cref="T:System.ArgumentException"/> to trap all of the <see cref="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)"/> cases.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.AssemblyTextualIdentityParser">
            <summary>
            Expected format, as defined in coreclr: <c>simple name (, attr = value)*</c>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeString(System.String,System.Text.StringBuilder)">
            <summary>
            Escapes a string against the textual identity parser rules, so that it were lexed back as a string if encountered as the simple name, attribute or a value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(System.String,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses an assembly textual identity string (aka FullName) from a runtime string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses an assembly textual identity string (aka FullName) from a string source, which can be a substring or a native memory range or whatever else. Only fixes the string once, so it's OK to do encoding translation on-the-fly. Resulting substrings will be subranges into this same string source.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parse(System.Char*,System.UInt32,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks,JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Parsed@)">
            <summary>
            Parses the fixed string.
            Wrap into a native string source if want to call from outside.
            This method is kept for perf to do a fixed() operator on the runtime string rather than going thru string source's Fixed operation.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.TrimTrailingWhitespace(System.Char*,System.Char*,System.Boolean)">
            <summary>
            Trailing wsp handling (wsp lexes into a string, but not if it's at the end of an unquoted string).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.EscapeMode.ClrDefault">
            <summary>
            Gets the default value used by the CLR version of the parser (as in <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo" />).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.ParserState.BeforeOptionalAttr">
            <summary>
            Before either an attribute value (,x=y), or EOF.
            After either the simple name or another attribute value.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.PreprocessorCharHandling.BacktrackInput">
            <summary>
            Backtracking: use the same char on the next step.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.AllowUnterminatedQuotedStrings">
            <summary>
            EOF terminates an unterminated quoted string with CLR AssemblyName std parsing. Turns on this mode.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.AllowShorterVersionNumbers">
            <summary>
            If a version number has less than four components, subst missing ones with FFFFh.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.AssemblyTextualIdentityParser.Quirks.ClrDefault">
            <summary>
            Gets the default value which provides better compatibility with the CLR version of the parser (as in <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo" />).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CallStackAnnotation">
            <summary>
              <para>This is a tool to add arbitrary text to your exception stack traces by inserting an artificial stack frame whose type/method names are set to arbitrary text.</para>
              <para>When needed: if you're reusing a lot of code and all the stacks look anonymous and alike, so adding the names of the entities is desired.</para>
              <para>How it works: emits a method with custom name; if you want to insert an annotation frame before calling function X, then you call that method instead, give it a delegate for X, and that method calls X from within.</para>
              <para>Impact: there's cost on emitting the dynamic method, and then some small overhead on calling that method thru a delegate and then your original function through a delegate as well (smth like two virtual calls, should be negligible unless very high perf code). The cost on emitting the method depends on how many unique names you want to use, mainly.</para>
              <para>Mitigating the impact: the current recommendation is to check your logger category for whether <see cref="F:JetBrains.Diagnostics.LoggingLevel.TRACE" /> level is enabled, and only use CSA if yes, otherwise call the target function directly; cache delegates obtained from <c>AnnotationWrapper</c> and for your target function; if your function has parameters, emit a delegate with parameters rather than create an <see cref="T:System.Action" /> closure on every call (see below).</para>
              <para>How to use: the simplest way is to make a parameterless <see cref="T:System.Action" /> closure for your function <c>X</c>, named <c>fX</c>, then calling it looks like:</para>
              <para><code>CallStackAnnotation.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper(fX);</code></para>
              <para>The <c>AnnotationWrapper</c> is cached on CSA side, but for the best perf you can cache it in a field.</para>
              <para>This is all if your target function <c>X</c> is void->void, but if it has parameters or a return value then it's better not to create a closure on every call but emit the artificial method with parameters.</para>
              <para>For a function <c>F: int, string -> bool</c> to be annotated with a <c>OwnerName.ActivityName</c> stack frame it looks like:</para>
              <para><code>var fWrap = CallStackAnnotation.Param1&lt;int&gt;.Param2&lt;string&gt;.Returns&lt;bool&gt;.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper</code></para>
              <para>The unannotated and annotated calls would look like:</para>
              <para><code>bool flag = X(666, "Hello");
            bool flag = fWrap(X, 666, "Hello");</code></para>
              <para>The type of <c>X</c> here is <c>Func&lt;int, string, bool&gt;</c>, and <c>fWrap</c> is <c>Func&lt;Func&lt;int, string, bool&gt;, int, string, bool&gt;</c> (takes <c>X</c> as the first param).</para>
            </summary>
            <example><code>CallStackAnnotation.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper(fX);</code></example>
            <example><code>bool flag = CallStackAnnotation.Param1&lt;int&gt;.Param2&lt;string&gt;.Returns&lt;bool&gt;.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper(X, 666, "Hello")</code></example>
            <example><code>CallStackAnnotation.Param1&lt;int&gt;.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper</code></example>
            <example><code>CallStackAnnotation.Returns&lt;double&gt;.TypeNames["OwnerName"].MethodNames["ActivityName"].AnnotationWrapper</code></example>
        </member>
        <member name="F:JetBrains.Util.Reflection.CallStackAnnotation.myLockStopTheWorld">
            <summary>
            In .NET Core runtime v7 (and, to a lesser extent, in .NET Framework runtime v4.8) there is a bug that would crash the runtime natively (memory corruption etc) if we access dynamic assembly emit from multiple threads at once.
            Add a pessimistic stop-the-world lock to try work around this issue.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Reflection.CallStackAnnotation.TypeNames">
            <summary>
            An entry point for annotating void-void functions (which fit an <see cref="T:System.Action" />, see docs on class for examples.
            For functions with parameters, choose <see cref="T:JetBrains.Util.Reflection.CallStackAnnotation.Param1`1" /> and further.
            For function with return values, choose <see cref="T:JetBrains.Util.Reflection.CallStackAnnotation.Returns`1" /> if no parameters, or take parameters as <see cref="T:JetBrains.Util.Reflection.CallStackAnnotation.Param1`1" /> etc. first and then <see cref="T:JetBrains.Util.Reflection.CallStackAnnotation.Returns`1" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.EmitDynamicAssemblyForGenericWrapper(System.ValueTuple{System.String,System.String},System.Boolean,System.Int32)">
            <summary>
            Makes a fully generic dynamic method which takes a lambda and all params for calling it, and calls it.
            Even though we always know the concrete types when emitting and would not have had to mess with generics and specialization, generics allow to bypass the access checks: we cannot emit calls involving private types from other assemblies, but we can specialize generics to them.
            The LCG emit has flags to bypass access checks during JIT, but LCG frames aren't rendered as method names in certain debuggers/profilers, we'd have to stick to a dynamic assembly, which has to abide by access rules.
            As a bonus, we can cache emitted stuff by just the number of parameters and name, but name makes it almost unique anyway.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.LdargMany(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>
            Loads the given number of arguments on the stack, starting with #0 (this on an instance method).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CallStackAnnotation.Param1`1">
            <summary>
            An entry point for annotating functions with parameters, see docs on class for examples.
            Go into Params* nested classes to the number of your parameters, giving their types.
            When done, either take <see cref="F:JetBrains.Util.Reflection.CallStackAnnotation.Param1`1.TypeNames" /> to pick the names for your frame if no return value, or specify <see cref="T:JetBrains.Util.Reflection.CallStackAnnotation.Param1`1.Returns`1" /> after the last parameter and then do the names.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CallStackAnnotation.Returns`1">
            <summary>
            An entry point for annotating functions without parameters but with a return type, see docs on class for examples.
            Specify the return type in generic parameter and then call <see cref="F:JetBrains.Util.Reflection.CallStackAnnotation.Returns`1.TypeNames" /> to pick the text for your stack frame.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CallStackAnnotation.Untyped">
            <summary>
            Raw API with an untyped delegate when you have Type's but cannot use them for specializing generics.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CallStackAnnotation.Untyped.AnnotateDelegate(JetBrains.Util.Reflection.CallStackAnnotation.Untyped.DelegateKey@)">
            <summary>
            Emits a wrapper with a user-chosen name to appear in the call stacks at runtime when the wrapped functionality is called.
            This method can make an untyped delegate from a list of parameter types and a return type. If you can write the delegate type and can use types as generic actual parameters, use the specific APIs, see doc on class.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.CodeDomAssemblyReferences">
            <summary>
            A helper class for tracking which assembly references might be involved within a CodeDOM session.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.CodeDomEx.MakeTypeReference(System.String,JetBrains.Util.Reflection.CodeDomAssemblyReferences,JetBrains.Metadata.Utils.AssemblyNameInfo[])">
            <summary>
            Correctly creates the code type reference.
            Use other overloads whenever possible, resort to this only if the type cannot be represented as <see cref="T:System.Type" /> or <c>PartCatalogType</c>.
            </summary>
            <param name="sFullyQualifiedName">FQN of the type (no assembly qualification).</param>
            <param name="refs">Tracks assembly references usage.</param>
            <param name="referencedassembly">If you know the originating assembly, track its usage.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Reflection.CodeDomEx.WriteCodeToFile(System.CodeDom.CodeCompileUnit,JetBrains.Util.FileSystemPath)">
            <summary>
            Writes code in any case, even if it is the same (touches the file date, used in normal build that looks at input/output dates).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.InterfaceImplementation.Ldarg(System.Reflection.Emit.ILGenerator,System.Int32,System.Boolean[])">
            <summary>
            Loags the given number of arguments on the stack, starting with #0 (this on an instance method).
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.SimpleTypeConverter`1">
            <summary>
            Implements the trivial Type Converter.
            For convertion to string: uses the class' <see cref="M:System.Object.ToString" /> method. Expected to be overridden and to provide the desired formatting.
            For conversion from string: assumes there is a constructor which takes one string parameter. The constructor is expected to do the appropriate parsing. Might be public or non-public.
            These two are expected to roundtrip and to be culture-independent.
            </summary>
            <typeparam name="T">The type which this converter handles. Unfortunately, the converter API does not let it know the type we have to parse the string into, it's assumed that the class is statically fit to serving some specific type.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Reflection.SimpleValueSerializer`1">
            <summary>
            Implements the trivial Value Serializer.
            For convertion to string: uses the class' <see cref="M:System.Object.ToString" /> method. Expected to be overridden and to provide the desired formatting.
            For conversion from string: assumes there is a constructor which takes one string parameter. The constructor is expected to do the appropriate parsing. Might be public or non-public.
            These two are expected to roundtrip and to be culture-independent.
            </summary>
            <typeparam name="T">The type which this converter handles. Unfortunately, the converter API does not let it know the type we have to parse the string into, it's assumed that the class is statically fit to serving some specific type.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Reflection.TypeConverterBase`1">
            <summary>
            A base class for quickly implementing a <see cref="T:System.ComponentModel.TypeConverter" /> for some class <typeparamref name="T" /> (attached thru <see cref="T:System.ComponentModel.TypeConverterAttribute" />).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,`0,System.String},System.Func{System.ComponentModel.ITypeDescriptorContext,System.Globalization.CultureInfo,System.String,`0})">
            <summary>
            An overload which gets the full <see cref="T:System.ComponentModel.ITypeDescriptorContext" /> into the methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{System.Globalization.CultureInfo,`0,JetBrains.Util.ILogger,System.String},System.Func{System.Globalization.CultureInfo,System.String,JetBrains.Util.ILogger,`0})">
            <summary>
            An overload which supplies the logger into the methods, either the <see cref="T:JetBrains.Util.ILogger" /> obtained from the <see cref="T:System.ComponentModel.ITypeDescriptorContext" />, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger" /> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.TypeConverterBase`1.#ctor(System.Func{`0,System.String},System.Func{System.String,`0})">
            <summary>
            The simplest overload which fits the most cases.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Reflection.ValueSerializerBase`1">
            <summary>
            A base class for quickly implementing a <see cref="T:System.Windows.Markup.ValueSerializer" /> for some class <typeparamref name="T" /> (attached thru <see cref="T:System.Windows.Markup.ValueSerializerAttribute" />).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{System.Windows.Markup.IValueSerializerContext,`0,System.String},System.Func{System.Windows.Markup.IValueSerializerContext,System.String,`0})">
            <summary>
            An overload which gets the full <see cref="T:System.Windows.Markup.IValueSerializerContext" /> into the methods.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{`0,JetBrains.Util.ILogger,System.String},System.Func{System.String,JetBrains.Util.ILogger,`0})">
            <summary>
            An overload which supplies the logger into the methods, either the <see cref="T:JetBrains.Util.ILogger" /> obtained from the <see cref="T:System.Windows.Markup.IValueSerializerContext" />, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger" /> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Reflection.ValueSerializerBase`1.#ctor(System.Func{`0,System.String},System.Func{System.String,`0})">
            <summary>
            The simplest overload which fits the most cases.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.AhoCorasickStateMachine">
            <summary>
            Represents a state machine built using the Aho-Corasick algorithm.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.AhoCorasickStateMachine.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Build a state machine on the given <paramref name="patterns"/> using the Aho-Corasick algorithm.
            </summary>
            <param name="patterns">List of <c>unique</c> patterns.</param>
            <exception cref="T:System.ArgumentException">Thrown when at least two patterns are identical.</exception>
        </member>
        <member name="P:JetBrains.Util.Text.AhoCorasickStateMachine.Patterns">
            <summary>
            Returns patterns used to build this state machine.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.AhoCorasickStateMachine.CurrentPatternsIndices">
            <summary>
            <para>Returns indices of patterns accepted now.</para>
            <para>Indexing corresponds to the input order and starts with 0.</para>
            <para>The patterns are sorted by length.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.AhoCorasickStateMachine.CurrentPatterns">
            <summary>
            <para>Returns patterns accepted now.</para>
            <para>The patterns are sorted by length.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.AhoCorasickStateMachine.Any">
            <summary>
            Checks if there are any patterns accepted now.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.AhoCorasickStateMachine.Advance(System.Char)">
            <summary>
            <para>Executes a transition to the next state by <paramref name="symbol"/>.</para>
            <para>Returns if there are any patterns accepted now for the next state.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.AhoCorasickStateMachine.Match(System.String)">
            <summary>
            Searches an input string for a any pattern, on which this machine were build. 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.AhoCorasickStateMachine.Reset">
            <summary>
            Executes a transition to the initial state of this machine.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.AhoCorasickStateMachine.TrieNode">
            <summary>
            It is an intermediate structure needed only to build a machine.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.AhoCorasickStateMachine.State">
            <summary>
            It is the main structure. Represents all the information about one state in a machine.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.EncodingUtil.CP1251">
            <summary>
            Cyrillic ANSI encoding, see https://en.wikipedia.org/wiki/Windows-1251
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.EncodingUtil.CP1252">
            <summary>
            Windows default ANSI encoding, see https://en.wikipedia.org/wiki/Windows-1252
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.LineEnding">
            <summary>
              <para>
                Supported line endings. All line endings supported by Unicode, and, by consequence, by Visual Studio Text Buffer implementation.
                Sync with Visual Studio is required to guarantee that we lineate the documents in the same manner, and this is essential for
                switching between disk-backed and VS ROT backed document implementations correctly.
              </para>
              <para>
                The implementation has been retrieved from the classical VS Text Buffer implementation of the pre-MEF age, actually.
              </para>
              <para>
                Enum member values are little-endian representations of the line ending chars in UTF-16LE with zero chars skipped,
                which gives one-char (high zero), two-char (for CRLF) and zero-char (for the very last line in file) endings.
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.LF">
            <summary>
            LF Line Feed. (/n)
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.CR">
            <summary>
            CR Carriage Return. (/r)
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.CRLF">
            <summary>
            CR Carriage Return. (/r/n)
            LF Line Feed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.LS">
            <summary>
            LS Line Separator.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.PS">
            <summary>
            PS Paragraph Separator.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.VT">
            <summary>
            VT Vertical Tabulation.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.FF">
            <summary>
            FF Form Feed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.NEL">
            <summary>
            NEL New Line.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEnding.Eof">
            <summary>
            An implicit line ending at the end of the file without an explicit line ending.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.LineEndings">
            <summary>
              <para>Utilities for handling line endings in text files. Also used by the <c>Document</c> to break the document text into the lines.</para>
              <para>If you have a document already, use its ext methods to learn line ending stats for it, like what's the most popular line ending in the current document, or just the first line ending.</para>
              <para>This class has the same functions for the case when you have no document object but only its text.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.mySmallBuffer">
            <summary>
            Lazy one-line buffer for fetching the first line ending quickly.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndings(JetBrains.Util.TextRange,JetBrains.Text.IBuffer)">
            <summary>
            Rebuilds a part of the index (or the whole index).
            </summary>
            <param name="rangeWholeLines">The part to rebuild. Range ends must be at start offsets of some lines (or end-offset-with-line-break, which is the same).</param>
            <param name="buffer"></param>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.AverageLineLength">
            <summary>
            Assumed average line length, to estimate the new lines buffer size.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetFirstLineEnding(JetBrains.Text.IBuffer)">
            <summary>
            Gets the very first line ending of the document.
            </summary>
            <param name="buffer"></param>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetMostPopularLineEnding(JetBrains.Text.IBuffer)">
            <summary>
              <para>Scans the line endings of the document, returns the most popular one.</para>
              <para>NOTE: if you got a document object, call the overload on the document for better perf.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.GetMostPopularLineEnding(System.Collections.Generic.List{JetBrains.Util.Text.LineEndings.LineSegment},JetBrains.Text.IBuffer)">
            <summary>
              <para>Scans the line endings of the document, returns the most popular one.</para>
              <para>NOTE: if you got a document object, call the overload on the document for better perf.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsCore(JetBrains.Util.TextRange,JetBrains.Text.IBuffer,JetBrains.Util.Text.LineEndings.Flags,System.Nullable{JetBrains.Util.Text.LineEndings.DetectLineEndingsContext})">
            <summary>
            Rebuilds a part of the index (or the whole index).
            </summary>
            <param name="range">The part to scan, see flags for special end handling.</param>
            <param name="buffer"></param>
            <param name="flags"></param>
            <param name="mctx">Optional previous context. Allows to parse incrementally, must be the result from the previous contiguous range. The new context is returned.</param>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.UnifyLineSeparators(JetBrains.Text.IBuffer,JetBrains.Util.Text.LineEnding)">
            <summary>
            Replaces all line separators in a buffer to a specified one
            Implementation was copied from IDEA
            </summary>
        </member>
        <member name="T:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext">
            <summary>
            Replaces the former lambda function, collects the context needed for the common <see cref="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.commitLine(System.Int32)" /> function (which were a lambda).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.news">
            <summary>
            Newly-collected line segments.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.offsCurrEndNoLB">
            <summary>
            Line end-no-line-break for the line we're currently collecting, -1 if not encountered yet.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.offsCurrStart">
            <summary>
            Line start for the line we're currently collecting.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.DetectLineEndingsContext.commitLine(System.Int32)">
            <summary>
             Adds a new line when we detect a complete line break char
            </summary>
            <param name="offsWithLB">The new end with line break.</param>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.LineEndsAtRangeEnd">
            <summary>
            The range ends at a whole line, so the line ending should be committed even if possibly a leading char (like \r). If also <see cref="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd" />, then it should be committed even without any line ending. If not <see cref="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd" /> and there's no line ending char at the end of the range, then it is an error.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.DocumentEndsAtBufferEnd">
            <summary>
            The buffer end is the document end, so if the range goes up to the buffer end, it should be treated as an EOF and a no-ending line should be committed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.Flags.FirstLineOnly">
            <summary>
            Break after committing the very first line.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Text.LineEndings.LineSegment.myPackedLengths">
            <summary>
            Keeps the line lenghts: lower 30 bits are the full line segment length, including the line break chars; the higher two bits are the line ending length, of whose values the valid ones are 0, 1, 2.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.EndOffsetNoLineBreak">
            <summary>
            Index after the last non-line-break character of the line. This denotes the line length.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.EndOffsetWithLineBreak">
            <summary>
            Index after the last character of the line, including any line break characters it has.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.ExtentNoLineBreak">
            <summary>
            Gets the line extent, not including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.ExtentWithLineBreak">
            <summary>
            Gets the line extent, including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.LengthNoLineBreak">
            <summary>
            Gets the number of non-line-break characters in the line.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.LengthWithLineBreak">
            <summary>
            Gets the number of characters in the line, including the line break characters.
            </summary>
        </member>
        <member name="P:JetBrains.Util.Text.LineEndings.LineSegment.StartOffset">
            <summary>
            Index of the first character in the line.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Text.LineEndings.LineSegment.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Util.Text.ThinArrayBuffer.AssertOffsetAndLength(System.Int32,System.Int32)">
            <summary>
            Assertion method to avoid creating closure objects when no exceptions are thrown
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:JetBrains.Util.TextRange">
            <summary>
            Represents a range in a plaintext document.
            </summary>
        </member>
        <member name="F:JetBrains.Util.TextRange.InvalidRange">
            <summary>
            Should be replaced with <see cref="T:System.Nullable`1"/> of <see cref="T:JetBrains.Util.TextRange"/> wherever possible.
            Avoid using in new code.
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.StartOffset">
            <summary>
            <para>The first offset (character position) of the range, inclusive.</para>
            <para>A character at this index is included with the range.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.EndOffset">
            <summary>
            <para>The last offset (character position) of the range, non-inclusive.</para>
            <para>A character at this index is not included with the range and goes right after the range end.</para>
            <para>An end offset could point at the end of the document, in which case there's no character at this position.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.Length">
            <summary>
            <para>The number of characters in the text range.</para>
            <para>As the end offset is non-inclusive, this is equal to <see cref="P:JetBrains.Util.TextRange.EndOffset"/> <c></c> <see cref="P:JetBrains.Util.TextRange.StartOffset"/>.</para>
            <para>Returns 0 for invalid range.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsEmpty">
            <summary>
            <para>Whether the range is empty.</para>
            <para>The <see cref="P:JetBrains.Util.TextRange.Length"/> of an empty range is zero, and its <see cref="P:JetBrains.Util.TextRange.StartOffset"/> is the same as its <see cref="P:JetBrains.Util.TextRange.EndOffset"/>.</para>
            <para>Returns 'true' for invalid range.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromLength(System.Int32,System.Int32)">
            <summary>
            Creates a new range from offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromLength(System.Int32)">
            <summary>
            Creates a new range from zero offset and length, rather than from start + end offsets, as the <c>.ctor</c> would do.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.FromUnorderedOffsets(System.Int32,System.Int32)">
            <summary>
            <para>Creates a range from two unordered offsets, i.e. when it's not known which of the offsets is the start and which one is the end.</para>
            <para>The resultant range is guaranteed to be normalized.</para>
            <para>DO NOT USE unless the source of your offset is unordered by its nature (eg if you select text with shift+left the offsets of
            the selection range will be inverted, so they're sometimes out of order by design). Usually you should know which offset is start
            and which is end, and failure to do so might indicate an error in preceding code.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.GetMinOffset">
            <summary>
            Gets the <see cref="P:JetBrains.Util.TextRange.StartOffset"/> or <see cref="P:JetBrains.Util.TextRange.EndOffset"/>, whichever is smaller.
            Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.GetMaxOffset">
            <summary>
            Gets the <see cref="P:JetBrains.Util.TextRange.StartOffset"/> or <see cref="P:JetBrains.Util.TextRange.EndOffset"/>, whichever is greater.
            Use for consistent processing of potentially non-normalized ranges.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.ContainedIn(JetBrains.Util.TextRange@)">
            <summary>
            Gets whether this range is a subset of the <paramref name="textRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.StrictContainedIn(JetBrains.Util.TextRange@)">
            <summary>
            Gets whether this range is a proper subset of the <paramref name="textRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.Contains(System.Int32)">
            <summary>
            Determines whether the offset falls within the range, start and end offsets included.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.ContainsCharIndex(System.Int32)">
            <summary>
            <para>Checks whether the character at the <paramref name="charindex">given index</paramref> falls within this range.</para>
            <para>Unlike <see cref="M:JetBrains.Util.TextRange.Contains(System.Int32)"/>, the right offset is not included, because the range ends before the character with such an index.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.IntersectsOrContacts(JetBrains.Util.TextRange@)">
            <summary>
            Ranges [2,4) and [1,3) intersects.
            Ranges [2,4) and [1,2) contacts.
            See <see cref="M:JetBrains.Util.TextRange.StrictIntersects(JetBrains.Util.TextRange@)"/> for strict intersection
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.Intersect(JetBrains.Util.TextRange@)">
            <summary>
            Calculates range of intersection with given range
            </summary>
            <param name="textRange">range to intersect with</param>
            <returns>Range of intersection if current range intersects with given range.
            Empty range if current range contacts with given range (ie [1,2) and [2,3) ). Invalid range otherwise</returns>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsValid">
            <summary>
            Should be replaced with <see cref="T:System.Nullable`1"/> of <see cref="T:JetBrains.Util.TextRange"/> wherever possible.
            Avoid using in new code.
            Checks that the range is not the <see cref="F:JetBrains.Util.TextRange.InvalidRange"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.AssertValid">
            <summary>
            Asserts that this range is valid, which means that it's not an <see cref="F:JetBrains.Util.TextRange.InvalidRange"/>.
            Throws in ASSERT mode only.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.AssertNormalized">
            <summary>
            Asserts that this range is normalized, which means that its <see cref="P:JetBrains.Util.TextRange.Length"/> is nonnegative.
            Includes <see cref="M:JetBrains.Util.TextRange.AssertValid"/>.
            Throws in ASSERT mode only.
            </summary>
        </member>
        <member name="P:JetBrains.Util.TextRange.IsNormalized">
            <summary>
            Gets whether this range is normalized, which means that its <see cref="P:JetBrains.Util.TextRange.Length"/> is nonnegative.
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.Normalized">
            <summary>
            Returns a normalized version of the current text range (with a nonnegative length).
            </summary>
        </member>
        <member name="M:JetBrains.Util.TextRange.DistanceTo(System.Int32)">
            <summary>
            Returns the distance between the <paramref name="offset"/> and the nearest point that belongs to the range.
            </summary>
        </member>
        <member name="M:JetBrains.Util.AntPatternUtil.ParsePattern(System.String,System.Boolean,System.Boolean)">
            <summary>
            Checks some simple patterns and returns the fast result for them, bypassing JITting and running the full parser.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Utils.CapitalizationStyle.SentenceCase">
            <summary>
            Sentence case is where only first word and proper names in a phrase are capitalized
            </summary>
        </member>
        <member name="F:JetBrains.Util.Utils.CapitalizationStyle.TitleCase">
            <summary>
            Title Case is where each word in a phrase is capitalized, unless:
            1. It's an article, preposition or conjunction 4 letters or less, and it's not first or last words
            2. It's in quotes
            </summary>
        </member>
        <member name="M:JetBrains.Util.Utils.CapitalizationUtil.ForceCapitalization(System.String)">
            <summary>
            Changes capitalization style of given string to a default
            </summary>
        </member>
        <member name="M:JetBrains.Util.Utils.CapitalizationUtil.ForceCapitalization(System.String,JetBrains.Util.Utils.CapitalizationStyle)">
            <summary>
            Changes capitalization style of given string
            </summary>
        </member>
        <member name="M:JetBrains.Util.Utils.ClientIdUtils.ClientIdUtil.AssertClientIdConsistency(JetBrains.Rd.ClientId,System.String)">
            <summary>
            Asserts that given client id equals to the ClientId.Current
            </summary>
            <param name="clientId"></param>
            <param name="message"></param>
        </member>
        <member name="M:JetBrains.Util.Utils.ClientIdUtils.ClientIdUtil.BindToClientId(JetBrains.Lifetimes.Lifetime,JetBrains.Rd.ClientId)">
            <summary>
            Returns a lifetime which parent is given <paramref name="lifetime"/> but termination handlers are executed under specified <paramref name="clientId"/>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Utils.Misc.LifetimedStopwatch">
            <summary>
            Measures time when any of specified lifetimes is alive
            </summary>
        </member>
        <member name="M:JetBrains.Util.CharUtil.IsUriSafeChar(System.Char)">
            <summary>
            Chars which can be used in an URI without escaping.
            RFC 1738.4, but don't include escape chars like '+'
            </summary>
        </member>
        <member name="F:JetBrains.Util.CharUtil.UriSafeAsciiChars">
            <summary>
            Chars which can be used in an URI without escaping.
            RFC 1738.4, but don't include escape chars like '+'
            </summary>
        </member>
        <member name="M:JetBrains.Util.DotNetRidEx.AppendDotNetRid(System.Text.StringBuilder,JetBrains.Util.JetRid)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN NAMING FOR PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DotNetRidEx.GetDotNetRidName(JetBrains.Util.PlatformUtil.Platform)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN MICROSOFT PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DotNetRidEx.GetDotNetRidName(JetBrains.Util.PlatformUtil.LinuxLibC)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN MICROSOFT PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.DotNetRidEx.GetDotNetRidName(JetBrains.Util.JetArchitecture)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN MICROSOFT PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.EnvironmentVariablesUtil.TryFindInPath(System.String,JetBrains.Util.IInteractionContext)">
            <summary>
            Returns first file with given <see cref="!:fileName"/> in environment path
            </summary>
            <param name="fileName">File name to search</param>
            <returns>Path to first path found or <see cref="F:JetBrains.Util.FileSystemPath.Empty"/></returns>
        </member>
        <member name="M:JetBrains.Util.EnvironmentVariablesUtil.GetEnvironmentVariableWithRenameToPidSpecificName(System.String)">
            <summary>
            Returns the value of environment variable called <paramref name="sEnvironmentVariableName"/> and 
            adds PID-specific suffix to environment name in current process. On subsequent calls reads value from
            PID-specific name. 
            
            Motivation: this function prevents child processes from inheriting this environment variable by
            renaming it to process-specific name.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EnumEx">
            <summary>
            Extension methods for enums.
            </summary>
        </member>
        <member name="F:JetBrains.Util.EnumEx.myMapEnumValueToName">
            <summary>
            Caches the <see cref="M:JetBrains.Util.EnumEx.GetNamesOfValue(System.Type,System.Object)" /> results, as they use reflection and are thus very slow.
            Copy-on-write, non-locked (the values are expendable and can be regenerated in case of a race).
            Values sorted by Code.
            </summary>
        </member>
        <member name="M:JetBrains.Util.EnumEx.CoerceEnumValueSlow``1(``0)">
            <summary>
            If the enum value does not fall into the list of valid enum values, coerce it to be the first available enum value.
            This is silent, no exception is thrown.
            Note: this operation is slow, do not use often.
            </summary>
        </member>
        <member name="M:JetBrains.Util.EnumEx.GetNamesOfValue(System.Type,System.Object)">
            <summary>
            Gets all of the alternative names for the value of an enum.
            The value is not required to be coerced to the enum type, it must be of any integral type.
            </summary>
            <param name="type">Enum type.</param>
            <param name="value">Enum value to be named, must be of an integral type. Not an error if missing from the enum, an empty list will be returned.</param>
            <returns>The list of values, in order of appearance in the enum, empty if such an item is missing from the enum.</returns>
        </member>
        <member name="M:JetBrains.Util.EnumEx.UnboxQWord(System.Object)">
            <summary>
            Unboxes an object of an integral type (intXXX, bool, byte, char, enum, etc) as a QWORD integer value.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddDataUnsafe``1(``0,System.String,System.Object)">
            <summary>
              <para>Adds some data to be reported with the exception.</para>
              <para>Note that the data is added as an object by default, and is not committed to text until the exception is rendered with <see cref="T:JetBrains.Util.ExceptionRenderer" />. Use <see cref="M:JetBrains.Util.ExceptionEx.WithData``1(``0,System.String,System.Func{System.Object})" />/<see cref="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})" /> to safely convert to a string.</para>
              <para>This method is unsafe because when you're reporting an unexpected condition which caused an exception, any objects from which you're reading the additional state are often also inconsistent and might cause secondary exceptions, which would mask the original exception or even get out of the safe environment. The use of overload with a lambda suppresses all exceptions caused by the lambda code execution. Only use the unsafe method for primitive expressions or when you're totally sure.</para>
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">
              <para>Data entry name.</para>
              <para>Should be unique with the exception (implementation will modify it with a random suffix unless the value also matches).</para>
              <para>Special names containing <see cref="F:JetBrains.Util.ExceptionRenderer.HiddenExceptionDataNameSubstring" /> will not get into the rendered exception text.</para>
            </param>
            <param name="value">
              <para>Data entry value. For calculated values consider passing as a function for exception safety.</para>
              <para>This data is added AS IS (unlike <see cref="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})" />, which collapses/renders it to primitive data types), so take care.</para>
              <para>CONS: the object must be serialiable, otherwise the exception's implementation will refuse to take it.</para>
              <para>CONS: if you store a non-immutable object, it might mutate by the time the exception gets rendered.</para>
              <para>PROS: you can store a custom data structure which will be accessible right as that original type.</para>
            </param>
            <returns>The same exception object, for fluent usages.</returns>
            <remarks>This method is non-conditional and will add the data even when in production mode.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.WithData``1(``0,System.String,System.Func{System.Object})">
            <summary>
              <para>Adds custom data to be reported with the exception.</para>
              <para>The value gets immediately coerced to text (if a collection, then to an array of strings), no errors will be let out of the function or coercing.</para>
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">
              <para>Data entry name.</para>
              <para>Should be unique with the exception (implementation will modify it with a random suffix unless the value also matches).</para>
              <para>Special names containing <see cref="F:JetBrains.Util.ExceptionRenderer.HiddenExceptionDataNameSubstring" /> will not get into the rendered exception text.</para>
            </param>
            <param name="FValue">
              <para>Data entry value, passed as a functor so that any errors in its calculation or coercing to string were trapped and wouldn't prevent the exception from being reported.</para>
              <para>When you're reporting an unexpected condition which caused an exception, any objects from which you're reading the additional state are often also inconsistent and might cause secondary exceptions, which would mask the original exception or even get out of the safe environment.</para>
            </param>
            <returns>The same exception object, for fluent usages.</returns>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Func{System.Object})">
            <inheritdoc cref="M:JetBrains.Util.ExceptionEx.WithData``1(``0,System.String,System.Func{System.Object})"/>
            <remarks>This method is conditional and won't create or execute the lambda when in production mode.</remarks>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddData``1(``0,System.String,System.Object)">
            <summary>
            Adds some data to be reported with the exception.
            Note that the data is added as an object by default, and is not committed to text until the exception is.
            </summary>
            <param name="exception">The exception to enrich with data.</param>
            <param name="name">Data entry name. Must be unique with the exception.</param>
            <param name="value">Data entry value. For calculated values consider passing as a function for exception safety.</param>
            <returns>The same exception object, for fluent usages.</returns>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.AddDataIndirect``1(``0,System.Action{System.Exception})">
            <summary>
            Adds some data to be reported with the exception.
            Allows to call a data-adding function on some object that bears the exception context.
            The call is executed in a safe manner.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ExceptionEx.FlattenDataValue(System.Object)">
            <summary>
            Flattens the data value by converting all of the objects to their string representation. Understands some kinds of collections.
            This is needed for safe marshalling of exceptions containing data values across appdomain boundaries. Keeping original object values might fail unmarshalling their custom types.
            // TODO: maybe use some parts of exception renderer for walking the value trees
            </summary>
            <param name="oValue"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.GuidExtensions.CreateRdProtocolJavaUuidFromString(System.String)">
            <summary>
            <para>A simplified implementation only for use where you need to match <c>com.jetbrains.rider.utils.UUIDUtils#createFromString</c> (i.e. talk over RD protocol to Java/JVM).</para>
            <para>For regular string-derived GUIDs which conform to RFC 4122, use <c>Uuid::NewUuid</c>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Util.XmlWriterEx.WriterSettings">
            <summary>
            Default settings for an XML Writer.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.StartElem``1(``0,System.String)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.EndElem``1(``0)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteEndElement" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.Str``1(``0,System.String)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteString(System.String)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.Attr``1(``0,System.String,System.Object)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.AttrNs``1(``0,System.String,System.String,System.Object)">
            <summary>
            A fluent version of <see cref="M:System.Xml.XmlWriter.WriteAttributeString(System.String,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.CreateWriter(System.IO.Stream)">
            <summary>
            Creates a writer over the stream with readability-friendly settings (<see cref="P:JetBrains.Util.XmlWriterEx.WriterSettings"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.Element(System.Xml.XmlWriter,System.String,System.String)">
            <summary>
            Writes an element string, mostly as <see cref="T:System.Xml.XmlWriter"/>, but supports special notation for <paramref name="name"/> to also specify the namespace in the form <c>xmlns::localname</c>, eg <c>"urn:shemas-jetbrains-com:all-assemblies-xml::AllAssemblies"</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.InElement(System.Xml.XmlWriter,System.String,System.Action,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            Supports special notation for <paramref name="name"/> to also specify the namespace in the form <c>xmlns::localname</c>, eg <c>"urn:shemas-jetbrains-com:all-assemblies-xml::AllAssemblies"</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.InElementNs(System.Xml.XmlWriter,System.String,System.String,System.Action,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.PushElement(System.Xml.XmlWriter,System.String,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.PushElementNs(System.Xml.XmlWriter,System.String,System.String,System.Boolean)">
            <summary>
            <see cref="M:System.Xml.XmlWriter.WriteStartElement(System.String)"/> + <see cref="M:System.Xml.XmlWriter.WriteEndElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.WriteXml(System.IO.Stream,System.Action{System.Xml.XmlWriter})">
            <summary>
            Creates a writer over the stream with readability-friendly settings (<see cref="T:System.Xml.XmlUtf8RawTextWriterIndent"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlWriterEx.WriteXml(System.IO.Stream,System.Xml.XmlWriterSettings,System.Action{System.Xml.XmlWriter})">
            <summary>
            Creates a writer over the stream with user-supplied settings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeeded(System.Object)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeeded(System.Threading.Thread)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteIfNeededCore(System.Object)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteListIfNeeded(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded``1(JetBrains.Util.dataStructures.Sources.CollectionSource{``0})">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeeded``1(JetBrains.Util.dataStructures.FrugalLocalList{``0})">
            <summary>
            Writes the number of items and a comma-separated list of the items, sorted lexicographically, quoting each item if it contains spaces.
            Defers the string so that it could be used with logger tracing without any additional conditions.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteListIfNeededCore(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            The order of items is preserved.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.QuoteSetIfNeededCore(System.Collections.IEnumerable)">
            <summary>
            Writes the number of items and a comma-separated list of the items, quoting each item if it contains spaces.
            The items are sorted lexicographically.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Special.GeneralUtil.WithNotNull``1(``0,System.Action{``0})">
            <summary>
            Executes <paramref name="F"/> on the <paramref name="item"/>, if the <paramref name="item"/> is not <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.IteratorCatchEnumerator.Catch``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Use this method for exception isolation in iterators.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
        </member>
        <member name="T:JetBrains.Util.JetArchitecture">
            <summary>
              This is the copy <see cref="T:System.Runtime.InteropServices.Architecture" /> form
              https://github.com/dotnet/runtime/blob/main/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/Architecture.cs
            </summary>
        </member>
        <member name="F:JetBrains.Util.JetMsilableRid.NativeRid">
            <summary>
              null means MSIL !!!
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetRidEx.AppendJetRid(System.Text.StringBuilder,JetBrains.Util.JetRid,System.Char)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN NAMING FOR PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetRidEx.GetJetRidName(JetBrains.Util.PlatformUtil.Platform)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN NAMING FOR PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetRidEx.GetJetRidName(JetBrains.Util.PlatformUtil.LinuxLibC)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN NAMING FOR PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetRidEx.GetJetRidName(JetBrains.Util.JetArchitecture)">
            <summary>
              <b>DO NOT CHANGE THE RETURN VALUE BECAUSE IT IS USED IN NAMING FOR PUBLIC PACKAGES !!!</b>
            </summary>
        </member>
        <member name="M:JetBrains.Util.JetRidEx.GetSecondaryOrderedArchitecturesForOS(JetBrains.Util.JetRid)">
            <summary>
              <list type="number">
                <listheader>Sorted order:</listheader>
                <item>Natively executing architectures come first</item>
                <item>Architectures of greater bit depth at the beginning</item>
              </list>
            </summary>
            <param name="osRid">Operation system runtime identifier</param>
            <returns>The ordered list of available secondary architectures</returns>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.CopyMemoryPinvokeThreshold">
            <summary>
            If got at least this many bytes to copy, PInvoke for native impl. Otherwise, do a loop. PInvoke has a one-time call cost, but works more effectively than a loop.
            This value was researched with the <c>AssessPinvokeFallback</c> test.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.memcmp(System.Void*,System.UInt32,System.Void*,System.UInt32)">
            <summary>
            Compares two memory regions.
            </summary>
            <param name="p1">Pointer to the start of the region.</param>
            <param name="cb1">Length of the region, in bytes.</param>
            <param name="p2">Pointer to the start of the region.</param>
            <param name="cb2">Length of the region, in bytes.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.memmem(System.Byte*,System.Int32,System.Byte*,System.Int32)">
            <summary>
              Locate a byte substring.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.UsingBuffer">
            <summary>
            When you need a temporary buffer for operations, say, with an array, and the buffer would sit idle most of the time, so it's not reasonable to allocate a new one.
            Maintains a pool of buffers.
            Dispose of the returned value to free a buffer. If you fail to return a buffer, it would be garbage collected.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myBufferCacheTotalAllocatedApprox">
            <summary>
            Counts created buffers to check if <see cref="F:JetBrains.Util.Memory.MemoryUtil.myBufferCacheAllocationLimit" />. Approx, because we're not interlocking, and with high concurrency we'd be lacking behind, but not fatally, the idea is to stop making large buffers at some point, not track them precisely.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myBufferCacheAllocationLimit">
            <summary>
            How many buffers we create in 64-bit before we revert to smaller ones.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myBufferCache">
            <summary>
            Stores allocated buffers which are not in use at the moment.
            Why queue not stack: in 64-bit, we want to allocate large buffers, but some party might start actively leaking these buffers  this isn't fatal because we don't keep a reference and they would be garbage collected, but making more them would cause big memory traffic, then we start making smaller ones to get lighter on mem traffic. But with a stack, we'd then mostly use those new smaller buffers from the tail, and a queue would round-robin them at least.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.ByteBufferUnderLohSize">
            <summary>
            Specifies the maximum optimal size of the byte buffer, such as for copying, which still fits into the regular heaps and does not fall off to LOH.
            Borrowed from System.Stream v4, which also recommends to have it a multiple of 4096 (page size?.. dunno).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.ObjectGraphScanner.System#Collections#Generic#IEqualityComparer{System#Object}#Equals(System.Object,System.Object)">
            <summary>
            Determines whether the specified objects are equal.
            </summary>
            
            <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
            
            <param name="y">The second object to compare.</param>
            <param name="x">The first object to compare.</param>
            <exception cref="T:System.ArgumentException">x and y are of different types and neither one can handle comparisons with the other.</exception>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetAvailablePhysicalMemory">
            <summary>
            Gets rhe amount of physical memory currently available, in bytes.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetTotalVirtualMemory">
            <summary>
            Gets the total amount of virtual memory available to the process.
            Caches the value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.GetMachinePhysicalMemory">
            <summary>
            Gets the total physical memory on this machine.
            Caches the value.
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myTotalVirtualMemory">
            <summary>
            Caches the memory stats.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Memory.MemoryUtil.myMachinePhysicalMemory">
            <summary>
            Caches the memory stats.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Memory.MemoryUtil.FlushMemoryMappedFileDirtyPagesToDisk(JetBrains.Util.FileSystemPath)">
            <summary>
              Flush dirty regions of memory mapped file to disk.
            </summary>
            <param name="file"></param>
        </member>
        <member name="T:JetBrains.Util.Misc.JetProgress">
            <summary>
            Lightweight progress adaptor with minimum overhead. Used in optimized algorithms (e.g. Stable and Quick sorts).
            </summary>  
        </member>
        <member name="M:JetBrains.Util.Misc.JetProgress.#ctor(System.Action,System.Action)">
            <summary>
            Initializes JetProgress with given <paramref name="yield"/> and <paramref name="advance"/> actions.
            </summary>
            <remarks>
            The progress always normalized to range [0, 100], so <paramref name="advance"/> action is not called more than 100 times.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Misc.JetProgress.YieldAndAdvance(System.Int32)">
            <summary>
            Yields execution and advances progress onto 1 step.
            MUST NOT be called more than `stepsCount` times passed to <see cref="M:JetBrains.Util.Misc.JetProgress.Begin(System.Int64)"/> method.
            </summary>
            <remarks>
            NOTE. This method might be ineffective if `stepsCount` less than 100.
            In such case it calls underlying advance action multiple times.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.Misc.JetProgress.Yield(System.Int32)">
            <summary>
            Yields execution and provides safe interruption point. Should throw <see cref="T:System.OperationCanceledException"/> if operation cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Misc.ProcessWatchdog">
            <summary>
            Watchdog that automatically terminates current process if some other process exits.
            </summary>
        </member>
        <member name="T:JetBrains.Util.OnError">
            <summary>
            Option for the functions that serve as a <c>[NotNull]</c> or <c>[CanBeNull]</c> implementation, depending on the settings.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.#ctor(System.String,System.Action{System.Exception},System.Boolean)">
            <summary>
            Initializes with the handler to be called on <see cref="M:JetBrains.Util.OnError.Handle(System.Exception)"/>. Name is for reviewing the onerror kind in the debugger.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.Ignore">
            <summary>
            A handler that ignores failures.
            Provides for silent-<c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.LogException">
            <summary>
            A handler that reports the exceptions and then continues execution.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.LogExceptionSilently">
            <summary>
            A handler that reports the exceptions and then continues execution.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="F:JetBrains.Util.OnError.Throw">
            <summary>
            A handler that always throws an exception.
            When the calling function is properly implemented, provides for <c>[NotNull]</c> behavior.
            </summary>
        </member>
        <member name="P:JetBrains.Util.OnError.IsIgnoringMessage">
            <summary>
            A technical helper which allows to avoid forming a complex exception in case the caller is only interested in the null/notnull result and won't be using the exception message.
            Only use if there're performance reasons.
            This flag should have no impact other than performance of forming the exception.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.ThrowMessage(System.String)">
            <summary>
            A handler that always throws an exception.
            When the calling function is properly implemented, provides for <c>[NotNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.LogAssertion(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an assertion to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.LogAlgorithmError(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an algorithm error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Error(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as an algorithm error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Warn(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as a warning to that logger. This is analogous to the old <c>LogExceptionSilently</c> method.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Verbose(JetBrains.Util.ILogger,System.String,System.Boolean)">
            <summary>
            A handler that logs the exception as a verbose message to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
            <param name="logger">Target logger.</param>
            <param name="extmessage">Optional. A fixed message to add to each reported exception.</param>
            <param name="isFullException">By default, exceptions are not fully rendered to save on performance and avoid huge log messages. Allows to turn on full exception dumping.</param>
        </member>
        <member name="M:JetBrains.Util.OnError.Info(JetBrains.Util.ILogger,System.String,System.Boolean)">
            <summary>
            A handler that logs the exception as a info message to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
            <param name="logger">Target logger.</param>
            <param name="extmessage">Optional. A fixed message to add to each reported exception.</param>
            <param name="isFullException">By default, exceptions are not fully rendered to save on performance and avoid huge log messages. Allows to turn on full exception dumping.</param>
        </member>
        <member name="M:JetBrains.Util.OnError.LogForeignException(JetBrains.Util.ILogger)">
            <summary>
            A handler that logs the exception as a foreign error to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Trace(JetBrains.Util.ILogger,System.String)">
            <summary>
            A handler that logs the exception as a traced message to that logger.
            Provides for <c>[CanBeNull]</c> behavior.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Handle(System.Exception)">
            <summary>
            <para>Called by a not-null-or-can-be-null function when an exception-worth error occurs. Could throw, store, or ignore the failure.</para>
            <para>The calling code must be ready that an exception might be thrown out (<c>[NotNull]</c> case).</para>
            <para>The calling code must be ready that execution might continue (<c>[CanBeNull]</c> case should return <c>Null</c> if so).</para>
            <para>Typical usage:</para>
            <code>
            if(isFailed)
            {
                onerror.Handle(new InvalidOperationException("FAIL").AddData("More", () => "Info"));  // Throws in [NotNull] case
                return null;  // Executes in [CanBeNull] case
            }
            </code>
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.WithMessage(System.String)">
            <summary>
            Creates a new <see cref="T:JetBrains.Util.OnError"/> object which wraps the handled exception with a given message exception before passing control to the current <see cref="T:JetBrains.Util.OnError"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Catch(System.Action)">
            <summary>
            Executes the <paramref name="action"/>.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="M:JetBrains.Util.OnError.Catch``1(System.Func{``0})">
            <summary>
            Executes the <paramref name="func"/> and returns its result or default value if exception happens.
            Catches all of the exceptions, reports them, and ensures guaranteed return.
            </summary>
        </member>
        <member name="T:JetBrains.Util.XmlHtmlNamedCharacterReferences">
            <summary>
            Lists XML Character Entity / HTML named characters. Includes known names from HTML 5.1 preview as of 2014-07-30, http://www.w3.org/html/wg/drafts/html/master/syntax.html#named-character-references.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlHtmlNamedCharacterReferences.EscapeXmlStandard">
            <summary>
            The chars usually escaped in generic XML/HTML.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlHtmlNamedCharacterReferences.EscapeXmlStandardAndControlChars">
            <summary>
            The chars usually escaped in generic XML/HTML, plus ASCII control characters [0..32).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.TryGetNamedReferenceBySingleChar(System.Char)">
            <summary>
            For entities which have a value fitting within a single UTF16 character, maps such characters to some of the alternative entity names.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferences.TryGetValueForCharacterReference(JetBrains.Util.dataStructures.Sources.StringSource,System.Char@,System.Char@)">
            <summary>
            Tries to look up a named reference by its name.
            </summary>
            <param name="name">Name.</param>
            <param name="ch1">The first char of the UTF-16LE value string, or NULL if not found.</param>
            <param name="ch2">The second char of the UTF-16LE value string, or NULL if not so long or not found.</param>
        </member>
        <member name="M:JetBrains.Util.XmlHtmlNamedCharacterReferencesOriginalDictionary.CreateXmlHtmlNamedCharacterReferencesDictionary">
            <summary>
            The original dictionary borrowed from the full list of known character entity names.
            The below BLOBs are produced with <code>XmlHtmlNamedCharacterReferences.RenderHashTable</code> and contain native hash tables for lookup by entity name string and by character.
            Previously, this dictionary were used immediately, but it imposed a JIT and cctor penalty on startup.
            </summary>
        </member>
        <member name="F:JetBrains.Util.PlatformUtil.LinuxLibC.Bionic">
            <summary>
              Android
            </summary>
        </member>
        <member name="F:JetBrains.Util.PlatformUtil.LinuxLibC.Glibc">
            <summary>
              Ordinary Linuxes such as Debian, Fedora, Ubuntu, ...
            </summary>
        </member>
        <member name="F:JetBrains.Util.PlatformUtil.LinuxLibC.Musl">
            <summary>
              Apline Linux
            </summary>
        </member>
        <member name="T:JetBrains.Util.PlatformUtil.LinuxDistro">
            <summary>
              Used only to choose the correct version of .NET SDK v1.1 or earlier (ask #profiler-team).
            </summary>
        </member>
        <member name="M:JetBrains.Util.PlatformUtil.ChModToExecute(JetBrains.Util.FileSystemPath)">
            <summary>
            Sets the file mode when running on *nix to <see cref="F:JetBrains.Interop.Unix.UnixFileModes.rwxr_xr_x"/>. Does nothing on WinNT.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:JetBrains.Util.PlatformUtil.ChModToNormal(JetBrains.Util.FileSystemPath)">
            <summary>
            Sets the file mode when running on *nix to <see cref="F:JetBrains.Interop.Unix.UnixFileModes.rw_r__r__"/>. Does nothing on WinNT.
            </summary>
            <param name="path"></param>
        </member>
        <member name="M:JetBrains.Util.PlatformUtil.ChMod(JetBrains.Util.FileSystemPath,JetBrains.Interop.Unix.UnixFileModes)">
            <summary>
            Sets the file mode when running on *nix. Does nothing on WinNT.
            </summary>
            <param name="path"></param>
            <param name="mode"></param>
        </member>
        <member name="M:JetBrains.Util.PlatformUtilUnix.Stat(System.String,JetBrains.Interop.Unix.Helpers.Stat@)">
            <summary>
            Gets file status on *nix.
            </summary>
            <param name="path"></param>
            <param name="stat"></param>
        </member>
        <member name="M:JetBrains.Util.ProcessorUtil.GetProcessorCountWithAffinityMask">
            <summary>
              Combines <see cref="P:System.Environment.ProcessorCount" /> with <see cref="P:System.Diagnostics.Process.ProcessorAffinity" /> mask, returns the number of CPUs effectively available to this process.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Interop.RegistryEx">
            <summary>
              Extensions for accessing Registry in an explicitly-defined view on 64-bit systems, regardless of the architecture of
              the currently running process.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.myIsCustomRootKey">
            <summary>
            Normally, we'd only allow a limited set of root HKEYs as <see cref="F:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.myKeyBase"/>.
            Loading an app hive makes an exception to this rule because it's a virtual root which is a valid root yet not in the list of the special keys.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.CreateKey(JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.OnError)">
            <summary>
              <para>Creates a key.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the key was successfully created.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.DeleteKey(JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.OnError)">
            <summary>
              <para>Deletes a key.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the key was successfully deleted.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.DeleteValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Deletes a value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully deleted.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetRawValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt32@,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a raw value.</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="valuetype">Return value type</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetDwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a 32-bits word value (REG_DWORD).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetQwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a 64-bits word value (REG_QWORD).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetStringValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a string value (REG_SZ or REG_EXPAND_SZ).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetStringArrayValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a string array value (REG_MULTI_SZ).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.GetBinaryValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Reads a binary value (REG_BINARY).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="onerror">
              Error handling. If the Registry value is missing, but everything else is OK, a <c>Null</c> is
              silently returned. In case of any errors, an exception is reported and <c>Null</c> is returned.
            </param>
            <returns>
              If <paramref name="onerror" /> is throwing, returns <c>Null</c> only if the value is missing. In non-throwing
              case, returns <c>Null</c> if the value cannot be read due to any reason.
            </returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetDwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt32,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a 32-bits word value (REG_DWORD).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">32-bits word value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetQwordValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.UInt64,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a 64-bits word value (REG_QWORD).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">64-bits word value.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetStringValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string value (REG_SZ).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">String value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetExpandStringValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.String,JetBrains.Util.OnError)">
            <summary>
              <para>Writes a expand string value (REG_EXPAND_SZ).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">String value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetStringArrayValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.String[],JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string array value (REG_MULTI_SZ).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">String value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.SetBinaryValue(JetBrains.Util.BackSlashSeparatedRelativePath,System.String,System.Byte[],JetBrains.Util.OnError)">
            <summary>
              <para>Writes a string value (REG_BINARY).</para>
            </summary>
            <param name="subkey">Subkey under the hive root key.</param>
            <param name="dataname">Name of the Registry data, or <c></c> for the default value.</param>
            <param name="datavalue">Byte array value, non-<c>Null</c>.</param>
            <param name="onerror">Error handling. In case of any errors, an exception is reported and <c>False</c> is returned.</param>
            <returns>Whether the value was successfully written.</returns>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.RegistryHiveAccess.LoadHive(JetBrains.Lifetimes.Lifetime,JetBrains.Util.BackSlashSeparatedRelativePath,JetBrains.Util.FileSystemPath,JetBrains.Util.OnError)">
            <summary>
              <para>Loads a Registry file on disk to work with it as with normal Registry.</para>
              <para>You might have to call <see cref="M:JetBrains.Interop.WinApi.Privileges.Adjust(System.Diagnostics.Process,JetBrains.Interop.WinApi.Privileges.NameAndAttributes[],System.Boolean)" /> to enable <see cref="F:JetBrains.Interop.WinApi.SeName.SE_RESTORE_NAME" /> and <see cref="F:JetBrains.Interop.WinApi.SeName.SE_BACKUP_NAME" /> before doing this for the first time.</para>
              <para>The only valid root keys for this are <see cref="F:Microsoft.Win32.Registry.LocalMachine" /> and <see cref="F:Microsoft.Win32.Registry.Users" />.</para>
            </summary>
            <param name="lifetime"></param>
            <param name="subKey">Subpath into which the registry will be mounted.</param>
            <param name="fileName">Disk file with reg hive.</param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.KEY_32">
            <summary>
              Flag to access virtualized WOW6432 hive on x64 regardless of the running process architecture (N/A on NT versions
              below 5.1).
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.KEY_64">
            <summary>
              Flag to access native Registry hive on x64 regardless of the running process architecture (N/A on NT versions below
              5.1).
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InProcessSpecific(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>
                Follows the system policy for Registry virtualization: in 64-bit processes, sees the native Registry, and in
                32-bit processes sees the emulated one. This works the same as default .NET Registry accessor methods.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InSystemNative(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>
                Operates on the system-native Registry view (64-bit on 64-bit systems), regardless of the current process
                architecture.
              </para>
              <para>
                This means that in a 32-bit process on a 64-bit system this reader won't be tricked into the WoW-64-32
                emulation Registry branch, but will read the system-real value.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.InWin32(Microsoft.Win32.RegistryKey)">
            <summary>
              <para>Operates on the 32-bit Registry view (WoW-64-32 emulation view on 64-bit systems).</para>
              <para>
                This means that in a 64-bit process on a 64-bit system this reader will still read the same value as any 32-bit
                process running in the WoW-64-32 emulation will do.
              </para>
              <para>On a 32-bit system, all of the readers read the same.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Interop.RegistryEx.LoadAppHive(JetBrains.Lifetimes.Lifetime,JetBrains.Util.FileSystemPath,JetBrains.Util.ILogger,JetBrains.Util.Interop.RegistryEx.LoadExclusiveness)">
            <summary>
            Uses the <see cref="M:JetBrains.Interop.WinApi.Advapi32Dll.RegLoadAppKeyW(System.String,System.Void**,System.UInt32,System.UInt32,System.UInt32)" /> function.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.LoadExclusiveness.AllowLoadingConcurrently">
            <summary>
            Does not prevent other clients from mapping the same file.
            </summary>
        </member>
        <member name="F:JetBrains.Util.Interop.RegistryEx.LoadExclusiveness.LoadExclusively">
            <summary>
            Prevents other clients from loading the same Registry file.
            </summary>
        </member>
        <member name="T:JetBrains.Util.Sizeof">
            <summary>
              <para>Gets the real runtime size for instances of the specified type, the same size that applies to array elements as they sum up to the array size. Works for intrinsic types, value types, reference types, whatever.</para>
              <para>Uses the <c>sizeof</c> CIL instruction to get the actual size. Note that C#'s <c>sizeof()</c> does not work for all types, and <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" /> gets the marshalling size, which is a 4x error for a boolean.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.Sizeof.Type``1">
            <summary>
              <para>Gets the real runtime size for instances of the specified type, the same size that applies to array elements as they sum up to the array size. Works for intrinsic types, value types, reference types, whatever.</para>
              <para>Uses the <c>sizeof</c> CIL instruction to get the actual size. Note that C#'s <c>sizeof()</c> does not work for all types, and <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" /> gets the marshalling size, which is a 4x error for a boolean.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Util.Sizeof.Reflection">
            <summary>
            Before referencing <c>System.Runtime.CompilerServices.Unsafe</c>, which has the <c>sizeof</c> IL opcode compiled-in, we didn't want to make a separate assembly for this task, so we emitted a dynamic assembly at runtime. This class keeps the original code for reference and for possible case that Unsafe is unavailable in some context.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Sizeof.Reflection.Type``1">
            <summary>
              <para>Gets the real runtime size for instances of the specified type, the same size that applies to array elements as they sum up to the array size. Works for intrinsic types, value types, reference types, whatever.</para>
              <para>Uses the <c>sizeof</c> CIL instruction to get the actual size. Note that C#'s <c>sizeof()</c> does not work for all types, and <see cref="M:System.Runtime.InteropServices.Marshal.SizeOf(System.Object)" /> gets the marshalling size, which is a 4x error for a boolean.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.SortUtil.IterativeTopoSorter`1.IterativeSort(System.Collections.Generic.IEnumerable{`0},System.Func{`0,System.Collections.Generic.IEnumerable{`0}})">
            Produce a topological sort of a given directed acyclic graph, given a set of nodes which include all nodes
            that have no predecessors. Any nodes not in the given set, but reachable through successors, will be added
            to the result. This is an iterative rather than recursive implementation, so it is unlikely to cause a stack
        </member>
        <member name="T:JetBrains.Util.StringTextElementEnumerator">
            <summary>
            Improved version of <see cref="T:System.Globalization.TextElementEnumerator"/> that allows
            getting the index range of the Unicode text elements in a string
            without allocating strings for each text element.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Convert``1(System.String,System.StringComparison,JetBrains.Util.Pair{System.String,``0}[])">
            <summary>
            Converts string value to the type <see cref="!:T"/> given set of known values 
            </summary>
            <param name="propertyValue">String value to be converted</param>
            <param name="stringComparison">String comparison to use</param>
            <param name="options">Known values</param>
            <typeparam name="T">Return type</typeparam>
            <returns>Matched value or null</returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Convert``1(System.String,``0,System.StringComparison,JetBrains.Util.Pair{System.String,``0}[])">
            <summary>
            Converts string value to the type <see cref="!:T"/> given set of known values 
            </summary>
            <param name="propertyValue">String value to be converted</param>
            <param name="fallbackValue">Value to return if no option matched</param>
            <param name="stringComparison">String comparison to use</param>
            <param name="options">Known values</param>
            <typeparam name="T">Return type</typeparam>
            <returns>Matched value or <see cref="!:fallbackValue"/></returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Convert``1(System.String,System.Func{``0},System.StringComparison,JetBrains.Util.Pair{System.String,``0}[])">
            <summary>
            Converts string value to the type <see cref="!:T"/> given set of known values 
            </summary>
            <param name="propertyValue">String value to be converted</param>
            <param name="fallbackValueFunc">Function that calculates fallback value if no option matched</param>
            <param name="stringComparison">String comparison to use</param>
            <param name="options">Known values</param>
            <typeparam name="T">Return type</typeparam>
            <returns>Matched value or calculated fallback value</returns>
        </member>
        <member name="F:JetBrains.Util.StringUtil.ourRandom">
            <summary>
            In order to get varying results on adjacent calls, there must be a shared Random object.
            </summary>
        </member>
        <member name="F:JetBrains.Util.StringUtil.ourRegexMacro">
            <summary>
            Caches the macro substitution regex.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StartsWith(System.String,System.String,System.StringComparison)">
            <summary>
            Returns true if one qualified name starts with another.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Combine(System.String,System.String)">
            <summary>
            Concatenates two names into a qualified name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ShortName(System.String)">
            <summary>
            Gets a short name out of qualified name (does not take nested classes (+ sign) into account)
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.NextQualification(System.String,System.String)">
            <summary>
            Takes a start of a fully qualified name and adds next part of it, e.g.:
            NextQualification ("A.B", "A.B.D.D") results in "A.B.D".
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SplitFQName(System.String)">
            <remarks> Splits fully qualified name of a class into name of the namespace and short name </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.MakeFQName(System.String,System.String)">
            <remarks>Concat namespace name and class name into fully qualified name</remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.Split(System.String,System.String,System.Boolean)">
            <remarks> Splits a string into tokens given the string of delimiter characters. The third argument
            tells whether it is necessary to retain empty strings in the array returned. This functions is not
            as efficient as it may be, so use it accurately.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GetCommon(System.String,System.String,System.Int32@)">
            <summary>
            Gets intersection of two qualified names
            </summary>
            <example>
            Calling it for "A.B.D.D" and "C.D.E.F" will return "C.D"
            </example>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SubstituteMacros(System.String,System.Func{System.String,System.String})">
            <summary>
            <para>Substitutes the macros in a string, throws if there are undefined macros.</para>
            <para>Does a one-stage replacement only, i.e. if some macro expands into another macro,
            this is not processed if the macro is known and not treated as an error if the macro is unknown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SubstituteMacros(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>
            <para>Substitutes the macros in a string, throws if there are undefined macros.</para>
            <para>Does a one-stage replacement only, i.e. if some macro expands into another macro,
            this is not processed if the macro is known and not treated as an error if the macro is unknown.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName(System.String)">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName(System.Int32)">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomName(System.Int32,System.Random)">
            <summary>
            Produces a human-readable random name.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomNameForObject(System.Object)">
            <summary>
              <para>Produces a stable human-readable random name for an object instance.</para>
              <para>For reference objects, uses object's sync table address as a unique identification for the instance for its lifetime.</para>
              <para>For value types, there is no stable instance identity, so it uses the hash code of the instance itself assuming it's correctly derived from the value.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GenerateRandomNameForObjectDeferred(System.Object)">
            <summary>
            Produces a stable human-readable random name for an object instance. This function does not make the calculations or string allocation until <see cref="M:System.Object.ToString"/> is called on the returned value type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.IsNullOrEmpty(System.String)">
            <summary>
            Returns <c>true</c> if and only if <paramref name="value"/> is empty or null.
            </summary>
            <remarks>
            This method required to avoid calls of <seealso cref="M:JetBrains.Util.CollectionUtil.IsNullOrEmpty``1(System.Collections.Generic.IEnumerable{``0})"/> on strings.
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.IsEmpty(System.String)">
            <summary>
            Checks whether the string is an empty string or a <c>Null</c> reference.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.StringUtil.IsNotEmpty(System.String)">
            <summary>
            Checks whether the string is a non-empty string.
            </summary>
            <seealso cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:JetBrains.Util.StringUtil.NotEmptyOrNull(System.String)">
            <summary>
            Returns non-empty string, otherwise null.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.FormatQuoted(System.String,System.Object[])">
            <summary>
            Works like <see cref="M:System.String.Format(System.String,System.Object[])"/>, but surrounds the space-containing arguments with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.QuoteIfNeeded(System.String)">
            <summary>
            If the string contains spaces, surrounds it with quotes.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.RemoveQuotes(System.String)">
            <summary>
            If the string surrounded by quotes remove them
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToStringIfNonDefault(System.Object)">
            <summary>
            Returns the <paramref name="o"/>'s <see cref="M:System.Object.ToString"/> value, unless <paramref name="o"/> is <c>Null</c>, or its <see cref="M:System.Object.ToString"/> is the default implementation (just returns the type name).
            Could be used to prevent non-implemented strings from getting into the UI.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.DropMiddleIfLong(System.String,System.Int32)">
            <summary>
            Makes sure the return text is no longer than <paramref name="nMaxLen"/>.
            Drops some text from the middle, if needed, keeping the beginning and the end.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.IntPtr)">
            <summary>
            Renders the pointer-sized integer as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.Void*)">
            <summary>
            Renders the pointer value as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToHexString(System.UIntPtr)">
            <summary>
            Renders the pointer-sized integer as the appropriate number of hex chars, with leading zeros.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.ToStringWithLeading(System.Int32,System.Int32)">
            <summary>
            Formats the <paramref name="value"/> to a string, adding leading zeros so that
            all of the numbers up to <paramref name="maxvalue"/>, inclusively, had the same
            number of characters in their string representation when formatted thru this function.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.SplitByWords(System.String)">
            <summary>
            Gets the words.
            </summary>
            <param name="text">The text.</param>
        </member>
        <member name="M:JetBrains.Util.StringUtil.MakeUpperCamelCaseName(System.String)">
            <summary>
            Changes the name from lowerCamelCase or MixedCAMELCase or
            dashed-words or underscored_words into the UpperCamelCase format.
            </summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.MakeUnderscoreCaseName(System.String)">
            <summary>
            Changes the name from CamelCase or mixed case into lower_underscore_case format.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GetPlatformIndependentHashCode(System.String,System.Boolean)">
            <summary>
            Platform independent hash code, can be used to persist records. <see cref="M:System.String.ToString"/>
            is different for x86 and x64, so it can't be used for serialization.
            </summary>
            <param name="s">source string</param>
            <param name="caseSensitive"> whether method should threat capital and smaller letters differently </param>
            <returns>hashcode</returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.UrlEncode(System.String)">
            <summary>
            Encodes a string for URI charset, assuming UTF-8 encoding for any non-ascii characters.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.HtmlEncode(System.String)">
            <summary>
            HTML-encodes a string and returns the encoded string.
            </summary>
            <param name="text">The text string to encode. </param>
            <returns>The HTML-encoded text.</returns>
        </member>
        <member name="M:JetBrains.Util.StringUtil.GetStringOrErrorMessage``1(System.Func{``0})">
            <summary>
            Returns a string representation of the object or an exception information, if the <see cref="!:getter"/> fails.
            Designed for logging when you want to know what kind of exception happened, but don't need the call stack.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StrFormatByteSize(System.Int64)">
            <summary>
            Converts a numeric value into a string that represents the number expressed as a size value in bytes, kilobytes, megabytes, or gigabytes, depending on the size.
            </summary>
            <param name="nSize">Numeric value to be converted.</param>
            <returns>Returns the size string.</returns>
            <remarks>
            The following table illustrates how this function converts a numeric value into a text string.
            Numeric value -> Text string
            532 532 -> bytes
            1340 -> 1.30KB
            23506 -> 22.9KB
            2400016 -> 2.29MB
            2400000000 -> 2.23GB
            
            Current implementation on Unix systems is a bit simplier
            </remarks>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StrFormatByteSizeSimple(System.Int64)">
            <summary>
            Platform independent simple implementation of <see cref="M:JetBrains.Interop.WinApi.ShlwapiDll.Helpers.StrFormatByteSize(System.Int64)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.StringUtil.StringCchLength(System.Char*,System.UInt32)">
            <summary>
            Gets the length of a zero-terminated string, not including the zero character.
            </summary>
            <param name="psz">Points to the character string.</param>
            <param name="cchMax">The maximum number of characters allowed in psz, including the terminating null character.</param>
        </member>
        <member name="M:JetBrains.Util.StringUtil.EqualityComparerGetHashCodeCaseInsensitively(System.Char*,System.UInt32)">
            <summary>
            For a char buffer, gets its hash code case-insensitively, using optimized platform routines if available.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeXmlStandard">
            <summary>
            The chars usually escaped in generic XML/HTML.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeXmlStandardAndControlChars">
            <summary>
            The chars usually escaped in generic XML/HTML, plus ASCII control characters [0..32).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValue(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            Creates attribute only if passed value is not empty
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValueFluent(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            A fluent version of <see cref="M:JetBrains.Util.XmlUtil.CreateAttributeWithNonEmptyValue(System.Xml.XmlElement,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.CreateAttributeWithValueFluent(System.Xml.XmlElement,System.String,System.String)">
            <summary>
            A fluent version of <see cref="M:JetBrains.Util.XmlUtil.CreateAttributeWithValue(System.Xml.XmlElement,System.String,System.String)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,System.Char[])">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,JetBrains.Util.RangeTranslator@,System.Char[])">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.CharsToEscape">
            <summary>
            The characters which explicitly should be escape.
            If you specify no characters, this list won't work, there's no fallback assumed here.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.AllowedRangeMin">
            <summary>
            Allows to limit the charset. Set both ends to <c>0</c> to set no range limit.
            If nonzero, defines the lowest allowed UTF-16 char code, inclusively.
            Note that 
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.EscapeChars.AllowedRangeMax">
            <summary>
            Allows to limit the charset. Set both ends to <c>0</c> to set no range limit.
            If nonzero, defines the highest allowed UTF-16 char code, inclusively.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.EscapeXmlString(System.String,System.Boolean,JetBrains.Util.RangeTranslator@,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            XML-escapes the chosen characters in a string.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ShouldEscape(System.String,System.Char[])">
            <summary>
            Checks if a string should be XML-escaped.
            </summary>
            <param name="text">The text to test.</param>
            <param name="charsToEscape">The characters to be escaped. NULL to use the default set for XML escaping, or any custom collection.</param>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ShouldEscape(System.String,JetBrains.Util.XmlUtil.EscapeChars)">
            <summary>
            Checks if a string should be XML-escaped.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.UnescapeXmlString(JetBrains.Util.StringSlice)">
            <summary>
            Runs on a string slice, non-allocating if there're no actual unescapes to be made.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.CtxUnescape.OriginalText">
            <summary>
            A copy of the original text.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.CtxUnescape.UserDefinedOutputStringBuilder">
            <summary>
            If the user wants the output written into a string builder (regardless of whether there were escaping or not), pass it here.
            If <c>NULL</c>, a new one will be created on-demand and returned, or a <c>NULL</c> return value means that no escaping were needed.
            </summary>
        </member>
        <member name="F:JetBrains.Util.XmlUtil.UnescapeXmlStringDelegate">
            <summary>
            The unescaper string processing function, to be used with <see cref="M:JetBrains.Util.StringSlice.ProcessString(JetBrains.Util.StringSlice.ProcessStringDelegate)" />.
            The context should hold a copy of the original string, for lookups.
            Returns a string builder with the new unescaped text, if unescaping were needed; or <c>NULL</c>, which means the original string should be presented as the unescaping result.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.OwnerDocumentNonNull(System.Xml.XmlNode)">
            <summary>
            Replaces <see cref="P:System.Xml.XmlNode.OwnerDocument"/>, always yields non-NULL, throws if NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.ParentNodeNonNull(System.Xml.XmlNode)">
            <summary>
            Replaces <see cref="P:System.Xml.XmlNode.ParentNode" />, always yields non-NULL, throws if NULL.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.OuterXmlIndented(System.Xml.XmlElement)">
            <summary>
            Gets the markup representing this node and all its child nodes, just like <see cref="P:System.Xml.XmlNode.OuterXml"/>, but with all the formatting and indenting of <see cref="P:JetBrains.Util.XmlWriterEx.WriterSettings"/> applied (<see cref="P:System.Xml.XmlNode.OuterXml"/> renders content as one line of text).
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.GetChildElements(System.Xml.XmlNode)">
            <summary>
            Return all child <see cref="T:System.Xml.XmlElement"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Util.XmlUtil.GetChildElements(System.Xml.XmlNode,System.String)">
            <summary>
            Return all child <see cref="T:System.Xml.XmlElement"/> with specified name.
            </summary>
        </member>
        <member name="T:JetBrains.Rd.ClientId">
            <summary>
            ClientId is a global context class that is used to distinguish the originator of an action in multi-client systems
            In such systems, each client has their own ClientId.
            
            The context is automatically propagated across async/await calls using AsyncLocal. The application should take care to preserve and propagate the current value across other kinds of asynchronous calls. 
            </summary>
        </member>
        <member name="M:JetBrains.Rd.ClientIdEx.IsLocal(JetBrains.Rd.ClientId)">
            <summary>
            Returns true if <paramref name="clientId"/> represents local IDE user, and false if a <paramref name="clientId"/> is a guest user
            </summary>
            <param name="clientId"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Threading.IPlatformDispatcherImpl">
            <summary>
            Platform-specific, non-thread-bound implementation of the entity actually deferring the execution.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.IPlatformDispatcherImpl.IsShutDown">
            <summary>
            Gets whether this dispatcher platform-specific implementation has been shut down (this will break the message loop, if any).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.IPlatformDispatcherImpl.Init(JetBrains.Threading.JetDispatcher)">
            <summary>
            Init the instance (activities not related to the registration of this instance).
            </summary>
            <param name="dispatcher">Thread-bound part of the dispatcher.</param>
        </member>
        <member name="M:JetBrains.Threading.IPlatformDispatcherImpl.ShutDown">
            <summary>
            Shuts down a platform-specific part of the dispatcher (should be invoked on the corresponding dispatcher thread).
            Th corresponding dispatcher will not be shutdown at the same time.
            Breaks the message loop, if any.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.IPlatformDispatcherImpl.InvokeAsync(System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the corresponding dispatcher thread, asynchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.IPlatformDispatcherImpl.Invoke(System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Invokes an action on the corresponding dispatcher thread, synchronously.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.OptionCallNativeMarshallerEveryItems">
            <summary>
              To increase reliability, the system marshaller will be additionally called when a multiple of this number is reached on the queue (if the first marshaller calls are lost due to
              some accident (e.g. system marshaller silently ignoring message postings when the Windows messages queue is full), we might never ever process the queue).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.OptionCallNativeMarshallerForFirstItems">
            <summary>
              To increase reliability, the system marshaller will be called for these first items added to the queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ourQueueLock">
            <summary>
              Syncs write access to <see cref="F:JetBrains.Threading.JetDispatcher.myPriorityBuckets" />, their fields, and their queues, and <see cref="F:JetBrains.Threading.JetDispatcher.myGeneration" />, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ourDispatchers">
            <summary>
              Dispatchers by their owning threads.
              Copy-on-write: instances are readonly, reads are lock-free, writes are lock-and-replace (<see cref="F:JetBrains.Threading.JetDispatcher.ourDispatchersWriterLock" />).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ourDispatchersWriterLock">
            <summary>
              Syncs write access to <see cref="F:JetBrains.Threading.JetDispatcher.ourDispatchers" />.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.OptionQueueReasonableSizeLimit">
            <summary>
              Report an exception when the queue reaches this limit. Shouldn't be stacking these many actions on the queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myPriorityBuckets">
            <summary>
              A lazy-inited queue (plus some additional state/cache) per each item priority class.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Thread">
            <summary>
              Gets the thread the dispatcher is running on.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myAsyncBehaviors">
            <summary>
              Encapsulates async behavior allowed/prohibited tracking.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myDontRun">
            <summary>
              Means the <see cref="M:JetBrains.Threading.JetDispatcher.Run" /> method should abort.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myExternalIdleProcessing">
            <summary>
              Main thread modification only. Any thread access. <see cref="M:JetBrains.Threading.JetDispatcher.SetIdleProcessingExternalDriver(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" /> backend.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myGeneration">
            <summary>
              Provides the generation number for <see cref="F:JetBrains.Threading.JetDispatcher.Closure.Generation" />.
              Can be read free-threaded (because in absence of synchronization you cannot prove violation of invariants).
              Incremented under the <see cref="F:JetBrains.Threading.JetDispatcher.ourQueueLock" />.
              Must not be zero.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.myPendingTasksCount">
            <summary>
            Provides a simple counter of tasks which were queued (BeginInvoke and Invoke calls), but not executed.
            It is needed to test whether <see cref="P:JetBrains.Threading.JetDispatcher.DispatcherImpl"/> not skipping tasks.
            Always writes under the <see cref="T:System.Threading.Interlocked"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.#ctor(JetBrains.Threading.IPlatformDispatcherImpl)">
            <summary>
              Creates an instance, for use only from <see cref="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher" />.
              Must be called under the <see cref="F:JetBrains.Threading.JetDispatcher.ourDispatchersWriterLock" />.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.DispatcherImpl">
            <summary>
            Platform-specific, non-thread-bound implementation of the entity actually deferring the execution.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher">
            <summary>
              Gets or creates a dispatcher for the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CreateDispatcherTimer">
            <summary>
            Creates platform-specific dispatcher timer.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CreateDispatcherTimer(System.Int32)">
            <summary>
            Creates platform-specific dispatcher timer.
            </summary>
            <param name="interval">Interval in milliseconds</param>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited">
            <summary>
              <para>Gets whether posting messages to the dispatcher thread is not allowed at the moment.</para>
              <para>To enable/disable async behavior use <see cref="P:JetBrains.Threading.JetDispatcher.AsyncBehaviorAllowed" />. property.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.AsyncBehaviorAllowed">
            <inheritdoc cref="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.IsAsyncBehaviorAllowed" />
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorAllowed">
            <inheritdoc cref="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.IsAsyncBehaviorAllowed" />
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.IsShutDown">
            <summary>
              Gets whether this dispatcher has been shut down and will not <see cref="M:JetBrains.Threading.JetDispatcher.Run" /> any more requests.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertFreeThreaded">
            <summary>
              Asserts that the calling method is free-threaded. A marker function that does not do anything.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CreateDispatcherThread(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
              Creates a new <see cref="F:System.Threading.ApartmentState.STA" /> <see cref="T:System.Threading.Thread" /> that is controlled by a <see cref="T:JetBrains.Threading.JetDispatcher" />.
              To stop the thread, use <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown" />.
            </summary>
            <param name="lifetime"></param>
            <param name="name">Arbitrary name for the new thread.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.FromThread(System.Threading.Thread)">
            <summary>
              <para>Tries to get a dispatcher for the specified <paramref name="thread" />, if already created.</para>
              <para>Returns <c>Null</c> if no dispatcher is running on that thread. To create a new dispatcher, use the <see cref="P:JetBrains.Threading.JetDispatcher.CurrentDispatcher" /> property on the desired thread.</para>
            </summary>
            <param name="thread">The thread to get a dispatcher for.</param>
            <returns>The existing dispatcher for that thread, or <c>Null</c>.</returns>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ResetForTests">
            <summary>
            Since we have static flags we need a way to reset them for tests purposes.
            Do NOT use this method except in tests!
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.SubstitutePlatformSpecific(JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific)">
             <summary>
             Provides a one-time way to replace the platform implementation of <see cref="T:JetBrains.Threading.JetDispatcher"/>.
             Currently the only use case is for use Avalonia dispatcher in Standalone applications on Avalonia:
             The application starts with our default implementation of <see cref="T:JetBrains.Threading.IPlatformDispatcherImpl"/>
             (depending on the platform <see cref="T:JetBrains.Util.Concurrency.WinDispatcherImpl"/> or <see cref="T:JetBrains.Util.Concurrency.UnixDispatcherImpl"/>),
             then Shell starts and Avalonia is initialized. Once Avalonia is initialized and the Avalonia dispatcher is ready,
             the <see cref="T:JetBrains.Threading.IPlatformDispatcherImpl"/> is replaced.
            
             All current tasks in the queue will be executed on the previous <see cref="T:JetBrains.Threading.IPlatformDispatcherImpl"/> implementation.
             But this method has no immediate effect. Switching to the new <see cref="T:JetBrains.Threading.IPlatformDispatcherImpl"/> implementation will be proceed
             after some time, when the current message loop is finished. So some newly invoked tasks can be executed
             on the previous <see cref="T:JetBrains.Threading.IPlatformDispatcherImpl"/> implementation.
            
             IMPORTANT: all active message loops (if any) will be exited after all remaining tasks are finished.
             Then loops will be restarted based on replaced <see cref="T:JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific"/>.
             </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.EnsureSynchronizationContextCaptured">
            <summary>
            Checks if the synchronization context has been recaptured by someone else.
            If yes, sets the <see cref="T:JetBrains.Threading.JetDispatcher.JetDispatcherSynchronizationContext"/> back, otherwise does nothing.
            Must be called from the Dispatcher thread.
            Normally there should not be the case when someone sets their own context and do not restore the original one.
            One possible case is due to an issue in Nunit, see https://github.com/nunit/nunit/issues/3740
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.PumpMessagesOnce">
            <summary>
              <para>Pumps all the Windows messages (and async actions) currently on the queue, and terminates.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
            <returns>The number of messages actually pumped.</returns>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but
                for at most <paramref name="timeout" /> period of time.
              </para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(JetBrains.DataFlow.IProperty{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but
                for at most <paramref name="timeout" /> period of time, if the thread supports message pumps; sleeps otherwise.
              </para>
              <para>
                Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout" /> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail" />, in which case an exception is
                thrown.
              </para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.Func{System.Boolean},System.TimeSpan,System.Boolean)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but
                for at most <paramref name="timeout" /> period of time.
              </para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.Func{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) while the given <paramref name="condition" /> is true, but
                for at most <paramref name="timeout" /> period of time, if the thread supports message pumps; sleeps otherwise.
              </para>
              <para>
                Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout" /> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail" />, in which case an exception is
                thrown.
              </para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.Threading.Tasks.Task,System.TimeSpan,System.Boolean)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until the given task <paramref name="waitUntilDone" /> is
                completed, but for at most <paramref name="timeout" /> period of time.
              </para>
              <para>Returns whether the wait succeeded (timeout was not reached), unless <paramref name="bThrowOnTimeout" /> is <c>True</c>, in which case an exception is thrown.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.Threading.Tasks.Task,System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until the given task <paramref name="waitUntilDone" /> is
              completed, but for at most <paramref name="timeout" /> period of time, if the thread supports message pumps; sleeps otherwise.
              <para>
                Returns whether the wait succeeded (timeout was not reached), unless <paramref name="ontimeout" /> is <see cref="F:JetBrains.Threading.OnWaitTimeout.Fail" />, in which case an exception is
                thrown.
              </para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run(System.TimeSpan)">
            <summary>
              <para>Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time.</para>
              <para>The thread must support message pumps (be an STA thread).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunOrSleep(System.TimeSpan)">
            <summary>
              <para>
                Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) for the <paramref name="timeout" /> period of time, if the
                thread supports message pumps.
              </para>
              <para>Sleeps out the given amount of time otherwise.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Run">
            <summary>
              Employs the current thread.
              Pumps the Windows messages on the current thread (which includes all of the async operations and marshallings) until <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown" /> is invoked for this dispatcher.
              This method only works on threads which support message pumps, and there is no sleep-version because that would be an infinite sleep.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.RunAndRestartIfNeeded(System.TimeSpan,System.Boolean,System.Func{JetBrains.Util.Concurrency.IJetDispatcherPlatformSpecific,System.TimeSpan,System.Boolean,JetBrains.Util.Concurrency.MessageLoopStatus})">
            <summary>
            Runs a message loop. Checks if the loop was terminated due to <see cref="F:JetBrains.Threading.JetDispatcher.PlatformSpecific"/> is changed and restarts the loop if true.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Sleep(System.Func{System.Boolean},System.TimeSpan,JetBrains.Threading.OnWaitTimeout)">
            <summary>
              Implements sleeping for the run-or-sleep methods family, for non-STA threads.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertAccess">
            <summary>
              Throws if the current thread is not the thread associated with this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AssertAsyncBehaviorSupported(System.String)">
            <summary>
              Throws if asynchronous operations are not supported on the dispatcher thread.
            </summary>
            <seealso cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited" />
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              Invokes an action on the dispatcher thread, asynchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvoke(JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              Invokes an action on the dispatcher thread, asynchronously.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="T:JetBrains.Util.Logging.Logger" />.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginOrInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginOrInvoke(JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              Invokes an action on the dispatcher thread, synchronously, if called on the same thread, or asynchronously, if called on another thread.
            </summary>
            <param name="lifetime">Limiting lifetime. If the lifetime ends before the action is executed, the execution is canceled.</param>
            <param name="name">Name of the action to execute. Used for debugging, logging, and exceptions identification.</param>
            <param name="action">The action to execute. Its exceptions will be intercepted and reported to the <see cref="T:JetBrains.Util.Logging.Logger" />.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Invoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              Invokes an action on the dispatcher thread, synchronously.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.SetIdleProcessingExternalDriver(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)">
            <summary>
              See <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver" />, <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Callbacks" />.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure)">
            <summary>
              Actually schedules deferred invocation of the action.
            </summary>
            <param name="closure"></param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.BeginInvokeShutdown">
            <summary>
            Shuts down a dispatcher on its thread, asynchronously.
            Breaks the <see cref="M:JetBrains.Threading.JetDispatcher.Run"/>, if any.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CheckAccess">
            <summary>
              Returns whether the calling thread is the thread associated with this dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CheckAllDispatchersTasksCompletionAndLog(System.Boolean)">
            <summary>
            Checks if all tasks in the queues of all dispatchers have been executed.
            </summary>
            <param name="throwException">If true, throws an exception in case of an error.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.CheckTasksCompletionAndLog(System.Boolean,System.Boolean)">
            <summary>
            Checks if all tasks in the queue of current dispatcher have been executed.
            In general it is not an issue (i.e. on app shutdown), but in some cases this can cause some tasks to be skipped.
            </summary>
            <param name="throwException">If true, throws an exception in case of an error.</param>
            <param name="logAsError">If true, logs with Error level in case of an error, otherwise as Warning.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.IsSupportedOnThisThread">
            <summary>
              Gets whether the current thread has been initialized with the apartment which supports the Dispatcher pattern (<see cref="F:System.Threading.ApartmentState.STA" />).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.TryEnsureAsyncBehaviorAllowedForever">
            <inheritdoc cref="M:JetBrains.Threading.JetDispatcher.AsyncBehaviors.TryEnsureAsyncBehaviorAllowedForever" />
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ToString">
            <summary>
              Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            <returns>
              A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ProcessQueue(System.Int32)">
            <summary>
              <para>Called indirectly from <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvokeCore(JetBrains.Threading.JetDispatcher.Closure)" /> by executing thru the marshaller asynchronously.</para>
              <para>Starts processing the higest-priority actions, if any, then lower, and so on, down to the lowest-allowed <paramref name="nMinBucket" />.</para>
            </summary>
            <param name="nMinBucket">The lowest buckets in <see cref="F:JetBrains.Threading.JetDispatcher.myPriorityBuckets" /> which can be processed on this call.</param>
            <returns>Whether processing has been interrupted without doing all of the items it could do (e.g. by idle state revocation). This mimcs the return value semantic of </returns>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.Closure">
            <summary>
              Implements a method that runs on another thread.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcher.Closure.Action">
            <summary>
              Action to execute, <c>Null</c>ed if the lifetime is terminated (execution is canceled).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.Closure.Execute">
            <summary>
              Executes the marshalled action.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Closure.Generation">
            <summary>
              Execution generation to which this schedulled action closure belongs. See usage for details.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.Closure.IsProbing">
            <summary>
            A synthetic scheduled item to make sure the queue gets pumped, see usages.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.AsyncBehaviors">
            <summary>
              Encapsulates async behavior allowed/prohibited tracking.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.IsAsyncBehaviorAllowed">
            <summary>
              <para>Get or set whether posting messages to the dispatcher thread is allowed or not at the moment.</para>
              <para>This could be set to <c>False</c> in the tests which do not pump messages and expect every activity to be completed deterministically and synchronously.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.myIsAsyncBehaviorAllowedForever">
            <summary>
              At runtime, we always have async behavior and an <see cref="P:JetBrains.Threading.JetDispatcher.AsyncBehaviorAllowed" /> period never ends. This allows to optimize certain code by skipping the limitation to the
              current async-allowed lifetime and skip tracking for where it ends. To know for sure, there're three states, see <see cref="T:JetBrains.Threading.JetDispatcher.AsyncBehaviors.EAsyncBehaviorAllowedForever" />.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AsyncBehaviors.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.AsyncBehaviors.TryEnsureAsyncBehaviorAllowedForever">
            <summary>
              <para>Call to check if your code can assume the current async-behavior-allowed period never ends.</para>
              <para>If <c>False</c>, assume async behavior might be prohibited.</para>
              <para>
                If <c>True</c>, assume it's forever. Subsequent attempts to disallow async behavior would fail with an assertion. It's assumed that if a Shell is started in an async mode,
                it won't be turned into sync later; a Shell started in a prohibited mode might be temporarily made async.
              </para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.EAsyncBehaviorAllowedForever.NotInitialized">
            <summary>
              Initial state. Can transition to any other on first use.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.EAsyncBehaviorAllowedForever.AllowedForever">
            <summary>
              <see cref="M:JetBrains.Threading.JetDispatcher.AsyncBehaviors.TryEnsureAsyncBehaviorAllowedForever" /> sets to this value, unless <see cref="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.EAsyncBehaviorAllowedForever.CanBeProhibited" /> has been set first  in which case it does not
              touch.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.AsyncBehaviors.EAsyncBehaviorAllowedForever.CanBeProhibited">
            <summary>
              Prohibiting async behavior changes to this state, unless <see cref="M:JetBrains.Threading.JetDispatcher.AsyncBehaviors.TryEnsureAsyncBehaviorAllowedForever" /> has been called first.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.DispatcherPriorityBucket.FProcessQueue">
            <summary>
              Lazy-created delegate which invokes <see cref="M:JetBrains.Threading.JetDispatcher.ProcessQueue(System.Int32)" /> for this priority class.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.DispatcherPriorityBucket.ItemsQueuedSinceLastExecution">
            <summary>
              Calculates the items added to <see cref="F:JetBrains.Threading.JetDispatcher.DispatcherPriorityBucket.PendingInvocationsQueue" /> since the last time those items were processed by the executor.
              This is needed to post to the underlying marshaller only so rarely, and to make sure we post one more marshaller request when we start queueing nested items for execution
              (BeginInvoke from within another BeginInvoke execution which pumps messages).
              Also reset when the queue gets empty.
              Accessed under <see cref="F:JetBrains.Threading.JetDispatcher.ourQueueLock" /> only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.DispatcherPriorityBucket.PendingInvocationsQueue">
            <summary>
              Default implementation of all the known marshallers (<see cref="!:WindowsFormsSynchronizationContext" /> in WinForms and <see cref="!:Dispatcher" /> in Avalon) would post a new
              Windows message on the queue on every <c>BeginInvoke</c> call. This poses a problem because we might really have lots and lots of <c>BeginInvoke</c> calls (some of them canceled
              later), and the Windows messages queue is of a finite size.
              We only post one (or a few) requests on the <see cref="P:JetBrains.Threading.JetDispatcher.DispatcherImpl" />, and the actual actions to process reside on the queue here.
              This field is lazy-inited on first use.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnIdle">
            <summary>
              Given you when you register a new external driver with <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Set(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />. Call when you detect the idle time after you've been
              requested for that with <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing" /> and until this delegate returns
              <see cref="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingResult.AllDone" />.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnUnavailable">
            <summary>
              Given you when you register a new external driver with <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Set(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />.
              Call when the external idle driver becomes temporary unavailable.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingRequestVerdict">
            <summary>
              External idle driver verdict.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingRequestVerdict.Affirmative">
            <summary>
              The driver is ready to provide OnIdle callbacks.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingRequestVerdict.NegativeTemporary">
            <summary>
              The driver is temporary unavailable.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingRequestVerdict.NegativePermanent">
            <summary>
              The driver gone down and should be switched off.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingResult">
            <summary>
              Idle processing results, values must map to <c>FDoIdle</c> return values.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingResult.AllDone">
            <summary>
              Don't call <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnIdle" /> callback until you're asked again with
              <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing" />.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingResult.HaveMore">
            <summary>
              Call <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnIdle" /> once more as soon as the idle state is achieved again.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.myDriver">
            <summary>
              Written on the main thread, read on any thread, sync not required.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.TryRequestIdleProcessing">
            <summary>
              Calls <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing" /> on the current one, returns whether present and successful (= do not call
              default impl).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IsContinueIdle">
            <summary>
              If we're running idle tasks, tells if we're OK to run more.
              Calls <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.IsContinueIdle" /> if avail, otherwise OK.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnExternalDriverIdle">
            <summary>
              Callback functor to give out to driver on <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Set(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnExternalDriverUnavailable">
            <summary>
              Callback functor to give out to driver on <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Set(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Reset">
            <summary>
              Undoer for <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Set(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />, called upon lifetime termination or on a fault.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver">
            <summary>
              <para>User handler to install the IDLE processing external driver.</para>
              <para>By default, IDLE tasks are scheduled with an idle priority level of the system Dispatcher. Installing an external driver replaces this with a custom implementation.</para>
              <para>An example of the custom implementation is the Visual Studio <c>FDoIdle</c> callback.</para>
              <para>This handler gets installed with <see cref="M:JetBrains.Threading.JetDispatcher.SetIdleProcessingExternalDriver(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver)" />, only one at a time.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.IsContinueIdle">
            <summary>
              <para>
                <see cref="T:JetBrains.Threading.JetDispatcher" /> calls this on the external idle driver while processing the idle tasks on the queue, asks whether it's OK to continue doing so, or the idle
                state might not hold anymore.
              </para>
              <para>Maps to <c>IMsoComponentManager::FContinueIdle</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing">
            <summary>
              <para>
                <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IDriver.RequestIdleProcessing" /> will be called when implementation thinks it should ping the underlying scheduler (not per every scheduled event, but with throttling)
                to schedule the idle processing.
              </para>
              <para>
                After that, the driver should call the <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnIdle" /> callback it has been given upon registration when it thinks
                the idle state has been reached, and continue doing so as long as it gets <see cref="F:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.IdleProcessingResult.HaveMore" />. After
                the idle events have been processed by this <see cref="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.OnIdle" /> callback with a successful return value, it is guaranteed
                that the driver will be called for <see cref="M:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.TryRequestIdleProcessing" /> anew at least once the next time new idle events
                are added.
              </para>
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcher.ExternalIdleProcessing.Callbacks">
            <summary>
              External idle processing driver callbacks.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.JetDispatcherSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcher.JetDispatcherSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <inheritdoc/>
        </member>
        <member name="T:JetBrains.Threading.DispatcherOperationStatus">
            <summary>Describes the possible values for the status of a <see cref="T:System.Windows.Threading.DispatcherOperation" />. </summary>
        </member>
        <member name="F:JetBrains.Threading.DispatcherOperationStatus.Pending">
            <summary>The operation is pending and is still in the <see cref="T:System.Windows.Threading.Dispatcher" /> queue.</summary>
        </member>
        <member name="F:JetBrains.Threading.DispatcherOperationStatus.Aborted">
            <summary>The operation has aborted. </summary>
        </member>
        <member name="F:JetBrains.Threading.DispatcherOperationStatus.Completed">
            <summary>The operation is completed. </summary>
        </member>
        <member name="F:JetBrains.Threading.DispatcherOperationStatus.Executing">
            <summary>The operation started executing, but has not completed. </summary>
        </member>
        <member name="T:JetBrains.Threading.JetDispatcherActionException">
            <summary>
            An exception that reports a failure in the inner (deferred) task.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherActionException.#ctor(JetBrains.Threading.JetDispatcher,System.String,System.Exception)">
            <summary>
            Ctor.
            </summary>
            <param name="dispatcher">The dispatcher that tried to execute the faulty action.</param>
            <param name="name">Dispatcher action name, included in the exception message.</param>
            <param name="ex">Original exception message, included in the exception message, passed to the base.</param>
        </member>
        <member name="P:JetBrains.Threading.JetDispatcherActionException.Name">
            <summary>
            Gets the name of the action that failed.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.ExecuteAsyncIfAllowedOrSync(JetBrains.Threading.JetDispatcher,JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime},System.Action,System.Func{System.Boolean})">
            <summary>
            If async behavior is allowed at the moment of method call executes async action while async is still allowed.
            If not allowed sync action is called.
            </summary>
            <param name="dispatcher">Dispatcher to be run on</param>
            <param name="lifetime">Action lifetime</param>
            <param name="asyncAction">Async action to be called if allowed</param>
            <param name="syncAction">Sync action to be called if async is forbidden</param>
            <param name="extraShouldRunSyncFunc">Optional extra check if run sync anyway</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.DefineAsyncActionLifetimeOrRunSync(JetBrains.Threading.JetDispatcher,JetBrains.Lifetimes.OuterLifetime,System.Action{JetBrains.Lifetimes.LifetimeDefinition},System.Action)">
            <summary>
            <para>If async behavior is allowed, creates a lifetime definition that can be used to execute async actions.</para>
            <para>The lifetime definition is an intersection of the parent lifetime and async allowed lifetime.
            To prevent leaks the definition must be explicitly terminated when all async actions are executed.</para>
            <para>If async behavior is prohibited, runs the sync action immediately.</para> 
            </summary>
            <param name="dispatcher">The dispatcher</param>
            <param name="outerLifetime">The parent lifetime.</param>
            <param name="asyncAction">Action that receives the async lifetime definition.</param>
            <param name="syncAction">Optional. Action to be executed immediately if async behavior is prohibited.</param>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.DispatcherWaitResult``1(System.Threading.Tasks.Task{``0},System.TimeSpan)">
            <summary>
              <para>Waits the task correctly based on the current thread apartment: pumps Windows messages on STA, blocks without pumping on MTA.</para>
              <para>Throws out task errors or on timeout. Returns the task result.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.DispatcherWaitResult(System.Threading.Tasks.Task,System.TimeSpan)">
            <summary>
              <para>Waits the task correctly based on the current thread apartment: pumps Windows messages on STA, blocks without pumping on MTA.</para>
              <para>Throws out task errors or on timeout. Returns the task result.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.GetCallStackAnnotationTypeName(System.String)">
            <summary>
            Gets the texts for Call Stack Annotation frames in <see cref="T:JetBrains.Threading.JetDispatcher" /> and <see cref="T:JetBrains.Threading.ReentrancyGuard" />.
            Try using the same texts in all similar locations so that the helper methods were emitted only once.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.JetDispatcherEx.GetCallStackAnnotationMethodName">
            <summary>
            Gets the texts for Call Stack Annotation frames in <see cref="T:JetBrains.Threading.JetDispatcher" /> and <see cref="T:JetBrains.Threading.ReentrancyGuard" />.
            Try using the same texts in all similar locations so that the helper methods were emitted only once.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.OnWaitTimeout">
            <summary>
              <para>Tells what to do if we performed a conditional wait with a timeout, and it has timed out.</para>
              <para>The default is to throw.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.OnWaitTimeout.Fail">
            <summary>
            Throws an exception, fails the task, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.OnWaitTimeout.Succeed">
            <summary>
            Abandons the wait and proceeds.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.PlatformDispatcherImplBase.RunThreadWaitTimeout">
            <summary>
              Timeout for <see cref="!:Run" /> method's waiting for messages.
              If non-infinite, wakes the thread from time to time, which is nice for the tests (but not essential).
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEvent">
            <summary>
            <para>An event that groups multiple incoming signals within a time span and issues only one outgoing signal for them.</para>
            <para>This allows to accomodate for external events firing at a high rate and execute the handler only when their activity suspends.</para>
            <para>The object is thread-safe: the incoming event may fire on any thread, the outgoing activity always happens on the primary thread, identified by <see cref="P:JetBrains.Threading.GroupingEvent.Host"/>-><see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>-><see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/>.</para>
            <para>If the owning <see cref="T:JetBrains.Threading.GroupingEventHost"/> has <code>GroupingEventHost.IsGuarded</code> on, then the outgoing activity is executed under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.</para>
            <para>The maximum grouping interval is limited by <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myDeadline">
            <summary>
            The deadline, in <see cref="T:System.DateTime"/>-UTC format, if waiting for execution. <c>Null</c>, otherwise.
            Interlocked access required.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myFHandler">
            <summary>
            The outgoing event handler, as passed from ctor, if available.
            <c>Null</c> when:
            (1) Not given to ctor (user relies on <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/>).
            (2) After "Dispose".
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIncoming">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.Incoming"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIncomingDontProlongate">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.IncomingDontProlongate"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myIsExecuting">
            <summary>
            True while we're inside the user <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> handler execution, to avoid reentrancy.
            Primary-thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myLazyIsWaiting">
            <summary>
            Lazy-created by <see cref="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myLockOutgoingField">
            <summary>
            Ensures thread safety of <see cref="F:JetBrains.Threading.GroupingEvent.myOutgoing"/>.
            SWL wouldn't create system table entries for the object's monitor handle and allows zero impact for the case we do not use the signals/locks on a shortlived grouping-event.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.myOutgoing">
            <summary>
            Lazy-created backing for <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.GroupingEventHost,System.String,System.TimeSpan,System.Action)">
            <summary>
            Creates a new grouping event. Must be executed on the primary thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEvent.MaxInterval">
            <summary>
            Limit for an interval of a <see cref="T:JetBrains.Threading.GroupingEvent"/>.
            To avoid the overhead, events with intervals exceeding this value are not supported.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Host">
            <summary>
            Gets the owning host for this object.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Incoming">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread under the reentrancy guard after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> prolongates the wait by the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.IncomingDontProlongate">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread under the reentrancy guard after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> does not change the initial deadline, unlike <see cref="M:JetBrains.Threading.GroupingEvent.FireIncoming"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Interval">
            <summary>
            The interval within which the incoming events are grouped before the outgoing event fires and the action is executed.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Name">
            <summary>
            Identifier for this event.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEvent.Outgoing">
            <summary>
            The outgoing event. Executed on the primary thread (if <code>GroupingEventHost.IsGuarded</code>, then under a <see cref="T:JetBrains.Threading.ReentrancyGuard"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.CancelIncoming">
            <summary>
            If there were incoming firings for which there was no outgoing firing yet, cancels that outgoing firing.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty">
            <summary><seealso cref="M:JetBrains.Threading.GroupingEvent.IsWaiting"/>
            Creates a property that tells whether the event is currently waiting for grouped execution.
            This method is not thread-safe.
            The property firings are free-threaded.
            </summary>
            <remarks>Lazy-creates the property so that the event resources are not spent if it's not needed.</remarks>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.FireIncoming">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread (if <code>GroupingEventHost.IsGuarded</code>, then under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>) after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> prolongates the wait by the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.FireIncomingDontProlongate">
            <summary>
            <para>Fires the incoming event. May be called on any thread.</para>
            <para>Causes the action to execute on the primary thread (if <code>GroupingEventHost.IsGuarded</code>, then under the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>) after the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> elapses. Calling this function again within the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> does not change the initial deadline, unlike <see cref="M:JetBrains.Threading.GroupingEvent.FireIncoming"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.IsWaiting">
            <summary><seealso cref="M:JetBrains.Threading.GroupingEvent.CreateIsWaitingProperty"/>
            <para>Checks whether the event has incoming firings for which there were no outgoing firings yet, ie is waiting for the <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> to elapse or for the reentrancy guard to allow the execution (if <code>GroupingEventHost.IsGuarded</code>) after it elapses.</para>
            <para>When the user action starts executing, gets <c>False</c> until there's the next icoming firing.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.Execute">
            <summary>
            Called by the host on the primary thread to fire the action.
            Must be already guarded, if needed by <code>GroupingEventHost.IsGuarded</code>.
            Must not throw out.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.IsExpired(System.Int64)">
            <summary>
            Gets whether the event has expired waiting for the outgoing firing.
            This means there were no outgoing firings after the incoming firing, and at least an <see cref="P:JetBrains.Threading.GroupingEvent.Interval"/> has elapsed since the last incoming firing.
            </summary>
            <param name="datetimeNow">Caches the <see cref="P:System.DateTime.UtcNow"/> value, to avoid re-quering it in the loops. A 64bit integer in the <see cref="T:System.DateTime"/> format. Must be UTC!</param>
        </member>
        <member name="M:JetBrains.Threading.GroupingEvent.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHost">
            <summary>
            Manages the <see cref="T:JetBrains.Threading.GroupingEvent"/> schedulling.
            Is affined to the thread thru <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/> (even if not IsGuarded), by making the events fire on that thread only. All of the manipulations over this class (<see cref="M:JetBrains.Threading.GroupingEventHost.CreateEvent(JetBrains.Lifetimes.Lifetime,System.String,System.TimeSpan,System.Action)"/>) or the <see cref="T:JetBrains.Threading.GroupingEvent">events</see> are free-threaded.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myClockTimer">
            <summary>
            Clocks the checks for expired events.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myDebugTotalEvents">
            <summary>
            In debug mode, counts the total number of events this instance met.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myDebugTotalThroughput">
            <summary>
            In debug mode, counts the total number of event state changes, like incoming firings, outgoing firings, and cancellings.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myEvents">
            <summary>
            The events handled by this instance, both waiting and not.
            Free-threaded, must be synced with <see cref="F:JetBrains.Threading.GroupingEventHost.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myExecuteExpiredEventsLocalGuard">
            <summary>
            If not "IsGuarded" and we're not using <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>, event execution becomes reentrancy prone. Protect the <see cref="M:JetBrains.Threading.GroupingEventHost.ExecuteExpiredEvents"/> func locally in this case.
            Not used when "IsGuarded".
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myIsWaitingOnReentrancyGuard">
            <summary>
            When timeout expires on any of the events, we try taking the reentrancy guard to execute it.
            This is <c>True</c> while we're waiting for the async or sync reega call.
            Primary-thread only.
            N/a if not "IsGuarded".
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myLock">
            <summary>
            Protects the <see cref="F:JetBrains.Threading.GroupingEventHost.myEvents"/> access.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.myWatchdogEvent">
            <summary>
            A dummy event of the maximum inteval.
            The event is incoming-fired whenever any other live event fires, and keeps the clock alive until expires.
            This makes sure the timer is not constantly switched on and off (which means marshalling).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.#ctor(JetBrains.Lifetimes.Lifetime,System.Boolean)">
            <summary>
            Creates the new host for the groping events that group multiple incoming signals into one outgoing signal that occurs with a limited frequency.
            </summary>
            <param name="lifetime">Host lifetime.</param>
            <param name="isGuarded">Whether the outgoing action executions should be guarded by the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.</param>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard">
            <summary>
            Identifies the hosts's primary thread.
            If non-<c>Null</c>, guards the execution of all the outgoing actions.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.Dispatcher">
            <summary>
            Identifies the hosts's primary thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.CreateEvent(JetBrains.Lifetimes.Lifetime,System.String,System.TimeSpan,System.Action)">
             <summary>
             Creates and registers a new grouping event.
             </summary>
            <param name="lifetime">Lifetime for the event object.</param>
            <param name="name">A name to identify the event.</param>
             <param name="interval">The grouping interval. The incoming events are grouped until there's a pause of the <paramref name="interval"/> length, and after that the outgoing event is fired. The interval must be not above <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</param>
            <param name="FFirstHandler">Optional. The first handler for the <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> signal. Others could be advised on the signal object proper. Using this param avoids creating the signal object, and is preferrable in simple cases.</param>
            <returns>The event on which the incoming events can be fired. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.AddEvent(JetBrains.Threading.GroupingEvent)">
            <summary>
            Registers a new event on the host.
            Free-threaded.
            Must not be called on already-added events.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.OnDeadlineChanged(JetBrains.Threading.GroupingEvent)">
            <summary>
            There was an incoming firing on one of the events, or a waiting event has been cancelled.
            Anyway, its deadline has changed and we must accomodate the schedulle.
            Free-threaded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.RemoveEvent(JetBrains.Threading.GroupingEvent)">
            <summary>
            Unregisters an event from the host.
            Free-threaded.
            Safe to call more than once (on unregistered events).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.ExecuteExpiredEvents">
            <summary>
            Executes any events that are currently in the expired state.
            Must be run under the <see cref="F:JetBrains.Threading.GroupingEventHost.ReentrancyGuard"/>, if "IsGuarded".
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.OnClockTimerTick">
            <summary>
            The clock signal has fired.
            Check if there's anything to execute.
            Primary thread.
            Safe to throw.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHost.ClockTimer">
            <summary>
            The timer that clocks the checks-for-execution.
            Supports free-threaded IsEnabled.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.Interval">
            <summary>
            Default clock period.
            A value less than 50ms approx means we will be called each time the Thread Message Queue gets empty.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myLifetime">
            <summary>
            We use this to track whether we've been disposed of.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsEnabledDesiredState">
            <summary>
            What we want to do to the timer. The immediate value set by <see cref="P:JetBrains.Threading.GroupingEventHost.ClockTimer.IsEnabled"/> from any thread.
            After marshalling to the UI thread, applies to the timer.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsMarshalling">
            <summary>
            True while there's a pending <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> running. 
            We should avoid posting multiple simultaneous marshalling requests.
            The <see cref="F:JetBrains.Threading.GroupingEventHost.ClockTimer.myIsEnabledDesiredState"/> is not enough an indication, as it might be changed back and forth while a marshalling is in progress.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.GroupingEventHost.ClockTimer.IsEnabled">
            <summary>
            Controls the enabled state of the timer.
            Free-threaded.
            Will not pump.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.ClockTimer.OnTimerTick(System.Object,System.EventArgs)">
            <summary>
            The internal timer has ticked. Tick the clock.
            Primary thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHost.ClockTimer.IsEnabled_MarshalNewValue">
            <summary>
            Applies the new IsEnabled value offstack. Reason: (1) switch to the right thread; (2) timer would pump and execute an arbitrary number of activities when chaning enabled state, so don't do it under the caller's stack (there's no hurry).
            </summary>
        </member>
        <member name="T:JetBrains.Threading.GroupingEventHosts">
            <summary>
            Exposes grouping event hosts for various possible guarding modes.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GroupingEventHosts.CreateEvent(JetBrains.Lifetimes.Lifetime,System.String,System.TimeSpan,JetBrains.Threading.Rgc,System.Action)">
             <summary>
             Creates and registers a new grouping event.
             </summary>
            <param name="lifetime">Lifetime for the event object.</param>
            <param name="name">A name to identify the event.</param>
             <param name="interval">The grouping interval. The incoming events are grouped until there's a pause of the <paramref name="interval"/> length, and after that the outgoing event is fired. The interval must be not above <see cref="F:JetBrains.Threading.GroupingEvent.MaxInterval"/>.</param>
            <param name="guarding">Whether the execution of the event's output signal should be guarded. Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
            <param name="FFirstHandler">Optional. The first handler for the <see cref="P:JetBrains.Threading.GroupingEvent.Outgoing"/> signal. Others could be advised on the signal object proper. Using this param avoids creating the signal object, and is preferrable in simple cases.</param>
            <returns>The event on which the incoming events can be fired. Must be disposed of.</returns>
        </member>
        <member name="P:JetBrains.Threading.GroupingEventHosts.Item(JetBrains.Threading.Rgc)">
            <summary>
            Retrieves the host for a particular guarding option.
            </summary>
            <param name="guarding">Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
        </member>
        <member name="T:JetBrains.Threading.GuardAttribute">
            <summary>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an outer world method.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.GuardAttribute.#ctor(JetBrains.Threading.Rgc)">
            <summary>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an outer world method.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.Rgc">
            <summary>
            <c>ReentrancyGuardContext</c>
            Defines the guarded context affinity of the method: whether it expects to be always executed in a guarded context, or is considered an outer world method.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.NotSpecified">
            <summary>
            There is no information regarding guarded context affinity yet.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Guarded">
            <summary>
            Must be guarded from reentrancy. Make sure to either take a <see cref="T:JetBrains.Threading.ReentrancyGuard"/> or call it from the guarded context.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Unguarded">
            <summary>
            Assumed to be executed in the outer world and must tage a <see cref="T:JetBrains.Threading.ReentrancyGuard"/> before calling any <see cref="F:JetBrains.Threading.Rgc.Guarded"/> things.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Invariant">
            <summary>
            Does not deal with <see cref="F:JetBrains.Threading.Rgc.Guarded"/> entities and can thus be used both in guarded and unguarded contexts.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.Rgc.Special">
            <summary>
            Neither <see cref="F:JetBrains.Threading.Rgc.Guarded"/> nor <see cref="F:JetBrains.Threading.Rgc.Unguarded"/> nor <see cref="F:JetBrains.Threading.Rgc.Invariant"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentracyGuardDiagnosticSettings">
            <summary>
            Statically switched on/ off diagnistic settings for <see cref="T:JetBrains.Threading.ReentrancyGuard"/>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentracyGuardDiagnosticSettings.PerformanceAssertionSettings.InterruptableActivityCookieThresholdInMilliseconds">
            <summary>
            When guarded activity runs more than this threshold <see cref="M:JetBrains.Application.InterruptableActivityCookie.CheckAndThrow(JetBrains.Application.Progress.IProgressIndicator)"/> will throw
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentracyGuardDiagnosticSettings.PerformanceAssertionSettings.GuardedActionExecutionThresholdInMilliseconds">
            <summary>
            When guarded activity runs more than this threshold error will be logged
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentracyGuardDiagnosticSettings.PerformanceAssertionSettings.PumpingCheckIntervalInMilliseconds">
            <summary>
            How frequently BeginInvoke should be called to check if there is pumping while guarded execution
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentracyGuardDiagnosticSettings.PerformanceAssertionSettings.IsEnabled">
            <summary>
            Whether assertions are enabled
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost">
            <summary>
            Manages the timed deferred actions, optionally protecting their execution with the <see cref="T:JetBrains.Threading.ReentrancyGuard"/>.
            Makes sure that the action can be canceled even if it's pending on the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/> queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myGeneration">
            <summary>
            A generation is increased each time the application is deactivated. After deactivation, each action can be executed at most once until the app is activated again.
            Whenever an action is executed, its generation is set to the generation of the alarm.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myReentrancyGuard">
            <summary>
            <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myTimedActions">
            <summary>
            The list of timed actions that are waiting for their deadline to come, and the actions already in the execution queue, whose deadline is <c>Null</c>.
            Main thread access only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.myTimer">
            <summary>
            Timer that is set to tick when the <see cref="F:JetBrains.Threading.TimedActionsHost.NearestDeadline"/> elapses.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.NearestDeadline">
            <summary>
            Nearest deadline of all those deadlines of the timed actions in <see cref="F:JetBrains.Threading.TimedActionsHost.myTimedActions"/> that are eligible for execution under the current conditions (application inactivity etc).
            Or <c>0</c>, if there are no eligible timed actions to execute.
            Changes to this property start/stop and edit the <see cref="F:JetBrains.Threading.TimedActionsHost.myTimer"/>.
            UTC!
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.NearestDeadlineGottenDirty">
            <summary>
            Means the <see cref="F:JetBrains.Threading.TimedActionsHost.NearestDeadline"/> has to be recalculated.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.IsApplicationActive">
            <summary>
            Gets or sets whether the application that owns the alarm is currently active.
            Recurring actions are executed once at most when the application is inactive.
            This property must be set by the external owner in the UI applications.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard">
            <summary>
            Gets the reentrancy guard for the thread this scheduller is working on.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.Dispatcher">
            <summary>
            Gets the dispatcher for the thread this scheduller is working on.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.Queue(JetBrains.Lifetimes.Lifetime,System.String,System.Action,System.TimeSpan,JetBrains.Threading.TimedActionsHost.Recurrence,JetBrains.Threading.Rgc)">
            <summary>
            Queues a timed action.
            May be called on any thread.
            </summary>
            <param name="lifetime">Limiting lifetime of the action. After the lifetime terminates, no subsequent execution is performed.</param>
            <param name="name">Name of the action.</param>
            <param name="action">Action executor.</param>
            <param name="interval">Timeout/interval.</param>
            <param name="recurrence">Whether to repeat.</param>
            <param name="guarding">Whether to guard timed actions or not. Currently, only <see cref="F:JetBrains.Threading.Rgc.Guarded"/> and <see cref="F:JetBrains.Threading.Rgc.Invariant"/> options are supported.</param>
            <returns>A token to cancel the activity.</returns>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.EligibleTimedActions">
            <summary>
            Skips those actions already in the execution queue and, if the app is inactive, those that have already executed within this inactivity period.
            Returns only those actions that are eligible for execution at some later moment, from the current point of view.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.OnTimerTick">
            <summary>
            When the timer ticks, the action whose deadline was reached are executed.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost.Recurrence">
            <summary>
            Tells apart one-time and recurring actions.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.TimedActionsHost.TimedAction">
            <summary>
            <para>The schedulling unit of the alarm.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myDeadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            <c>Null</c>, if we've reached the deadline and are now waiting for execution/executing/etc.
            UTC!
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myLastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myLock">
            <summary>
            Protects non-atomic <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.State"/>-related operations, as they might be executed from different threads.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.myQueueMembershipToken">
            <summary>
            A token of the membership in the alarm's queue, or a <see cref="F:JetBrains.DataFlow.Disposable.Empty"/> dummy.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.State">
            <summary>
            The current state of the timed action, see <see cref="T:JetBrains.Threading.TimedActionsHost.TimedAction.States"/> for details.
            First states might be set on a foreign thread.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline">
            <summary>
            The deadline date/time, if we're currently waiting for the deadline.
            <c>Null</c>, if we've reached the deadline and are now waiting for execution/executing/etc.
            UTC!
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.GottenDirty">
            <summary>
            Fires when the timed-action state changes and the common deadline timer has to be recalculated.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.LastExecutedGeneration">
            <summary>
            When the action executes, this is set to the current generation of the alarm.
            Allows to track whether the action has executed since the last application deactivation, or not.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.TimedActionsHost.TimedAction.Name">
            <summary>
            The user-supplied action name.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.BeginExecute(System.UInt32)">
            <summary>
            After waiting on the alarm timer queue in <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>, starts waiting on the reentrancy guard.
            Called by the alarm queue when the <see cref="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline"/> comes.
            Places self on the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/>. Must not exec the action on this stack, must <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})">
            <summary>
            Called on the guarded thread as soon as possible after creating the action.
            Transitions from <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling"/> to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>.
            Adds itself to the alarm queue, if not cancelled yet (atomically).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Execute">
            <summary>
            After waiting on the reentrancy guard in <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy"/>, executes the action actually.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Reschedulle">
            <summary>
            Schedulles the deadline for the action.
            Free-threaded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.CompareTo(JetBrains.Threading.TimedActionsHost.TimedAction)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the other parameter.Zero This object is equal to other. Greater than zero This object is greater than other. 
            </returns>
            
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.Threading.TimedActionsHost.TimedAction.Terminated">
            <summary>
            Cancels the timed action.
            Might be called on any thread
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.New">
            <summary>
            The action has just been created. It has not been returned to the user or added to the queue.
            Transites into <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Marshalling">
            <summary>
            The action has been fully created, but has not been added to the queue.
            If created on the guarded thread, this immediately transitions into <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/> by the <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})"/> method.
            If created on a foreign thread, the action is returned to the user and can be either cancelled (with <see cref="M:System.IDisposable.Dispose"/>, transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>) or added to the queue (by <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.MarshallingComplete(JetBrains.DataFlow.ICollectionEvents{JetBrains.Threading.TimedActionsHost.TimedAction})"/>, transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer">
            <summary>
            Waiting for the <see cref="P:JetBrains.Threading.TimedActionsHost.TimedAction.Deadline"/> to come on the alarm queue. Accepts <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.BeginExecute(System.UInt32)"/> (transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy"/>) or <see cref="M:System.IDisposable.Dispose"/> (to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingReentrancy">
            <summary>
            Deadline has come. Waiting when the <see cref="P:JetBrains.Threading.TimedActionsHost.ReentrancyGuard"/> allows us to run.
            <see cref="M:JetBrains.Threading.TimedActionsHost.TimedAction.Execute"/> transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Executing"/>.
            <see cref="M:System.IDisposable.Dispose"/> transitions to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Executing">
            <summary>
            The action is running. Too late to cancel.
            When thru, transitions either to <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead"/> (one-time) or <see cref="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.WaitingTimer"/> (recurring).
            </summary>
        </member>
        <member name="F:JetBrains.Threading.TimedActionsHost.TimedAction.States.Dead">
            <summary>
            Either the action has been cancelled, or a one-time action has executed. Terminal state.
            Removes itself from the queue, if any.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard">
            <summary>
            A reentrancy guard that prevents controlled actions from running one on top of another.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myDefaultExternalDriverExecutionLimit">
            <summary>
            The number of actions to be executed in a row in response to the external driver call to <see cref="M:JetBrains.Threading.ReentrancyGuard.PumpQueue(System.Int32)"/>, unless overridden in the function arguments.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.OptionQueueReasonableSizeThresholdMask">
            <summary>
            Report an exception when the queue reaches this limit. Shouldn't be stacking these many actions on the queue.
            This limit is a full-ones mask, and it should not be much above the limit of the dispatcher, <see cref="F:JetBrains.Threading.JetDispatcher.OptionQueueReasonableSizeLimit" />, because if the guard is oversized, the dispatcher would typically also be overly full, but won't provide details on which actions are stacked in the guard.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myInstance">
            <summary>
            The per-thread guard instance.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myDispatcher">
            <summary>
            A dispatcher that identifies the guarded thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myExecutionStack">
            <summary>
            While executing an action, the reentrancy constraint can be lifted and another action executed.
            The executions and liftings thus form a stack.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myQueueActions">
            <summary>
            Actions that are coming through the <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> method.
            Added from any thread, peeked/removed from the UI thread.
            
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myIsExecutePendingActionsFromIsExecutingFallingSchedulled">
            <summary>
            See <see cref="M:JetBrains.Threading.ReentrancyGuard.BeginInvokeExecutePendingActions(System.Boolean)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.myTraces">
            <summary>
            Lazy-created. Main thread modifications only.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.#ctor">
            <summary>
            Constructs an instance for the current thread, on first request to <see cref="P:JetBrains.Threading.ReentrancyGuard.Current"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.Current">
            <summary>
            <para>Gets or creates a reentrancy guard for the current thread.</para>
            <para>Take caution if your code might execute on other threads. In these cases you might want to explicitly take the Guard for the desired thread instead of using <see cref="P:JetBrains.Threading.ReentrancyGuard.Current"/>.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow">
            <summary>
            Tells whether the guard can execute actions at this moment, which means there's no action currently executing. Readonly.
            </summary>
            <seealso cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.CurrentActionName">
            <summary>
            <para>Gets a readonly property that tells the name of the current action (an execution or a lifting of the reentrancy constraint, see <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>), or <c>Null</c> if neither is present.</para>
            <para>This is always non-<c>Null</c> when <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/>, but could be also non-<c>Null</c> when not <see cref="P:JetBrains.Threading.ReentrancyGuard.IsExecuting"/> (if <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> was called).</para>
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.Dispatcher">
            <summary>
            Gets the dispatcher for the thread guarded by this instance.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.IsEmpty">
            <summary>
            Gets whether there are no pending actions on the Reentrancy Guard queue.
            All of the deferred actions go through this queue.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.IsExecuting">
            <summary>
            <para>Gets whether a reentrant-safe execution is currently in progress.</para>
            <para>If <c>True</c>, then <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/> is <c>False</c>.</para>
            <para>As the <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> method that lifts the guard, this flag falls and only becomes <c>True</c> when an execution, not lifting, is on top of the executions stack.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)">
            <summary>
            When under an <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)" /> reentrancy guard, temporarily lifts the reentrancy constraints and allows other <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)" /> to be called, as if there were no executions on the stack.
            This function can be called under execution only.
            </summary>
            <param name="name">A name that identifies this constraint lifting.</param>
            <param name="action">The activity to be executed with the constraint lifted.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AssertGuarded">
            <summary>
            Checks that the activity is executed on the proper thread and is being guarded from reentrancy.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)">
            <summary>
              <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow" />, executes the <paramref name="action" /> immediately and synchronously.</para>
              <para>Otherwise, throws an exception and doesn't execute or queue the action.</para>
              <para>Throws exceptions on fatal errors, traps exceptions from the <paramref name="action" /> proper.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Execute``2(System.String,``0,System.Func{``0,``1})">
            <summary>
              <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow" />, executes the <paramref name="func" /> immediately and synchronously.</para>
              <para>Otherwise, throws an exception and doesn't execute or queue the action.</para>
              <para>Throws exceptions on fatal errors, traps exceptions from the <paramref name="func" /> proper.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="func">The function to execute. Exceptions will be trapped.</param>
            <param name="state">Extra state to pass in functon to eliminate closures.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              <para>Executes an action on the guarded thread in a reentrant-safe manner.</para>
              <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)" />.</para>
              <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)" /> does.</para>
            </summary>
            <param name="name">Identifies the action in the queue.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="priority"></param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)" />-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.PumpQueue(System.Int32)">
            <summary>
            Causes the internal guard actions queue to pump, and actions to execute.
            The function must be called under good conditions (<see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow" />).
            </summary>
            <param name="limit">The maximum number of actions to execute, or <c>0</c> for the default internal value.</param>
            <returns>The number of actions actually executed.</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
              <para>Queues the action to execute asynchronously on the guarded thread, as soon as possible.</para>
              <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="name">Identifies the action in the queue.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
            <param name="priority"></param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)">
            <summary>
            <para>If called on the guarded thread and <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/>, executes the <paramref name="action"/> immediately and synchronously and returns <c>True</c>.</para>
            <para>Otherwise, immediately returns <c>False</c> and doesn't execute or queue the action.</para>
            </summary>
            <param name="name">Identifies the action being executed.</param>
            <param name="action">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ReportOversizedQueue">
            <summary>
            Emits diagnostics if there're too many queued items.
            That happens when the size is any multiple of the threshold, defined as <see cref="F:JetBrains.Threading.ReentrancyGuard.OptionQueueReasonableSizeThresholdMask" /><c> + 1</c>.
            Note that this call might happen on any thread, so the size at the moment of the report is not necessarily equal to the threshold.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AddExceptionData(System.Exception)">
            <summary>
            Dumps state for an exception.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.AssertCanExecute(System.String)">
            <summary>
            Check that thread-affinity and reentrancy conditions allow us to execute an action right now.
            </summary>
            <param name="name">Action name, for error-reporting.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.BeginInvokeExecutePendingActions(System.Boolean)">
            <summary>
            A method that schedulles execution of the actions queue.
            Called when <see cref="P:JetBrains.Threading.ReentrancyGuard.CanExecuteNow"/> comes true or from within <see cref="M:JetBrains.Threading.ReentrancyGuard.Queue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.
            Can be called on any thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutePendingActions">
            <summary>
            Executes the pending actions on the guarded thread, if possible.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.ExecutionStack">
            <summary>
            Encapsulates the stack of executions and reentrancy liftings.
            Supposed number of items: less than 10.
            Main-thread-only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myCurrentActionName">
            <summary>
            Backend for <see cref="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.CurrentActionName"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myIsExecuting">
            <summary>
            Backend for <see cref="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecuting"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.myStack">
            <summary>
            Storage for executions and liftings.
            An execution is added with <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>, and a lifting with <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/>. An execution prevents other executions, and a lifting allows them.
            An execution can only be added into an empty stack or on top of a lifting, and a lifting can only be added on top of an execution.
            Thus, the bottom of the stack and every even-indexed item is an execution, and every odd-indexed item is a lifting.
            Thread safety: changes only on the home thread (remember, this is the execution stack, not the actions queue). Safe to read on the home thread only. Lock-free.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.CurrentActionName">
            <summary>
            The name of the execution or lifting currently active (on top of the execution stack), or <c>Null</c> if there's none such.
            </summary>
            <remarks>
            This property could be evaluated on demand, but this is not thread-safe, so we make a copy in a thread-safe context (execution stack is only modified on the home thread).
            </remarks>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecuting">
            <summary>
            Tells whether an execution is currently in progress.
            This means that the stack is not empty (an <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/> is running), and the execution guard has not been lifted with <see cref="M:JetBrains.Threading.ReentrancyGuard.AllowNestedExecution(System.String,System.Action)"/> since the last <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>.
            </summary>
            <remarks>
            Technically, tells whether the number of items in the stack is even.
            This property could be evaluated on demand, but this is not thread-safe, so we make a copy in a thread-safe context (execution stack is only modified on the home thread).
            </remarks>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.IsExecutingFalling">
            <summary>
            Event.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.PopExecution(System.String)">
            <summary>
            Removes a recorded execution from the stack.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.PushExecution(System.String,JetBrains.Threading.ReentracyGuardDiagnosticSettings.PerformanceAssertionSettings)">
            <summary>
            Records an execution on the stack.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
            <param name="performanceAssertionSettings"></param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.AddLifting(System.String)">
            <summary>
            Records a reentrancy constraint lifting on the stack, removes upon retval disposal.
            Home thread only.
            </summary>
            <param name="name">Item name.</param>
            <remarks>Note: PushExecution has been broken into Push/Pop to avoid creating the disposable object. A lifting is a much rarer thing, let's keep the safer code here.</remarks>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.RemoveLifting(System.String)">
            <summary>
            Pairing func to <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.AddLifting(System.String)" />.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1">
            <summary>
            A stack data structure with events, lite version (compared to <see cref="T:JetBrains.DataFlow.CollectionEvents`1"/> and others), without interlocking.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.AddRemove">
            <summary>
            Fires when an add/remove operation is performed on the storage.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Count">
            <summary>
            Gets the number of items in the stack.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Add(`0)">
            <summary>
            Adds an item to the stack. Updates the properties.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.Remove(`0)">
            <summary>
            Removes an item from the stack. Updates the properties.
            </summary>
            <param name="item">Ensures that we removed exactly the same name we added (valid bracket structure).</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.TryGetLast">
            <summary>
            Peeks the item on top of the stack. <c>Null</c> if empty.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.ExecutionStack.StackEventsLite`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.InterlockedQueue">
            <summary>
            Encapsulates the queue in a thread-safe manner.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myLock">
            <summary>
            Lock for protecting the data structure.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myStorage">
            <summary>
            The internal storage. Must be protected by <see cref="F:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.myLock"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.IsEmpty">
            <summary>
            Gets whether the queue currently has no items in it.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.Enqueue(JetBrains.Threading.ReentrancyGuard.QueuedAction)">
            <summary>
            Adds an item to the end of the queue.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.TryDequeue(System.Action{JetBrains.Threading.ReentrancyGuard.QueuedAction})">
            <summary>
            Removes the first item in the queue. Does not throw if the queue is empty.
            Thread-safe.
            <param name="funcVisitor">A handler that will be executed on the removed item, in case there were any items in the queue.</param>
            </summary>
            <returns>Whether the queue was not empty and anything were executed.</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.InterlockedQueue.GetQueuedActionNames">
            <summary>
            Diagnostics. Dumps the RG queue.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext">
            <summary>
            A synchro-context to be set on the thread while executing the no-reentrancy action.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.#ctor">
            <summary>
            Attaches to the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.#ctor(JetBrains.Threading.JetDispatcher)">
            <summary>
            Attaches to some given thread (needed for <see cref="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.CreateCopy"/>).
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Push">
            <summary>
            Pushes/pops the context on the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.CreateCopy">
            <summary>
            Clone.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Use the dispatcher.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.NoReentrancySynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Use the dispatcher.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuard.QueuedAction">
            <summary>
            Implements a data item that waits on the queue.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.QueuedAction.Action">
            <summary>
            The method to execute.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuard.QueuedAction.Name">
            <summary>
            User-assigned name of the action.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuard.QueuedAction.ToString">
            <summary>
            Returns the fully qualified type name of this instance.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> containing a fully qualified type name.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Reclaims the queueing and cancels the action from executing when the lifetime ends.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="priority">Priority.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Reclaims the queueing and cancels the action from executing when the lifetime ends.</para>
            <para>The reentrancy between guarded actions is prevented.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="priority">Priority.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueueOrRunSync(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="priority">Priority.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueueOrRunSync(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.ExecuteOrQueueOrRunSync(JetBrains.Threading.ReentrancyGuard,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Executes an action on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>.</para>
            <para>If called on a foreign thread, executes the action asynchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>If called on the guarded thread, checks for reentrancy. If there are no guarded executions on the stack yet, executes the action immediately and synchronously, like <see cref="M:JetBrains.Threading.ReentrancyGuard.Execute(System.String,System.Action)"/>. Otherwise, postpones the action for asynchronous execution, like <see cref="M:JetBrains.Threading.ReentrancyGuardEx.Queue(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> does.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="ths"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="priority">Priority.</param>
            <returns><c>True</c> if executed immediately, <c>False</c> if queued (<see cref="M:JetBrains.Threading.ReentrancyGuard.TryExecute(System.String,System.Action)"/>-compatible behavior).</returns>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardEx.QueueOrRunSync(JetBrains.Threading.ReentrancyGuard,JetBrains.Lifetimes.Lifetime,System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            <para>Queues the action to execute asynchronously on the <see cref="P:JetBrains.Threading.ReentrancyGuard.Dispatcher"/> thread in a <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see>, as soon as possible. Reclaims the queueing and cancels the action from executing when the lifetime ends.</para>
            <para>If Async behavior is prohibited, like in test environment, always executes synchronously.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime"></param>
            <param name="name">The name for the task.</param>
            <param name="F">The action to execute. Exceptions will be trapped.</param>
            <param name="priority">Priority.</param>
        </member>
        <member name="T:JetBrains.Threading.ReentrancyGuardTimer">
            <summary>
            A timer that executes its activities under a reentrancy guard and (optionally) suspends the activity when the application is inactive, after executing the action once.
            This class must be disposed of.
            Can be used on the primary thread only.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.InactiveExecutionTime">
            <summary>
            When the <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.Tick"/> event is about to fire, is set to <see cref="P:System.DateTime.Now"/> if the app is inactive, or to a <c>Null</c> value if the app is active.
            Helps with the app-inactivity execution conditions: stop after first time inactive, fire if missed an execution when get active.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsNotWaitingTimer">
            <summary>
            Raised when we're not waiting for the timer event, but sitting on the <see cref="T:JetBrains.Threading.ReentrancyGuard"/> queue or executing.
            In this state, the new timer events are ignored to avoid parallel execution.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsWinFormsTimerEnabled">
            <summary>
            Tells whether the underlying WinForms <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.myTimer"/> should be ON. Applied to the timer offstack to avoid pumping on <code>Timer.Stop</code>.
            Is composed from all the states: <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled"/>, <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive"/>, <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.InactiveExecutionTime"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.myReentrancyGuard">
            <summary>
            Identifies the owning thread.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.myTimer">
            <summary>
            The timer implementation.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.Interval">
            <summary>
            Gets or sets the timer interval.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive">
            <summary>
            Allows to suspend the timer execution when application gets inactive.
            It's different from <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled"/> in that after <see cref="F:JetBrains.Threading.ReentrancyGuardTimer.IsApplicationActive"/> falls, the action executes once more until the timer is suspended. When the application gets back active, if the action execution was missed, it's executed immediately.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.IsEnabled">
            <summary>
            Gets or sets whether the timer is currently enabled.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ReentrancyGuardTimer.Name">
            <summary>
            The name of this instance.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.ReentrancyGuardTimer.Tick">
            <summary>
            Fires when the timer ticks, under a reentrancy guard.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.OnTimerTick">
            <summary>
            Tick of the underlying winforms timer. Unguarded.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.OnTimerTickReentrantSafe">
            <summary>
            Executes on the timer tick, but under the reentrancy guard.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Threading.ReentrancyGuardTimer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Threading.ThreadAccessException">
            <summary>
            Reports a thread access inconsistency.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ThreadAccessException.ThreadDesired">
            <summary>
            Gets the thread the action was expected to execute on. Optional.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.ThreadAccessException.ThreadWrong">
            <summary>
            Gets the thread on which the action was prevented from being executed.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.JetFastSemiReenterableRWLock">
            <summary>
            ReaderWriter lock for relatively small critical sections. Uses spinwait locks and interlocked internally, so CPU do meanless job before lock acquiring (not event-based).
            
            In JET_MODE_ASSERT:
            If thread acquires write lock it can aquire this lock read and write fashion any number of times recursively afterwards. If thread acquires readlock - it can't acquire recursively read and write lock (on this lock) any more,
            so readlock isn't reenterable.
            
            In production configuration: breach of abovementioned items can lead to deadlock.
            
            Also, locks must be released in reversed order to order they were acquired (is controlled by assertions).
            <code>UsingReadLock()</code> and <code>UsingWriteLock()</code> methods helps to follow this pattern.  
            
            </summary>
        </member>
        <member name="F:JetBrains.Threading.JetFastSemiReenterableRWLock.myState">
            <summary>
            State of this RWLock. Can be presented as sum of following:
            1) <see cref="F:JetBrains.Threading.JetFastSemiReenterableRWLock.WriteLockFactor"/> * WriterThread.ManagedThreadId - if some writer've took write lock
            2) - <see cref="F:JetBrains.Threading.JetFastSemiReenterableRWLock.ReenterLockFactor"/> * number_of_times_this_writer_lock_was_taken_recursively_either_in_write_or_read_mode  - for reentrancy, excludes the first acquiring (it is counted in 1.)
            3) - number_of_threads_acquired_read_lock (sometimes in writer mode this parameter is still present, it introduced by readers that tried to acquire read lock but were overtaken by writer) 
            
            So if state is lower than zero it means that RWLock in Read mode
            If state is greater than zero - RWLock in Write mode
            If state is zero - RWLock is free
            </summary>   
            
            
            | 32 bits - managedThreadId | 8 bits - #times lock taken reenterant | 24 bits - number of readers that take lock |
        </member>
        <member name="F:JetBrains.Threading.JetFastSemiReenterableRWLock.myAwaitingWritersCount">
            <summary>
            Number of writers that are awaiting for releasing of read locks to aquire write lock. This field is introduced only to prevent writers starvation.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.MonitorReleaseCookie">
            <summary>
            Release monitor (must acquired previosly either with <see cref="M:System.Threading.Monitor.Enter(System.Object)"/> or <code>lock</code> statement) and then reacquires it in Dispose method.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.WaitingThreadsCookie">
            <summary>
            To envelop custom wait events
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.AllowStaExecutor(JetBrains.Lifetimes.Lifetime)">
            <summary>
            This is to make sure no dispatchers are left behind and prevent appdomain from unloading.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="M:JetBrains.Threading.ThreadManager.RunSafe(System.Action)">
            <summary>
            Runs action on system thread pool (even in Tests) with guaranteed exception logging. 
            
            Use it for :
            1) IO-bound tasks if you can't rewrite them in async way (via TaskCompletionSource)
            2) You can't get access to IThreading.TaskHost.RunSafe method (e.g. in static methods)
            3) When you need guaranteed execution in async manner with no checks of lifetimes.
            </summary>
            <param name="action">action to run on System Pool Thread</param>
        </member>
        <member name="T:JetBrains.Threading.WeakTimer">
            <summary>
            A timer that is not held on a strong reference by the system.
            If there are no more root paths to your class that owns the timer, the ticks stop automatically.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.Interval">
            <summary>
            Gets or sets the timer ticks interval.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.IsEnabled">
            <summary>
            Gets or sets whether the timer is currently running.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.Tick">
            <summary>
            Fires when the timer ticks.
            Sinking this event does not hold you on a permanent GC root.
            </summary>
        </member>
        <member name="F:JetBrains.Threading.WeakTimer.myStrongTimer">
            <summary>
            This timer is held on a strong reference, but it does not hold us.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.WeakTimer.#ctor(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates the timer. If you got the lifetime, pass it in. Otherwise, could be the eternal lifetime, because the timer is held on weak ref and won't be keeping this object alive.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.WeakTimer.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Concurrency.Fiber">
            <summary>
            Implements the fibers (non-preemptive multitasking).
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.#ctor(System.Action)">
            <summary>
            Creates a new secondary fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.#ctor">
            <summary>
            Wraps the primary fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.CreateSecondaryFiber(System.Action)">
            <summary>
            Creates a new fiber to execute the <paramref name="action"/> in.
            To start execution, <see cref="M:JetBrains.Concurrency.Fiber.YieldTo"/> this fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.GetPrimaryFiber">
            <summary>
            Gets the primary fiber for this thread. It represents the main execution path of the thread.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Concurrency.Fiber.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.Fiber.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.Fiber.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow (<see cref="M:JetBrains.Concurrency.Fiber.GetPrimaryFiber"/>), rather than a specifically created coroutine (<see cref="M:JetBrains.Concurrency.Fiber.CreateSecondaryFiber(System.Action)"/>).
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.Fiber.FiberProc">
            <summary>
            Fiber proc prototype. Cannot use a generic <see cref="T:System.Action`1"/> for marshalling.
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.FiberOverThread">
            <summary>
            Manages multiple threads of execution via fiber-like API.
            </summary>
        </member>
        <member name="F:JetBrains.Concurrency.FiberOverThread._current">
            <summary>
            The current fiber for this thread, or <c>Null</c> if no active one available.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.#ctor">
            <summary>
            Primary.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.#ctor(System.Action,JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Secondary.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.CreateSecondaryFiber(System.Action,JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates a new fiber to execute the <paramref name="action"/> in.
            To start execution, <see cref="M:JetBrains.Concurrency.FiberOverThread.YieldTo"/> this fiber.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.GetPrimaryFiber">
            <summary>
            Gets the primary fiber for this thread. It represents the main execution path of the thread.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Concurrency.FiberOverThread.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.FiberOverThread.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.FiberOverThread.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow, rather than a specifically created coroutine.
            </summary>
        </member>
        <member name="T:JetBrains.Concurrency.IFiber">
            <summary>
            Common interface for various fiber incarnations.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.IFiber.IsCompleted">
            <summary>
            Whether the fiber coroutine has started running and completed its run successfully.
            A primary fiber is never considered completed, as its code has no specific end.
            </summary>
        </member>
        <member name="P:JetBrains.Concurrency.IFiber.IsPrimary">
            <summary>
            Whether this is the primary fiber, a wrapper over the thread's main execution flow, rather than a specifically created coroutine.
            </summary>
        </member>
        <member name="M:JetBrains.Concurrency.IFiber.YieldTo">
            <summary>
            Yields execution to this fiber.
            </summary>
        </member>
        <member name="T:JetBrains.UI.Application.LocalReentrancyGuard">
            <summary>
            In the local scope, prevents reentrancy with own methods only.
            Thread-safe.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LocalReentrancyGuard.TryExecute(System.Action)">
            <summary>
            Executes the action, if not yet executing another one.
            </summary>
            <param name="action">Action.</param>
            <returns>Whether the action were executed.</returns>
        </member>
        <member name="M:JetBrains.UI.Application.LocalReentrancyGuard.Execute(System.Action)">
            <summary>
            Executes the action, if not yet executing another one.
            </summary>
            <param name="action">Action.</param>
        </member>
        <member name="T:JetBrains.UI.Application.LogEventListener">
            <summary>
            Listens for <see cref="T:JetBrains.Util.Logging.Logger"/> events, reports them to the consumer.
            Prevents reentrancy in handlers.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Application.LogEventListener.myIdentity">
            <summary>
            Identity.
            ACHTUNG ACHTUNG! Special handling in Equals.
            </summary>
        </member>
        <member name="F:JetBrains.UI.Application.LogEventListener.myNoReentrancy_HasEntered">
            <summary>
            Reentrancy in these handler methods most probably means infinite recursion.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.#ctor(System.String,System.Action{JetBrains.Util.LogEvent})">
            <summary>
            Creates a listener that could be matched by its identity which prevents adding more than one instance with the same identity to the logger.
            An empty string is considered to be the unique identity.
            </summary>
        </member>
        <member name="P:JetBrains.UI.Application.LogEventListener.Identity">
            <summary>
            A listener that could be matched by its identity which prevents adding more than one instance with the same identity to the logger.
            An empty string is considered to be the unique identity.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnException">
            <summary>
            <see cref="M:JetBrains.Diagnostics.LoggingLevelEx.IsSeriousError(JetBrains.Diagnostics.LoggingLevel)"/>.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnMessage">
            <summary>
            Not <see cref="M:JetBrains.Diagnostics.LoggingLevelEx.IsSeriousError(JetBrains.Diagnostics.LoggingLevel)"/>.
            </summary>
        </member>
        <member name="E:JetBrains.UI.Application.LogEventListener.OnLogEvent">
            <summary>
            <see cref="M:JetBrains.Util.ILogEventListener.OnLogEvent(JetBrains.Util.LogEvent)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.UI.Application.LogEventListener.Equals(JetBrains.UI.Application.LogEventListener)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="T:JetBrains.Application.Progress.IProgressIndicator">
            <summary>
            <para>Given to a lengthy task that knows its progress, used to enable the UI indications of the task progress.</para>
            <para>You should read all of the member summaries before using this class.</para>
            </summary>
            <seealso cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:System.OperationCanceledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicator.TaskName">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)">
            <summary>
            <para>Advances the progress within the range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> MUST be called first.</para>
            </summary>
            <param name="units">A whole or fractional number of units from the [0..totalWorkUnits] range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> method.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> at the end. Use <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.IProgressIndicator.Stop">
            <summary>
            <para>Completes the progress run. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> if you previously called <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>.</para>
            <para>Generally, you SHOULD always call the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> pair on the given indicator, even if gotten no items to process, so that a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> could use up the parent range consistently.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.IProgressIndicatorModel">
            <summary>
            A data-only presentation of the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> state.
            While <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> is producer-oriented, the <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> is intended for consumers.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction">
            <summary>
            <para>The current position of the progress, in the [0..1] range, inclusive.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:System.OperationCanceledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning">
            <summary>
            Whether the producer thinks it's currently running. <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> SHOULD be at <c>1</c> when done running.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.ProgressIndicator">
            <summary>
            <para>A self-container progress indicator implementations.</para>
            <para><see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> should be given to producers, and the consumers make use of this instance thru its <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/>.</para>
            <para>By default, no special threading model is implied on the members. They could be modified on any thread and fire changes on any thread.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myAdvanceFactor">
            <summary>
            The factor to be applied to the "Advance" units to make them <see cref="P:JetBrains.Application.Progress.ProgressIndicator.Fraction"/> units.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Progress.ProgressIndicator.myEpsilon">
            <summary>
            Epsilon for the <see cref="T:System.Double"/> parameters of the progress.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.ReadonlyToken">
            <summary>
            An optional readonly token used by this object for accessing the <see cref="T:JetBrains.Application.Progress.IProgressIndicatorModel"/> part.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Advance(System.Double)">
            <summary>
            <para>Advances the progress within the range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> MUST be called first.</para>
            </summary>
            <param name="units">A whole or fractional number of units from the [0..totalWorkUnits] range, as defined by the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> method.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Start(System.Int32)">
            <summary>
            <para>Starts the progress to run through the [0..range] range. You MUST call <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> at the end. Use <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> to identify the current execution span, once per <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>, and change the <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> when doing <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="range">The inclusive upper limit of the progress range.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#Stop">
            <summary>
            <para>Completes the progress run. You MUST call <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> if you previously called <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>.</para>
            <para>Generally, you SHOULD always call the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>-<see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> pair on the given indicator, even if gotten no items to process, so that a <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> could use up the parent range consistently.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#CurrentItemText">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:System.OperationCanceledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicator.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.JetBrains#Application#Progress#IProgressIndicator#TaskName">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.Fraction">
            <summary>
            <para>The current position of the progress, in the [0..1] range, inclusive.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.IsCanceled">
            <summary>
            <para>Whether the activity which the progress is visualizing has been canceled externally. This could be user's clicking on the "Cancel" button of the UI the progress is bound to.</para>
            <para>You should check this property periodically and cut off the remaining activity if <c>True</c>. You MIGHT throw <see cref="T:System.OperationCanceledException"/> for that, still it's recommended not to use exceptions for flow control, but check <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsCanceled"/> on all of the levels of nesting.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.IsRunning">
            <summary>
            Whether the producer thinks it's currently running. <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> SHOULD be at <c>1</c> when done running.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.Name">
            <summary>
            <para>A title of the whole activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicator.StepName">
            <summary>
            <para>A title of the current item being processed by the activity which the progress is visualizing.</para>
            <para>You SHOULD set <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Name"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.IsRunning"/> run, and <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.StepName"/> once per <see cref="P:JetBrains.Application.Progress.IProgressIndicatorModel.Fraction"/> step, if applicable.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Progress.ProgressIndicatorBase.Fraction">
            <summary>
            Gives out the progress value as a floating point number in the [01] range.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorBase.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.Application.Progress.SlowProgressIndicator">
            <summary>
            Usefull to testing indicators progress and cancellation.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Progress.SubProgressIndicator">
            <summary>
            <para>Allows for a few tasks to share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            <para>See <see cref="M:JetBrains.Application.Progress.SubProgressIndicator.#ctor(JetBrains.Application.Progress.IProgressIndicator,System.Double,System.Boolean)"/> for details.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.SubProgressIndicator.#ctor(JetBrains.Application.Progress.IProgressIndicator,System.Double,System.Boolean)">
            <summary>
            <para>A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, which uses up only <paramref name="fUnitsInParentIndicator"/> in the parent <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.</para>
            <para>This way, a few tasks could share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
            <param name="advanceWhenNotStarted">Advance in parent progress bar on dispose</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            <para>Advances the progress by default fraction (1.0) within the range, as defined by the <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/> call.</para>
            <para><see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/> MUST be called first.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator,System.Double,System.Action{JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            <para>Advances the <paramref name="progressParent"/> by <paramref name="fUnitsInParentIndicator"/> units, while running the <paramref name="funcAdvanceSubprogress"/> task.</para>
            <para>Unlike the core <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> method, the increment goes gradually, as the <paramref name="funcAdvanceSubprogress"/> calls <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on the <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> it is given as a parameter. Note that its units are totally independent of the <paramref name="fUnitsInParentIndicator"/> in the <paramref name="progressParent"/>. Any range it chooses in its <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> will result in <paramref name="fUnitsInParentIndicator"/> advance of the parent.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
            <param name="funcAdvanceSubprogress">The subtask that gets its own subprogress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator,System.Double)">
            <summary>
            <para>A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, which uses up only <paramref name="fUnitsInParentIndicator"/> in the parent <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.</para>
            <para>This way, a few tasks could share the full progress range without knowing that they're using it together, each one running the whole length of its subprogress.</para>
            </summary>
            <param name="progressParent">The parent progress.</param>
            <param name="fUnitsInParentIndicator">The number of units used up from the <paramref name="progressParent"/>, in terms of its parent <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>, when you do <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> on this subprogress with any units of your liking.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
              <para>
                A sub-routine runs the whole <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>
                run on the subprogress, with units of its own choice in <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and
                <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/> on the subprogress, in terms of its parent
                <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Advance(System.Double)"/>.
              </para>
              <para>
                This way, a few tasks could share the full progress range without knowing that they're using it together,
                each one running the whole length of its subprogress.
              </para>
            </summary>
            <param name="progressParent">The parent progress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.AdvanceNested(JetBrains.Application.Progress.IProgressIndicator,System.Double)">
            <summary>
            Unlike <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator,System.Double)"/> this implementation
            advances parent progress on dispose, even when Start was never called.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.AdvanceNested(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Unlike <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSubProgress(JetBrains.Application.Progress.IProgressIndicator,System.Double)"/> this implementation
            advances parent progress on dispose, even when Start was never called.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSlowIndicator(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Returns slowed down progress indicator that is useful to test progress and cancellation support.
            Total progress duration is 10 seconds.
            </summary>
            <param name="progressIndicator">The parent progress to wrap.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.CreateSlowIndicator(JetBrains.Application.Progress.IProgressIndicator,System.TimeSpan)">
            <summary>
            Returns slowed down progress indicator that is useful to test progress and cancellation support.
            </summary>
            <param name="progressIndicator">The parent progress to wrap.</param>
            <param name="timeSpan">Total progress duration.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgressImpl``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{JetBrains.Application.Progress.IProgressIndicator,``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{``0,JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Action{``0,JetBrains.Application.Progress.IProgressIndicator})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Boolean,System.Action{``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.ForEachWithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Action{``0})">
            <summary>
            A LINQ-like FOREACH with progress.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,System.String,System.String},System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgress2``1(System.Collections.Generic.IReadOnlyCollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,System.String,System.String},System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgressForEvery``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,System.String,System.String},System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithProgressForEvery2``1(System.Collections.Generic.IReadOnlyCollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,System.String,System.String},System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.WithSubProgress``1(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.Double,System.String,System.Boolean)">
            <summary>
            Wraps sequence such that iteration over returned enumerable increases progress indicator.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.SelectWProgress``2(System.Collections.Generic.ICollection{``0},JetBrains.Application.Progress.IProgressIndicator,System.String,System.Func{``0,``1})">
            <summary>
            A LINQ-like SELECT statement with progress.
            Works on <see cref="T:System.Collections.Generic.ICollection`1"/>, returns a committed <see cref="T:System.Collections.Generic.List`1"/>.
            </summary>
            <typeparam name="TSource">Source item types.</typeparam>
            <typeparam name="TResult">Resulting item types.</typeparam>
            <param name="source">Source items.</param>
            <param name="progress">The progress to track the source items iteration.</param>
            <param name="taskName">Name for the progress run.</param>
            <param name="selector">Selector function.</param>
            <returns>The resulting items.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range. You MUST call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/> at the end. Use <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Start(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <param name="sTaskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartProgress(JetBrains.Application.Progress.IProgressIndicator,System.Int32)">
            <summary>
            <para>Just call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and
            return the same instance of <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>.
            See <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> for details.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <returns>The same instance of IProgressIndicator in order to use fluent interface.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartProgress(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String)">
            <summary>
            <para>Just call <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and return the same instance of <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/>. See <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> for details.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="taskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <returns>The same instance of IProgressIndicator in order to use fluent interface.</returns>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.StartStop(JetBrains.Application.Progress.IProgressIndicator,System.Int32,System.String,System.Action)">
            <summary>
            <para>Starts the progress to run through the [0..totalWorkUnits] range, executes <paramref name="action"/>, and then stops the progress. Use <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to move the progress across the range.</para>
            <para>Generally, you SHOULD set the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> to identify the current execution span, once per <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/>-<see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>, and change the <see cref="P:JetBrains.Application.Progress.IProgressIndicator.CurrentItemText"/> when doing <see cref="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.Advance(JetBrains.Application.Progress.IProgressIndicator)"/> to comment on the progress.</para>
            <para>If you would like to delegate a sub-range to a nested routine, you SHOULD create a <see cref="T:JetBrains.Application.Progress.SubProgressIndicator"/> and pass the resulting <see cref="T:JetBrains.Application.Progress.IProgressIndicator"/> to the routine, so that it ran a whole range from its point of view, which would then map to a sub-range of this progress indicator.</para>
            </summary>
            <param name="progress">Progress indicator.</param>
            <param name="totalWorkUnits">The inclusive upper limit of the progress range.</param>
            <param name="taskName">The <see cref="P:JetBrains.Application.Progress.IProgressIndicator.TaskName"/> value to be set for the run. You SHOULD NOT leave it unmodified, unless you are running a subprogress.</param>
            <param name="action">The task to execute in between <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Start(System.Int32)"/> and <see cref="M:JetBrains.Application.Progress.IProgressIndicator.Stop"/>.</param>
        </member>
        <member name="M:JetBrains.Application.Progress.ProgressIndicatorExtensions.PumpForSingleThreadedTasks(JetBrains.Application.Progress.IProgressIndicatorModel,JetBrains.Lifetimes.Lifetime,System.Func{System.Boolean},System.Int32)">
             <summary>
             When a single-threaded task manipulates its progress, pump Windows messages to make sure the UI is not stuck (also required to let the progress window show onscreen).
             NOTE: the interruptable cookie we're pushing onstack would be pumping also, but it does not have effect on non-interruptable-read-activity-like tasks, e,g. in DotTrace
             </summary>
            <param name="millisecondsPumpInterval">
             Interval between pumping Windows messages (check every nCallsBetweenChecks only)
             Pump Windows messages only when running on the same thread as the UI; otherwise, they'll be pumped by the waiting code
             </param>
             <param name="mainThreadCheck">
             Thread check: must do pumps on the main thread only
             Why not needed on other threads: we need this pumping to unfreeze UI when executing task right on the same thread, other threads are usually worker threads and they don't care
             Why dangerous on other threads: other threads are usually worker threads and they might not have a message queue.
             Pumping would create one, and the thread might cause a Windows Message broadcaster to get stuck while waiting for a response from such a thread.
             </param>>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.ITaskHost">
            <summary>
            Entry point for JetBrains concurrency. All basic schedulers are located here.
            Note that this class should be used only in platform code. For features please use extension methods of lifetimes from <c>ShellLifetimes</c> class 
            </summary>
            <remarks>
            If you haven't found scheduler you want please also consider
            <see cref="T:JetBrains.Collections.Viewable.SynchronousScheduler"/>, <see cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler"/> or
            <c>PsiFiles.OnCommitBackgroundReadLockScheduler</c>
            </remarks>
            <seealso cref="T:JetBrains.Application.Threading.Tasks.Scheduling"/>
            <seealso cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler"/>
            <seealso cref="T:JetBrains.Collections.Viewable.SynchronousScheduler"/>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler">
            <summary>
            JetPool scheduler.    
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.Factory">
            <summary>
            Factory of all task. Can be used to obtain functionality such as <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAll(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task[]})"/>,
            <see cref="M:System.Threading.Tasks.TaskFactory.ContinueWhenAny(System.Threading.Tasks.Task[],System.Action{System.Threading.Tasks.Task})"/>    
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.UnguardedMainThreadScheduler">
            <summary>
            Non-guarded execution on main thread (and thus it takes no read lock).
            This scheduler does not use a guard, so it's invariant to whether some guarded activity is being executed on the main thread at the moment. You might be running when there is no guard, or in the middle of somebody else's guarded execution.
            <exception cref="T:JetBrains.Diagnostics.Assertion.AssertionException">Thrown when there is no UnguardedMainThreadScheduler</exception>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.GuardedMainThreadScheduler">
            <summary>
            Guarded execution on main thread under read lock.
            <exception cref="T:JetBrains.Diagnostics.Assertion.AssertionException">Thrown when there is no GuardedMainThreadScheduler</exception>
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.WriteLockMainThreadScheduler">
            <summary>
            Guarded execution of action on main thread under write lock.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.UnguardedMainThreadSchedulerIfPresent">
            <summary>
            Unguarded execution on main thread.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.GuardedMainThreadSchedulerIfPresent">
            <summary>
            Guarded execution on main thread under read lock.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.ITaskHost.SystemThreadPool">
            <summary>
            System thread pool: <see cref="P:System.Threading.Tasks.TaskScheduler.Default"/>.
            If you expect problems with system pool starvation consider usage of
            <see cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler"/>.<see cref="F:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler.Instance"/>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Queue(JetBrains.Lifetimes.Lifetime,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with given priority
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="priority"></param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueAt(JetBrains.Lifetimes.Lifetime,System.Action,System.DateTimeOffset)">
             <summary>
             Queues <paramref name="action"/> on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay expressed by <paramref name="date"/>
            
             BUG: Captured by <paramref name="action"/> objects will not be freed until actual execution! The termination of provided lifetime will not remove the scheduled action from execution!  
             </summary>
             <param name="lifetime"></param>
             <param name="action"></param>
             <param name="date">Date, when task will be queued to execution.</param>
             <returns><see cref="T:System.Threading.Tasks.Task"/> that was created. Its execution progress can be viewed by <see cref="P:System.Threading.Tasks.Task.Status"/></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.QueueRecurring(JetBrains.Lifetimes.Lifetime,System.Action,System.DateTimeOffset,System.TimeSpan)">
            <summary>
            Queues <paramref name="action"/> reccurenly on threads managed by <see cref="P:JetBrains.Application.Threading.Tasks.ITaskHost.Scheduler"/> with priority <see cref="F:JetBrains.Util.Threading.Tasks.TaskPriority.AboveNormal"/> with certain delay 
            expressed by <paramref name="firstTime"/>
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="firstTime">Date, when task will be queued to execution.</param>
            <param name="interval">Interval between end and begin of execution of two adjancent repetition. If action execution time extends <paramref name="interval"/> then 
            they will be executed sequentially one by one. It's guaranteed that new action repetition can't start before old one is finished.</param>    
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create(JetBrains.Lifetimes.Lifetime,System.Action,JetBrains.Application.InterruptionSet,System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:System.OperationCanceledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
            <param name="lifetime"></param>
            <param name="action"></param>
            <param name="checkForInterrupt"></param>
            <param name="options"></param>
            <param name="properties"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.Create``1(JetBrains.Lifetimes.Lifetime,System.Func{``0},JetBrains.Application.InterruptionSet,System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties)">
            <summary>
            Creates task in <see cref="F:System.Threading.Tasks.TaskStatus.Created"/> state. <paramref name="checkForInterrupt"/> and lifetime termitation is beeing propated into task, that can 
            throw <see cref="T:System.OperationCanceledException"/> and finish execution in  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted"/> state. State <see cref="F:System.Threading.Tasks.TaskStatus.Canceled"/> state is not supported.
            In case of normal execution, <see cref="F:System.Threading.Tasks.TaskStatus.RanToCompletion"/> is assigned to task.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.Lifetimes.Lifetime,JetBrains.Application.InterruptionSet,System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Must be used with <code>using</code>. On dispose synchronously waits all activities that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.Action)"/> and <see cref="!:TaskBarrier.EnqueueDependentJobs"/>
            </summary>
            <param name="lifetime"></param>
            <param name="checkForInterrupt">if null inherits current thread's <see cref="T:JetBrains.Application.InterruptableActivityCookie"/> into all jobs</param>
            <param name="sync">whether to execute all enqueued jobs in the same thread as enqueue call</param>
            <param name="takeReadLock">whether to take readlock in each job. True by default (legacy of MulticoreFibersPool)</param>
            <param name="options">options to all tasks in barrier</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.RunEmpty(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates an empty task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1" /> of <see cref="T:System.Threading.Tasks.Task`1" /> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Func{System.Threading.Tasks.Task})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1" /> of <see cref="T:System.Threading.Tasks.Task" /> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Action)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{``0})">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1" /> of <see cref="T:System.Threading.Tasks.Task`1" /> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.StartNew(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,JetBrains.Util.Threading.Tasks.TaskPriority,System.Func{System.Threading.Tasks.Task})">
            <summary>
              <para>Creates a task from an async lambda, unwraps it, and puts it in the started state.</para>
              <para>If you call the simple <c>StartNew</c> for the same async lambda, it would cause a nested <see cref="T:System.Threading.Tasks.Task`1" /> of <see cref="T:System.Threading.Tasks.Task" /> instead, which would have to be double-awaited or manually unwrapped.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Started``1(``0,System.Threading.Tasks.TaskScheduler)">
            <summary>
            In the client code, you should use <c>StartNew</c> directly as much as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Started``2(``0,System.Threading.Tasks.TaskScheduler)">
            <summary>
            In the client code, you should use <c>StartNew</c> directly as much as possible.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.GetTaskScheduler(JetBrains.Threading.JetDispatcher)">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.ContinueWithTask(System.Threading.Tasks.Task,JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task)">
            <summary>
            Awaits for <paramref name="ths"/> task to complete, then executes <paramref name="taskAfter"/>, and returns the task that represents this execution.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,System.Action,JetBrains.Application.InterruptionSet,System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.Run``1(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,System.Func{``0},JetBrains.Application.InterruptionSet,System.Threading.Tasks.TaskCreationOptions,JetBrains.Application.Threading.Tasks.TaskJetProperties,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Creates a task and puts it in the started state.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.While(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,System.Func{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ITaskHostEx2.While(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},System.Nullable{System.TimeSpan},JetBrains.Threading.OnWaitTimeout)">
            <summary>
              <para>Runs an async while loop for the condition.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.ITaskHostEx2.TaskCreationOptionsNetfx45.HideSchedulerFlag">
            <summary>
            Gives the value of the <see cref="T:System.Threading.Tasks.TaskCreationOptions" /><c>::HideScheduler</c> flag.
            It's only present with netfx45, and we're compiling against netfx40, so we can't use the declaration, but we're running against netfx45 in most-most cases, and it's but a number, so we can use it numerically.
            But pure netfx40 would make the check for flags it does not understand, so make sure not to use the numerical value when running without netfx45.
            For that, we keep this field with the ready-for-use value <c>0</c> or the actual flag <c>16</c>, and check in cctor if there is such a value among the enum fields.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.JetDispatcherTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on a Dispatcher thread.
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler">
            <summary>
            Allows to schedule async tasks execution on the Reentrancy Guard.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.ReentrancyGuardTaskScheduler.#ctor(JetBrains.Threading.ReentrancyGuard,JetBrains.Util.Threading.IReaderWriterLock,System.Boolean)">
            <summary>
            Sets up the scheduler for the given guard.
            </summary>
            <param name="guard">The guard instance, also defines the target STA thread.</param>
            <param name="rwLocks">Optional. Takes reader lock on with the given object, if supplied.</param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.Yield(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime)">
            <summary>
              <para>Frees the current thread of execution and re-schedules asynchronously to the free-threaded scheduler with default priority.</para>
              <para>For advanced options and custom priorities, see <see cref="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldTo(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})" />.</para>
            </summary>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldAsLongRunning(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime)">
            <summary>
              <para>Frees the current thread of execution and re-schedules asynchronously to the free-threaded scheduler with default priority.</para>
              <para>For advanced options and custom priorities, see <see cref="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldTo(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})" />.</para>
            </summary>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldIfNeeded(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime)">
            <summary>
              <para>Does nothing if we're on the desired scheduler already, otherwise, calls <see cref="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.Yield(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime)" />.</para>
            </summary>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldTo(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})">
            <summary>
            Frees the current thread of execution and re-schedules asynchronously to the given scheduler.
            </summary>
            <param name="tasker">Task host that owns the schedulers and knows into priorities.</param>
            <param name="lifetime">Lifetime for the autocreated continuation task which would be running after the <c>await</c> keyword.</param>
            <param name="scheduling">The target scheduler shorthand enum member.</param>
            <param name="priority">Optionally, the priority.</param>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.SchedulerAwaiterEx.YieldToIfNeeded(JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Lifetimes.Lifetime,JetBrains.Application.Threading.Tasks.Scheduling,System.Nullable{JetBrains.Util.Threading.Tasks.TaskPriority})">
            <summary>
            Does nothing if we're on the desired scheduler already, otherwise, frees the current thread of execution and re-schedules asynchronously to the given scheduler.
            </summary>
            <param name="tasker">Task host that owns the schedulers and knows into priorities.</param>
            <param name="lifetime">Lifetime for the autocreated continuation task which would be running after the <c>await</c> keyword.</param>
            <param name="scheduling">The target scheduler shorthand enum member.</param>
            <param name="priority">Optionally, the priority.</param>
            <returns>Use the <c>await</c> construct on this.</returns>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.Scheduling">
            <summary>
            Typical scenarios for task scheduling.
            Note that this class should be used only in platform code.
            For features please use extension methods of lifetimes from <c>ShellLifetimes</c> class
            </summary>
            <remarks>
            If you haven't found scheduler you want please also consider
            <see cref="T:JetBrains.Collections.Viewable.SynchronousScheduler"/>, <see cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler"/> or
            <c>PsiFiles.OnCommitBackgroundReadLockScheduler</c>, or <see cref="T:JetBrains.Lifetimes.Lifetime"/> extensions from
            <c>ShellLifetimes</c> class.
            </remarks> 
            <seealso cref="T:JetBrains.Application.Threading.Tasks.ITaskHost"/>
            <seealso cref="T:JetBrains.Util.Concurrency.Threading.UnlimitedThreadPoolScheduler"/>
            <seealso cref="T:JetBrains.Collections.Viewable.SynchronousScheduler"/>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.FreeThreaded">
            <summary>
            Tasks will be run on an MTA thread pool, with maximum parallelism.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainDispatcher">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.JetDispatcher">Dispatcher</see> of the main thread (one of the <c>IThreading</c> components)  i.e. on the main thread when smb pumps the Windows Message Queue. No reentrancy guarantee for these.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Threading.Tasks.Scheduling.MainGuard">
            <summary>
            Tasks will be run with the <see cref="T:JetBrains.Threading.ReentrancyGuard">Guard</see> of the main thread (one of the <c>IThreading</c> components)  i.e. on the main thread when smb pumps the Windows Message Queue and when no other guarded tasks are running. Tasks executed with the Guard will never reenter one another. NOTE: eventually, all such tasks will be taking the reader lock automatically (if available in the current Shell).
            </summary>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskBarrier">
            <summary>
            Replace of MulticoreFibersPool. When you dispose this object it synchronously waits all task that were enqueued by <see cref="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.String,System.Action)"/> and <see cref="!:EnqueueDependentJobs"/>
            Create an instance with <see cref="M:JetBrains.Application.Threading.Tasks.ITaskHost.CreateBarrier(JetBrains.Lifetimes.Lifetime,JetBrains.Application.InterruptionSet,System.Boolean,System.Boolean,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueTask(System.Threading.Tasks.Task)">
            <summary>
            Enqueue a custom (possibly already running) task under the task barrier. If task is not started it will be started.
            </summary>
            <remarks>Note that custom tasks (in contrast with tasks created by EnqueueJob) will not share check-for-interrupt, proiority, and sync and read-lock flag defined in TaskBarrier ctor.</remarks>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskBarrier.EnqueueJob(System.String,System.Action)">
            <summary>
            Create and start a new task under the task barrier.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.Start(System.Threading.Tasks.Task,JetBrains.Application.Threading.Tasks.ITaskHost,System.Boolean)">
            <summary>
            Helper that parametrize task start mode: synchronous (on the same thread, instantly) or asynchronous (on thread pool managed by <see cref="T:JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler"/>)
            </summary>
            <param name="task"></param>
            <param name="host"></param>
            <param name="sync">if true run task synchronously (on the same thread)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.WaitOnMonitor(JetBrains.Application.Threading.Tasks.ITaskHost,System.Object,System.Int32)">
            <summary>
            Wait on monitor <code>mySentry</code> with awareness about MainThread
            </summary>
            <param name="tasks"></param>
            <param name="sentry"></param>
            <param name="timeToWaitMillis"></param>
        </member>
        <member name="M:JetBrains.Application.Threading.Tasks.TaskEx.CantBeJetTask(System.Threading.Tasks.Task)">
            <summary>
            Sometimes some external action can be scheduled here with some state. 
            https://youtrack.jetbrains.com/issue/RSRP-440328
            </summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Application.Threading.Tasks.TaskJetProperties">
            <summary>
            Additional task properties that influence on its execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Priority">
            <summary>
            Task execution priority. Higher priorities are executed first.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.TakeReadLock">
            <summary>
            Whether to take system ReadLock on task execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ExecutionId">
            <summary>
            Internal number that designated in which order tasks are entered
            into <see cref="M:JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler.QueueTask(System.Threading.Tasks.Task)" /> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.Name">
            <summary>
            Internal number that designated in which order tasks are entered
            into <see cref="M:JetBrains.Application.Threading.Tasks.Scheduler.JetScheduler.QueueTask(System.Threading.Tasks.Task)" /> method
            </summary>
        </member>
        <member name="P:JetBrains.Application.Threading.Tasks.TaskJetProperties.ScheduledTime">
            <summary>
            For scheduled tasks with delayed execution
            </summary>
        </member>
        <member name="P:JetBrains.Application.IInterruptionSource.IsPolling">
            <summary>
            <see cref="M:JetBrains.Application.IInterruptionSource.Subscribe(JetBrains.Application.Interruption.InterruptionHandler)"/> and <see cref="M:JetBrains.Application.IInterruptionSource.Unsubscribe(JetBrains.Application.Interruption.InterruptionHandler)"/> will not be used for polling interruption source and this
            provider will asked for interruption state regardless of notifications. (pull-based interrupts)
            </summary>
        </member>
        <member name="M:JetBrains.Application.IInterruptionSource.Subscribe(JetBrains.Application.Interruption.InterruptionHandler)">
             <summary>
             Subscribes the Interruption handler to the invalidation events from the current interruption source.
            
             By contract, the <see cref="M:JetBrains.Application.Interruption.InterruptionHandler.MarkAsDirty"/> will be called by Interruption source
             when the result of <see cref="M:JetBrains.Application.IInterruptionSource.CheckInterrupt"/> may be changed.
            
             Note: you must unsubscribe from this event by using <see cref="M:JetBrains.Application.IInterruptionSource.Unsubscribe(JetBrains.Application.Interruption.InterruptionHandler)"/>.
             This is the only way to manage the lifetime of the interruption source!
             </summary>
        </member>
        <member name="M:JetBrains.Application.IInterruptionSource.CheckInterrupt">
            <summary>
            A function to check for interruption.
            </summary>
            <returns>true if interrupt was requested, false otherwise</returns>
        </member>
        <member name="T:JetBrains.Application.InterruptableActivityCookie">
            <summary>
            Obsolete, see <see cref="T:JetBrains.Application.Interruption"/> for current implementation
            </summary>
        </member>
        <member name="M:JetBrains.Application.InterruptableActivityCookie.CheckAndThrow(JetBrains.Application.Progress.IProgressIndicator)">
            <summary>
            Obsolete. Ensure, that provided progress indicator was added to the list of interruption sources somewhere above the invocation in the call stack using
            
            <code>
            using (Interruption.Current.Add(ProgressIndicatorInterruptionSource.Create(progressIndicator)))
            </code>
            
            After that you can safely replace this call to <code>Interruption.Current.CheckAndThrow()</code>
            </summary>
            <param name="progress"></param>
        </member>
        <member name="T:JetBrains.Application.Interruption.InterruptionHandler">
            <summary>
            Handler for interrupt. Cannot be used across threads.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.CONTINUE">
            <summary>
            No polling providers and no interrupt was requested
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.INTERRUPT">
            <summary>
            No polling providers and interrupt was requested
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.DIRTY">
            <summary>
            Interruption status was possible changed and must be checked
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.POLLING">
            <summary>
            At least one polling provider exist and must be checked every time
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.INVALIDATING">
            <summary>
            It is an error to check current interrupt state during invalidating current state.
            This state is used to detect these calls and each <see cref="M:JetBrains.Application.Interruption.InterruptionHandler.Check"/> invocation
            will report such illegal usage.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.States.SUSPEND">
            <summary>
            Interruption handler suspended and always return false
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.myLastPollingTimestamp">
            <summary>
            The value of <see cref="P:System.Environment.TickCount"/> when last interruption was checked from polling provider
            By default, InterruptionHandler throttle the amount of calls to 
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.myLastPollingResult">
            <summary>
            The result of check of polling-only providers. Cached only for the amount of <see cref="P:JetBrains.Application.Interruption.InterruptionHandler.PollingThrottleMs"/> amount
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.myPollingProviders">
            <summary>
            Non-reactive interruption sources, check source have to be checked every invocation
            Should be either null or non-empty.
            </summary>
        </member>
        <member name="F:JetBrains.Application.Interruption.InterruptionHandler.myInterruptSuspend">
            <summary>
            A counter for the amount of issued <see cref="M:JetBrains.Application.Interruption.InterruptionHandler.Suspend"/> cookies.
            </summary>
        </member>
        <member name="P:JetBrains.Application.Interruption.InterruptionHandler.PollingThrottleMs">
            <summary>
            The property to regulate the interval between checks of polling interruption sources.
            These providers will be polled no often than this amount of milliseconds
            Set it to zero to disable it
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.Add(JetBrains.Application.IInterruptionSource)">
            <summary>
            Add interruption source to current handler.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.Add(JetBrains.Lifetimes.Lifetime,JetBrains.Application.IInterruptionSource)">
            <summary>
            Add interruption source to current handler. The provided lifetime has to be disposed in the current stack on the
            current thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.HasPolling">
            <summary>
            Interruption handler may contains so called "Polling provider" (aka legacy provider) when interruption state
            changes not reported by interruption provider, but checked each time by executing code. When such provider
            exists in the current InterruptionHandler it is considered to be slow, because it is not possible to measure
            and limit the execution cap of this external function.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.Check">
            <summary>
            Check whether interrupt was requested.
            </summary>
            <returns>return true if interruption was requested, false otherwise</returns>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.MarkAsDirty">
            <summary>
            Explicit request to check interruption state on next invocation
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.Suspend">
            <summary>
            Temporary suspend interruption check, e.g. <see cref="M:JetBrains.Application.Interruption.InterruptionHandler.Check"/> calls will return false independent from real interruption state.
            Polling handlers will not be called.
            Can be suspended from any thread.
            </summary>
        </member>
        <member name="M:JetBrains.Application.Interruption.InterruptionHandler.CallInterruptsUntilReentrancyMarker(System.Collections.Generic.List{JetBrains.Application.IInterruptionSource})">
            <summary>
            Checks if any of the interrupts after <see cref="M:JetBrains.Application.Interruption.Override(JetBrains.Application.InterruptionSet)"/> call is interrupted
            </summary>
            <param name="interrupts">Stack of interrupts</param>
            <returns>True if any of the interrupts after reentrancy marker returned true, false otherwise</returns>
        </member>
        <member name="M:JetBrains.Application.Interruption.Override(JetBrains.Application.InterruptionSet)">
            <summary>
            Temporarily replace current interruption set with empty one.
            </summary>
        </member>
        <member name="T:JetBrains.Application.InterruptionSet">
            <summary>
            An immutable set of interruption sources.
            </summary>
        </member>
        <member name="T:JetBrains.Application.InterruptionSourceBaseNoLifetime">
            <summary>
            A base class for <see cref="T:JetBrains.Application.IInterruptionSource"/> to support reuse of interruption sources across several threads.
            Tracks subscriptions and marks them as dirty when <see cref="M:JetBrains.Application.InterruptionSourceBaseNoLifetime.Fire"/> is called.
            </summary>
        </member>
        <member name="T:JetBrains.Application.InterruptionSourceBase">
             <summary>
             A base class for <see cref="T:JetBrains.Application.IInterruptionSource"/> to support reuse of interruption sources across several threads.
            
             Interruption sources can be activated with different lifetimes from different threads. This class support the notion
             of "union lifetime" and allows inheritors to activate resources only once.
            
             It implements reusable prolongable lifetime like <see cref="T:JetBrains.Util.DataStructures.Caches.ProlongableLifetime"/>.
             It is not possible to reuse ProlongableLifetime here because of different lock order (external lock and spinwait
             inside ProlongableLifetime acquired in different order during creating and termination)
             </summary>
        </member>
        <member name="T:JetBrains.Application.InterruptionSourceByTimer">
            <summary>
            Interruption source with invalidation event raised by <see cref="T:System.Threading.Timer"/>
            </summary>
        </member>
        <member name="T:JetBrains.Application.LifetimeInterruptionSource">
            <summary>
            Implementation of <see cref="T:JetBrains.Application.IInterruptionSource"/> for Lifetime.
            </summary>
        </member>
        <member name="T:JetBrains.Application.PollingInterruptionSource">
             <summary>
             Previous approach for interruption was repeatedly calling a function (which calls several other functions)
             This is class is used to emulate this approach during transition period to reactive interruptions.
             For details see <see cref="T:JetBrains.Application.Interruption"/> and related tests.
            
             Please, do not use in new code. Consider migrating to push-based interruption model.
             </summary>
        </member>
        <member name="F:JetBrains.Application.CompanyInfo.HistoricalDefaultProductName">
            <summary>
            Name of the main historical Visual Studio integrated product of which we keep most of the technical decorations over VS CTO command names prefix, VS command line keys prefix, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Application.CompanyInfo.PlatformProductRegistryKeyName">
            <summary>
              <para>In the Registry, name of the key that's shared by all of the Platform-based products (under the company name key).</para>
              <para>Things like InstanceId that are used by usage statistics of all the products are stored there.</para>
            </summary>
            <example><code>HKEY_CURRENT_USER\Software\JetBrains\Platform</code></example>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemoveEventArgs`1">
            <summary>
            Notifies that the item is being added to or removed from an event-equipped collection.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action">
            <summary>
            Gets the action (either <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> or <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/>).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Collection">
            <summary>
            Gets the owning event-equipped collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Cookie">
            <summary>
            An optional cookie specified with the operation.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging">
            <summary>
            Gets whether the handler is being called in the Acknowledgement mode, that is, the items appear/disappear in the handler's view not because they're being put/removed into the collection, but because the collection itself comes/goes into view of the handler, with all of its items. This happens when you sink/unsink the signal.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding">
            <summary>
            Gets whether <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action"/> is actually <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/>.
            Exactly one of <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> and <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is guaranteed to be <c>True</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving">
            <summary>
            Gets whether <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.Action"/> is actually <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/>.
            Exactly one of <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> and <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is guaranteed to be <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.AddRemoveEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.Collections.Viewable.AddRemove,System.Object,System.Action{`0}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.AddRemoveIndexEventArgs`1">
            <summary>
            Notifies that the item is being added to or removed from an event-equipped list.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.AddRemoveIndexEventArgs`1.Index">
            <summary>
            Gets the index at which the change is happening.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.AddRemoveIndexEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.Collections.Viewable.AddRemove,System.Object,System.Action{`0,System.Int32}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1">
            <summary>
            Notifies that the item will be added to or removed from an event-equipped collection, and allows to cancel this action.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.Collections.Viewable.AddRemove,System.Object,System.Action{`0}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1">
            <summary>
            Notifies that the item will be added to or removed from an event-equipped list, and allows to cancel this action.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1.Index">
            <summary>
            Gets the index at which the change is happening.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforeAddRemoveIndexEventArgs`1.CreateAcknowledgementArgs(JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.Collections.Viewable.AddRemove,System.Object,System.Action{`0,System.Int32}@)">
            <summary>
            Creates the arguments specifically suited for acknowledgement, with the specific flag set and an ability to change the value in order to reuse the arguments object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1">
            <summary>
            Notifies of the intended property change.
            Comes before the <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/> and the actual property change, and allows to cancel the change.
            Acknowledges the fact that the property change can be either from no value to something, or from something to no value.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateBoth(JetBrains.DataFlow.IProperty{`0},`0,`0,System.Object)">
            <summary>
            Creates an instance that has both values defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateNew(JetBrains.DataFlow.IProperty{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the new value defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.CreateOld(JetBrains.DataFlow.IProperty{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the old value defined.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CancelEventArgs`1">
            <summary>
            An event arguments class with one typed value and the Cancel functionality.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.CancelEventArgs`1.Cancel">
            <summary>
            Gets or sets whether the change will be cancelled.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge`2">
            <summary>
            Bridges two unordered collection of items.
            The items flow from the first collection to the second one. Conversion and filtering is supported on the items.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge`2.myMapBothWays">
            <summary>
            Two-way map, non-Null only in two-way mode.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge`2.myMapSourceToTarget">
            <summary>
            One-way map, non-Null only in one-way mode.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionBridge`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.CollectionBridge.MappingInfo,JetBrains.DataFlow.ICollectionEvents{`0},JetBrains.DataFlow.ICollectionEvents{`1},System.Func{`0,`1},System.Object)">
            <summary>
            Wires up the bridge.
            </summary>
            <param name="lifetime">Lifetime for the bridge.</param>
            <param name="mappinginfo">Specifies which mapping information is maintained by the bridge  source-to-target only, or both ways. one-way is cheaper.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="funcConverter">The conversion operator.</param>
            <param name="oTaregtModificationCookie">An otpional cookie to be passed to the <paramref name="target"/> collection when performing modification operations on it.</param>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.AllowForeignTargetRemovals">
            <summary>
            <para>Whether the bridged items could be removed from the target collection by a foreign actor, and the bridge should ignore such occurrences.</para>
            <para>When <c>True</c>, <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> does nothing when the target item is already not there.</para>
            <para>When <c>False</c>, <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> throws when about to remove a nonexistent item. This is the default.</para>
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MappingInfo">
            <summary>
            Gets which mapping information is maintained by the bridge  source-to-target only, or both ways.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MapSourceToTarget">
            <summary>
            Gets the read-only source-to-target mapping info. This one is always available.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.MapTargetToSource">
            <summary>
            Gets the read-only target-to-source mapping. Available only if <see cref="P:JetBrains.DataFlow.CollectionBridge`2.MappingInfo"/> is set to <see cref="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.BothWays"/>; in other cases, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.Source">
            <summary>
            Gets the source collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionBridge`2.Target">
            <summary>
            Gets the target collection.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge">
            <summary>
            Supplementary class for the <see cref="T:JetBrains.DataFlow.CollectionBridge`2"/> utility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionBridge.BridgeInto``2(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Object)">
            <summary>
            Mirrors one collection into another thru a converter.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionBridge.MappingInfo">
            <summary>
            Kind of info about collections mapping to be maintained by the bridge.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.SourceToTarget">
            <summary>
            There's only data for translating from the source collection to the target one.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionBridge.MappingInfo.BothWays">
            <summary>
            There's data for translating both from source to target and from target to source collection items.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionEvents`1">
            <summary>
            A collection that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.CollectionEvents`1.myStorage">
            <summary>
            Sync thru <see cref="F:JetBrains.DataFlow.CollectionEvents`1.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.DataFlow.PropertyId{`0},System.Collections.Generic.ICollection{`0},System.Boolean,JetBrains.Util.ILogger)">
            <summary>
              <para>The universal constructor.</para>
              <para>Initializes the collection by giving the underlying storage that also implements the collection interface.</para>
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">Whether the <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)" /> method should abort silently if the collection already <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)" /> the item being added.</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{`0},System.Collections.Generic.ICollection{`0},System.Boolean,JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(System.String,System.Collections.Generic.ICollection{`0},System.Boolean)">
            <summary>
            Initializes the collection by giving the underlying storage that also implements the collection interface.
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bUniqueItems">Whether the <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)" /> method should abort silently if the collection already <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)" /> the item being added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.Lifetimes.Lifetime,System.String,System.Collections.Generic.ICollection{`0},System.Boolean)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(System.String)">
            <summary>
            Creates a collection that is based on a <see cref="T:System.Collections.Generic.List`1" /> and merges duplicate items.
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.#ctor(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsNullValuesAllowed">
            <summary>
            Gets whether the <c>Null</c> values are allowed to be added to the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsUniqueItems">
            <summary>
            Gets whether all of the items in the collection should be unique.
            Behavior of the collection in case of duplicates found depends on the
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.SuppressItemErrors">
            <summary>
            Gets whether the errors when adding/removing items should be suppressed, and just <c>false</c> returned, when appropriate.
            The errors include item already added (when <see cref="P:JetBrains.DataFlow.CollectionEvents`1.IsUniqueItems" />) or cannot remove nonexistent item.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireAddRemove(JetBrains.Collections.Viewable.AddRemove,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireBeforeAddRemove(JetBrains.Collections.Viewable.AddRemove,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> event.
            Returns whether the operation has been cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireCollectionChanged(`0,JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Fires the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> event in case the index is not known.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FireCollectionChanged(`0,System.Int32,JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Fires the <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged"/> event in case the index is known.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.FirePropertyChanged(System.String)">
            <summary>
            Fires the <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.CollectionAddCore(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            DO NOT call from collection impl because to enable Call Stack Annotation all calls to this method MUST go thru <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0,System.Object)" />.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.CollectionRemoveCore(`0,System.Object)">
            <summary>
            One of the core methods that implement the actual functionality.
            DO NOT call from collection impl because to enable Call Stack Annotation all calls to this method MUST go thru <see cref="M:JetBrains.DataFlow.CollectionEvents`1.Remove(`0,System.Object)" />.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.OnAcknowledgeSinkAddRemove(System.Action{JetBrains.DataFlow.AddRemoveEventArgs{`0}},JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Acknowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.OnAcknowledgeSinkBeforeAddRemove(System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{`0}})">
            <summary>
            Called when someone attempts to sink the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> signal. Acknowledges the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.GetCsaObjectName">
            <summary>
            Object name in the Call Stack Annotation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="E:JetBrains.DataFlow.CollectionEvents`1.CollectionChanged">
            <summary>
            Occurs when the collection changes.
            </summary>
            
        </member>
        <member name="E:JetBrains.DataFlow.CollectionEvents`1.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
            
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was added to the collection. An addition can be cancelled by the duplicates merger or the before-added handlers.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Add(`0)">
            <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Executes the <see cref="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)" /> operation for all the elements in the given collection.
            </summary>
            <param name="items">The collection whose elements should be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Clear">
            <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only. </exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Clear(System.Object)">
            <summary>
            Executes the <see cref="M:JetBrains.DataFlow.ICollectionEvents`1.Remove(`0,System.Object)" /> operation for all the elements currently in the collection.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <remarks>
            Note: it's not guaranteed that the collection is empty after clean, because of the events.
            Of course, you cannot guarantee it without external locks when multithreading, anyway.
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Contains(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> contains a specific value.
            </summary>
            <returns>s
            true if item is found in the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false.
            </returns>
            <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.Generic.ICollection`1"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.Generic.ICollection`1"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing.</param>
            <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">arrayIndex is less than 0.</exception>
            <exception cref="T:System.ArgumentNullException">array is null.</exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or-arrayIndex is equal to or greater than the length of array.-or-The number of elements in the source <see cref="T:System.Collections.Generic.ICollection`1"></see> is greater than the available space from arrayIndex to the end of the destination array.-or-Type T cannot be cast automatically to the type of the destination array.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.GetEnumerator">
            <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
            
            <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1"></see> that can be used to iterate through the collection.
            </returns>
            <filterpriority>1</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Modify(JetBrains.Collections.Viewable.AddRemove,`0,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove" /> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Remove(`0,System.Object)">
            <summary>
            Attempts to remove a value from the collection.
            </summary>
            <param name="value">The value to be removed.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was removed from the collection. A removal may fail either if the item is missing from the collection, or the before-removed handlers have cancelled the operation.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.Remove(`0)">
            <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            <returns>
            true if item was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1"></see>; otherwise, false. This method also returns false if item is not found in the original <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1"></see>.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#CopyTo(System.Array,System.Int32)">
            <summary>
            Copies the elements of the <see cref="T:System.Collections.ICollection"></see> to an <see cref="T:System.Array"></see>, starting at a particular <see cref="T:System.Array"></see> index.
            </summary>
            
            <param name="array">The one-dimensional <see cref="T:System.Array"></see> that is the destination of the elements copied from <see cref="T:System.Collections.ICollection"></see>. The <see cref="T:System.Array"></see> must have zero-based indexing. </param>
            <param name="index">The zero-based index in array at which copying begins. </param>
            <exception cref="T:System.ArgumentNullException">array is null. </exception>
            <exception cref="T:System.ArgumentException">The type of the source <see cref="T:System.Collections.ICollection"></see> cannot be cast automatically to the type of the destination array. </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">index is less than zero. </exception>
            <exception cref="T:System.ArgumentException">array is multidimensional.-or- index is equal to or greater than the length of array.-or- The number of elements in the source <see cref="T:System.Collections.ICollection"></see> is greater than the available space from index to the end of the destination array. </exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.CollectionEvents`1.System#Collections#IEnumerable#GetEnumerator">
            <summary>
            Returns an enumerator that iterates through a collection.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.IEnumerator"></see> object that can be used to iterate through the collection.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove">
            <summary>
            Fires when an item is added (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> is defined) or removed (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is defined).
            Throwing an exception does not prevent the item from being added, and other handlers from being called.
            The event supports acquaintance, which means that when you sink it, all the items currently in collection are added, and when you unsink, they are removed for the particular eventhandler you're adding or removing.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAdding"/> is defined) or removed (<see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsRemoving"/> is defined).
            Setting <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> or throwing an exception prevents the item from being added.
            Note that even though the number of before-handlers called is undefined in such a case, no <see cref="P:JetBrains.DataFlow.CollectionEvents`1.AddRemove"/> handlers are guaranteed to execute if you cancel the operation on the <see cref="P:JetBrains.DataFlow.CollectionEvents`1.BeforeAddRemove"/> event.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.Count">
            <summary>
            Gets the number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </summary>
            
            <returns>
            The number of elements contained in the <see cref="T:System.Collections.Generic.ICollection`1"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.Id">
            <summary>
            Gets the identification for this list.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.IsReadOnly">
            <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.ICollection`1"></see> is read-only; otherwise, false.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#IsSynchronized">
            <summary>
            Gets a value indicating whether access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe).
            </summary>
            
            <returns>
            true if access to the <see cref="T:System.Collections.ICollection"></see> is synchronized (thread safe); otherwise, false.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.CollectionEvents`1.System#Collections#ICollection#SyncRoot">
            <summary>
            Gets an object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </summary>
            
            <returns>
            An object that can be used to synchronize access to the <see cref="T:System.Collections.ICollection"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.CollectionEvents`1.Csa">
            <summary>
            Call Stack Annotation helpers.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.CombinedProperty2`3">
            <summary>
            Implements a property combining two other properties which does not have its own lifetime but uses the combined lifetime of its sinks, and works as a stateless pass-thru when there are none.
            </summary>
            <remarks>Unlike the original <seealso cref="T:JetBrains.DataFlow.CompositeProperty`3"/>, this class is a property implementation on itself, and it does not have its own lifetime (is driven by sinks).</remarks>
            <seealso cref="T:JetBrains.DataFlow.CompositeProperty`3"/>
        </member>
        <member name="T:JetBrains.DataFlow.CompositeProperty`3">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.CompositeProperty`3.Create(JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.CompositeProperty{`0,`1,`2}.ComposerDelegate)">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
            <param name="propertySourceOne">The source property.</param>
            <param name="propertySourceTwo">The source property.</param>
            <param name="composer">The composer that produces the target from the sources.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.CompositeProperty`3.Create(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.CompositeProperty{`0,`1,`2}.ComposerDelegate)">
            <summary>
            Creates a new composite property that composes the values of two source ones.
            </summary>
            <param name="lifetime"></param>
            <param name="propertySourceOne">The source property.</param>
            <param name="propertySourceTwo">The source property.</param>
            <param name="composer">The composer that produces the target from the sources.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.DataFlow.CompositeProperty`3.ComposerDelegate">
            <summary>
            Composes a target value from two source ones.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DataFlowDirection">
            <summary>
            Defines the direction of the data flow between two properties.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.None">
            <summary>
            No synchronization is performed automatically.
            Both bindings can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.FromSource">
            <summary>
            A one-way forward data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/>.
            The back-way binding can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.FromTarget">
            <summary>
            A one-way backward data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/>.
            The forward-way binding can still be invoked manually.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DataFlowDirection.BothWays">
            <summary>
            A two-way data flow from the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/> to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Target"/>, and then back to the <see cref="P:JetBrains.DataFlow.PropertyBinding`2.Source"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DictionaryEvents`2">
            <summary>
            A dictionary that fires events when items are added or removed.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.DictionaryEvents`2.myStorage">
            <summary>
            Stores the dictionary entries.
            Sync thru <see cref="F:JetBrains.DataFlow.CollectionEvents`1.myLock"/>.
            </summary>
            <remarks>
            The storage must be passed to the base class in ctor, for the collection operations to work on the same data.
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.DataFlow.PropertyId{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IDictionary{`0,`1},System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
              <para>This is the universal constructor.</para>
              <para>Specifies whether <c>Null</c> keys or values are allowed or not.</para>
              <para>Take caution with value types, for them the <c>default</c> value is used.</para>
              <para>Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.</para>
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="storage">The underlying collection, all the operations will be relayed to it.</param>
            <param name="bNullKeysAllowed">Whether <c>Null</c> values are allowed for keys (take caution with value types).</param>
            <param name="bNullValuesAllowed">Whether <c>Null</c> values are allowed for values (take caution with value types).</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{System.Collections.Generic.KeyValuePair{`0,`1}},System.Collections.Generic.IDictionary{`0,`1},System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(System.String,JetBrains.Util.ILogger)">
            <summary>
            Creates a dictionary that allows storing <c>Null</c> values.
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.Lifetimes.Lifetime,System.String,JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(System.String,System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>
              <para>Specifies whether <c>Null</c> keys or values are allowed or not.</para>
              <para>Take caution with value types, for them the <c>default</c> value is used.</para>
              <para>Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.</para>
            </summary>
            <param name="id">
              <para>An unique identifier for the list, to tell it apart in data flow chains.</para>
              <para>If callstack annotation is on, will appear on callstacks when collection is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="bNullKeysAllowed">Whether <c>Null</c> values are allowed for keys (take caution with value types).</param>
            <param name="bNullValuesAllowed">Whether <c>Null</c> values are allowed for values (take caution with value types).</param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.#ctor(JetBrains.Lifetimes.Lifetime,System.String,System.Boolean,System.Boolean,JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.NullPairKeysAllowed">
            <summary>
            Gets whether <c>Null</c> keys are allowed or not.
            Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.NullPairValuesAllowed">
            <summary>
            Gets whether <c>Null</c> values are allowed or not.
            Note: the <c>Null</c>-checks are enforced only by those operations that add to the dictionary.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Item(`0)">
            <summary>
            Gets or sets the element with the specified key.
            </summary>
            
            <returns>
            The element with the specified key.
            </returns>
            
            <param name="key">The key of the element to get or set.</param>
            <exception cref="T:System.NotSupportedException">The property is set and the <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">The property is retrieved and key is not found.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.Add(`0,`1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <param name="value">The object to use as the value of the element to add.</param>
            <param name="key">The object to use as the key of the element to add.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.ContainsKey(`0)">
            <summary>
            Determines whether the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the specified key.
            </summary>
            
            <returns>
            true if the <see cref="T:System.Collections.Generic.IDictionary`2"></see> contains an element with the key; otherwise, false.
            </returns>
            
            <param name="key">The key to locate in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.</param>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.Remove(`0)">
            <summary>
            Removes the element with the specified key from the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            <returns>
            true if the element is successfully removed; otherwise, false.  This method also returns false if key was not found in the original <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            <param name="key">The key of the element to remove.</param>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"></see> is read-only.</exception>
            <exception cref="T:System.ArgumentNullException">key is null.</exception>
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.TryGetValue(`0,System.Func{`1})">
            <summary>
            Attempts to look up a value by its <paramref name="key"/> in the dictionary.
            In case there is no such key-value pair present, uses the <paramref name="funcCreateIfMissing"/> function to create a new value, and then places it into the dictionary under the <paramref name="key"/>.
            </summary>
            <param name="key">Key to the value we're trying to look up.</param>
            <param name="funcCreateIfMissing">In case there is no <paramref name="key"/> in the dictionary, produces a new value to be stored in the dictionary and returned to the caller.</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Keys">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the keys of the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            
        </member>
        <member name="P:JetBrains.DataFlow.DictionaryEvents`2.Values">
            <summary>
            Gets an <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </summary>
            
            <returns>
            An <see cref="T:System.Collections.Generic.ICollection`1"></see> containing the values in the object that implements <see cref="T:System.Collections.Generic.IDictionary`2"></see>.
            </returns>
            
        </member>
        <member name="M:JetBrains.DataFlow.DictionaryEvents`2.set_Item(`0,System.Object,`1)">
            <summary>
            Sets the element with the specified key.
            An overload of the <see cref="M:JetBrains.DataFlow.DictionaryEvents`2.set_Item(`0,`1)"/> method which allows to specify the modification cookie for both removal and addition operation events which might be fired as a result of this assignment.
            </summary>
            <param name="key"></param>
            <param name="cookie"></param>
            <param name="value"></param>
        </member>
        <member name="T:JetBrains.DataFlow.EventArgs`1">
            <summary>
            An event arguments class with one typed value.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.EventArgs`1.#ctor(`0)">
            <summary>
            Constructs the universal event args.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.EventArgs`1.Value">
            <summary>
            Gets the value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.DataFlowEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DataFlowEx.OnSignal``1(JetBrains.DataFlow.IPropertyBinding,JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Sets up the binding to update when the <paramref name="signal"/> fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.DataFlowEx.AddLifetime(System.ComponentModel.IContainer,JetBrains.Lifetimes.LifetimeDefinition)">
            <summary>
            Allows to bind the lifetime to a Windows Form.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEventsEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.BeginAdd``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynchronously adds a new item to the collection.
            </summary>
            <typeparam name="TValue">Item type.</typeparam>
            <param name="ths">Collection.</param>
            <param name="lifetimeAsyncOperation">The lifetime for the async operation of adding the item, NOT for the item's presence in the collection! If the lifetime expires while the deferred operation is still pending, the operation will be dropped.</param>
            <param name="dispatcher">Identifies the thread the modification should happen on.</param>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateCount``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a property that tells the numer of items in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateIsEmpty``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a property that tells whether the collection is empty.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.CreateIsNotEmpty``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a property that tells whether the collection has some items in it.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="ths">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="ths">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.LogChanges``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Object)">
            <summary>
            Logs the collection modifications.
            </summary>
            <param name="ths">The collection.</param>
            <param name="lifetime">ILifetime for the logging set-up.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItem``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each item in the collection.</para>
            <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.Lifetimes.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes  before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItem``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each item in the collection.</para>
            <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.Lifetimes.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes  before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself, the third param is the cookie with which the item has been added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemCore``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0},System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
            Core impl for both ForEachItem functions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreaded``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Binds a lifetime to each item in the collection.</para>
              <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.Lifetimes.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime" /> you define for this method terminates.</para>
              <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes  before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
              <para>This version allows free-threaded add/removes on the collection and lifetime termination. To be completely thread-safe, the lifetime passed to this function MUST be synchronized with collection adds/removes, see <see cref="T:JetBrains.Util.Threading.SynchronizedLifetime" />.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreaded``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
              <para>Binds a lifetime to each item in the collection.</para>
              <para>Your handler is called for each item when it's added to the collection (and initially for all the items already in the collection), and is given the <see cref="T:JetBrains.Lifetimes.Lifetime">lifetime object</see> for that item. This per-item lifetime is terminated whenever that item is removed from the collection, or when the <paramref name="lifetime" /> you define for this method terminates.</para>
              <para>Using the per-item lifetime, you can define a pair of actions (after-item-comes  before-item-goes) to be executed for each item, or spawn some activity for the duration of each item, etc.</para>
              <para>This version allows free-threaded add/removes on the collection and lifetime termination. To be completely thread-safe, the lifetime passed to this function MUST be synchronized with collection adds/removes, see <see cref="T:JetBrains.Util.Threading.SynchronizedLifetime" />.</para>
            </summary>
            <param name="ths"></param>
            <param name="lifetime">ILifetime of the construct. All of the open per-item lifetimes will be terminated when it terminates.</param>
            <param name="FHandler">Handler, called for each item when you first see it in the collection. The first param is the lifetime of the item, the second one is the item value itself, the third param is the cookie with which the item has been added.</param>
        </member>
        <member name="F:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemData.OpenLifetimes">
            <summary>
            Holds one lifetime for each item that was added, but not yet removed. This supports reordering which might happen with free-threaded access.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemData.RemoveRequests">
            <summary>
            Holds one per each item remove event which has not been yet completed. E.g. with free-threaded operations a Remove event might come before its Add.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.ForEachItemFreeThreadedCore``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0},System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
            Core impl for ForEachItemFreeThreadedCore family functions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.Add``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,``0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="lifetime">ILifetime for the item to be present in the collection. Upon termination, the item is removed.</param>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <param name="ths">Collection.</param>
            <returns>If the item was added to the collection (not cancelled by the duplicates merger or the before-added handlers), returns an object that removes the item from the collection on <see cref="M:System.IDisposable.Dispose"/>. Otherwise, returns a dummy <see cref="T:System.IDisposable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.Insert``1(JetBrains.DataFlow.IListEvents{``0},JetBrains.Lifetimes.Lifetime,System.Int32,``0,System.Object)">
            <summary>
            Attempts to insert the item to the list
            </summary>
            <param name="lifetime">ILifetime for the item to be present in the collection. Upon termination, the item is removed.</param>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <param name="index">The zero-based index at which <paramref name="value"/> should be inserted.</param>
            <param name="ths">Collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
            Mirrors one collection into another.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the collection flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that for the <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> operation to be mirrored successfully, the converter product must return <see cref="M:System.Object.Equals(System.Object,System.Object)"/> for to projections of the same source item. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">An optional cookie for the modification operation on the <paramref name="target"/> collection.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
                <para>Mirrors one collection into another.</para>
                <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">
                If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the
                <see
                    cref="F:JetBrains.Collections.Viewable.AddRemove.Add" />
                operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)" /> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.
            </param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">
                An optional cookie for the modifiction operation on the <paramref name="target" /> collection.
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoCollectionCore``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``1},System.Func{``0,``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,``1},System.Func{``0,System.Boolean},System.Object)">
            <summary>
                <para>Mirrors one collection into another.</para>
                <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">
                If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the
                <see
                    cref="F:JetBrains.Collections.Viewable.AddRemove.Add" />
                operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)" /> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.
            </param>
            <param name="FLifeConvert">
                Same as <see cref="!:FConvert" />, but with a lifetime. It's an error to specify both at the same time.
            </param>
            <param name="FFilter">Allows to exclude certain items from being converted and added to the target collection.</param>
            <param name="cookie">
                An optional cookie for the modifiction operation on the <paramref name="target" /> collection.
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IReadonlyListEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IReadonlyListEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowInto``2(JetBrains.DataFlow.IReadonlyListEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{``1})">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="source">The source collection.</param>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="target">The target collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoListCore``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IReadonlyListEvents{``0},JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Func{JetBrains.Lifetimes.Lifetime,``0,``1},System.Object)">
            <summary>
            <para>Mirrors one list into another with the same item order.</para>
            <para>It is an error to modify the target collection directly while this method is in effect.</para>
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
            <param name="lifetime">ILifetime of the flow.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="FConvert">If the collection types differ and are unrelated, a converter that produces items for the second collection from the items of the first collection. Note that the converter is only used for the <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation, and there are no limitations on <see cref="M:System.Object.Equals(System.Object,System.Object)"/> of the conversion products. May be <c>Null</c> if the types could be converted by a simple cast.</param>
            <param name="FLifeConvert">Same as <see cref="!:FConvert"/>, but with a lifetime. It's an error to specify both at the same time.</param>
            <param name="cookie">An optional cookie for the modifiction operation on the <paramref name="target"/> collection.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.DisposeEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Makes sure each item of the collection is disposed of when it exits the collection view (just after the item is removed from the collection).
            When the <paramref name="lifetime"/> terminates, all of the items currently in the collection are also disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGuarded_NoReplay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.ReentrancyGuard,System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but in a guarded context.
            After the guarded context gets acquired, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGrouped_NoReplay``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.GroupingEventHost,System.TimeSpan,System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but at a rarer intervals, as limited by the grouping event (could be guarded or guard-invariant).
            After the timeout expires, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoGrouped_NoReplay``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{``0},System.Action,System.Action{System.Action},System.Boolean,System.Object)">
            <summary>
            Updates the second collection as the first one is modified, but at a rarer intervals, as defined by the grouping function (eg <see cref="M:JetBrains.Threading.ReentrancyGuard.ExecuteOrQueue(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/> or <see cref="M:JetBrains.Util.Concurrency.GroupingEventHostEx.QueueAtShort(JetBrains.Threading.GroupingEventHost,JetBrains.Lifetimes.Lifetime,System.String,System.TimeSpan,System.Action)"/>).
            When the grouping function manages to execute, does not replay all additions and removals, but instead replicates the current collection state (hence "no replay"). Can be thus slow on large collections, so hashsets are recommended as backing store.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.FlowIntoSorted``2(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Collections.Generic.IComparer{``1},System.Collections.Generic.IEqualityComparer{``1},System.Func{``0,System.Boolean},System.Object,System.Boolean)">
            <summary>
            For a collection of arbitrary items, maintains a list (= collection with linear order on the items) of the same items sorted in the order as defined by the <paramref name="comparerForSorting" />.
            </summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="source">Collection of items without any order implied.</param>
            <param name="lifetime">Time to work.</param>
            <param name="target">Target collection of ordered items.</param>
            <param name="comparerForSorting">Comparer setting up the order. Might be partial order, in which case items are added in order of appearance (stable sorting), and removed by equality (<see cref="!:comparerForDeleting" />). If <c>NULL</c>, uses default comparer, e.g. <see cref="T:System.IComparable`1" /> on the type.</param>
            <param name="comparerForDeleting">Optional. If <see cref="!:comparerForSorting" /> does not impose linear order, upon deletion we might get a set of items all of the same sort order. To remove the correct one of them, we have to check equality now, and here's the comparer. If <c>NULL</c>, uses default comparer.</param>
            <param name="FFilter">Optional filtering function.</param>
            <param name="cookie">Target collection modification token.</param>
            <param name="clearTarget">Clear target on initialization and lifetime termination</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.GetLifetimeOfItem``1(JetBrains.DataFlow.IReadonlyCollectionEvents{``0},JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            For an item in the collection, creates a lifetime that will be terminated when the item leaves the collection (or the passed-in lifetime terminates, or the collection lifetime terminates).
            </summary>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="ths">Collection.</param>
            <param name="lifetime">The limiting lifetime. The returned lifetime will be nested within this lifetime (as well as within the collection's).</param>
            <param name="item">The item whose lifetime should be created. It's an error if the item is currently not present within the collection.</param>
            <returns>The lifetime of the item's presence in the collection.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.AddItemUnderLifetime``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.LifetimeDefinition,``0})">
            <summary>
              <para>Creates a new item to be added to the collection.</para>
              <para>The item lifetime terminates when either the input lifetime is terminated, or when the item is removed from the collection by some other collection client.</para>
              <para>If you terminate the item's definition, it will be removed from the collection.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx.SyncOneTime``1(JetBrains.DataFlow.IListEvents{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Use this method to update the whole list in one go. It would compare list content with new data, adding and removing items as needed
            </summary>
            <param name="listEvents"></param>
            <param name="currentData"></param>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.BeginAdd``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynchronously adds a new item to the collection.
            </summary>
            <typeparam name="TValue">Item type.</typeparam>
            <param name="coll">Collection.</param>
            <param name="dispatcher">Identifies the thread the modification should happen on.</param>
            <param name="item">The item to be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.BridgeInto_Guarded_Slow``1(JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.DataFlow.ICollectionEvents{``0},JetBrains.Threading.ReentrancyGuard,System.Object)">
            <summary>
            Bridges first collection modifications into the second collection, in the guarded context.
            Slow. Not suitable for large collections. Better use hashsets (both).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.PushForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},System.Func{``0,System.IDisposable})">
            <summary>
            Executes a pair of actions for each of the items in the collection.
            When a new items comes into view, executes the <paramref name="handler"/> for it. The return value of the <paramref name="handler"/> is the closing bracket and will be executed when the collection item goes off the view.
            </summary>
            <typeparam name="TValue">Type of the collection items.</typeparam>
            <param name="coll">The collection.</param>
            <param name="handler">The handler that executes the opening bracket and returns an <see cref="T:System.IDisposable"/> that executes the closing bracket when disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEventsEx_ObsoleteWithoutLifetime.PushForEachItem``1(JetBrains.DataFlow.ICollectionEvents{``0},System.Func{JetBrains.DataFlow.AddRemoveEventArgs{``0},System.IDisposable})">
            <summary>
            Executes a pair of actions for each of the items in the collection.
            When a new items comes into view, executes the <paramref name="handler"/> for it. The return value of the <paramref name="handler"/> is the closing bracket and will be executed when the collection item goes off the view.
            </summary>
            <typeparam name="TValue">Type of the collection items.</typeparam>
            <param name="coll">The collection.</param>
            <param name="handler">The handler that executes the opening bracket and returns an <see cref="T:System.IDisposable"/> that executes the closing bracket when disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Advises the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving the collection view).</para>
            <para>During an acknowledgement change, <see cref="!:BeforeAddRemoveEventArgs&lt;TValue&gt;.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving the collection view).</para>
            <para>During an acknowledgement change, <see cref="!:BeforeAddRemoveEventArgs&lt;TValue&gt;.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the items initially in the collection) and at the end of the lifetime (to acknowledge the final items of the collection and unbind from them correctly as from any other items leaving your view on the collection).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.AddRemoveEventArgs`1.IsAcknowledging"/> is <c>True</c>. When using this method, only real changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Add``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_Remove``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}})">
            <summary>
            Sinks the collection's <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/> operation selectively.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforeAddRemoveEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action{JetBrains.DataFlow.AddRemoveEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionSignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.AddRemoveIndexEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBagEx.LogChanges(JetBrains.DataFlow.IPropertyBag,JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Logs the changes to the bag property set and the bag property values.
            </summary>
            <param name="ths">The property.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.BeginSetValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            Asynhronously assigns a new value to the property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Cast``1(JetBrains.DataFlow.IUntypedProperty,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Casts the property value to the given type by creating a new property of that type.
            If the type of the value in the source property is wrong, an exception will be reported, and <c>Null</c> will be assigned to the target property for that period.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source property of the source type.</param>
            <param name="lifetime">Lifetime of the newly-created property.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0})">
             <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
             </summary>
             <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
             <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
            </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="target">The target property.</param>
            <param name="FConvert">Converter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
            </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="dispatcher">The dispatcher on which the assignment should occur.</param>
            <param name="target">The target property.</param>
            <param name="FConvert">Value converter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
            Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment goes on the same thread with the change.
            </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="dispatcher">The dispatcher on which the assignment should occur.</param>
            <param name="target">The target property.</param>
            <param name="FConvert">Value converter.</param>
            <param name="priority">Priority. Lowest is Idle, would wait the queue to empty.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The assignment occurs on the <paramref name="dispatcher" /> thread.
            </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="dispatcher">The dispatcher on which the assignment should occur.</param>
            <param name="target">The target property.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow between two properties.
            Creates a "PropertyBindingCore" of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            Creates a "PropertyBindingCore" of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/> type.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowChangesInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow of changes made to the source property between two properties.
            Does not flow a value when it is acknowledged.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowChangesInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow of changed made to the source property between two properties of different types, thru a converter.
            Does not flow a value when it is acknowledged.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoReadonly``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoReadonly``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes a data flow between two properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowIntoViaGroupingEvent``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.GroupingEvent,System.Boolean,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes one-way frequency-limited data flow between two properties.
            The target update occurs no more often than allowed by the grouping event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowInto_Grouped``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.Threading.GroupingEvent,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Establishes one-way frequency-limited data flow between two properties.
            The target update occurs no more often than allowed by the grouping event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Invert(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a boolean property with an inverter value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChangesAndStacktraces``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger,System.Nullable{JetBrains.Diagnostics.LoggingLevel})">
            <summary>
            Logs the changes to the property value and appends change stacktrace
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Object)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix,
            ie prepended in square brackets to each log message, or a <see cref="T:System.Type" /> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger,System.String,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
            <param name="level">A which level to log these events.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="lifetime">Duration of the logging.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
            <param name="level">A which level to log these events.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.LogChanges``1(JetBrains.DataFlow.Property{``0},JetBrains.Util.ILogger,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Logs the changes to the property value. Forever. Fluent, can be applied to .ctor.
            </summary>
            <param name="property">The property.</param>
            <param name="logger">The logger which serves as the logging context. Property name is added to each logged message.</param>
            <param name="level">A which level to log these events.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.MakeFlag``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Func{``0,System.Boolean},System.String)">
            <summary>
            Creates a flag property out of an arbitrary property which is either <c>True</c> or <c>False</c>,
            based on the <paramref name="FCondition"/> evaluated on the live value of the <paramref name="prop"/>.
            </summary>
            <typeparam name="TValue">Type of the source property.</typeparam>
            <param name="prop">The source property.</param>
            <param name="lifetime">Lifetime for the created property and its binding to the original property.</param>
            <param name="FCondition">The condition to be evaluated on each new value of the property.</param>
            <param name="sConditionName">The name of the condition. This name is appended to the <paramref name="prop"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.Id"/> to form the new <see cref="T:JetBrains.DataFlow.PropertyId`1"/> for the resulting flag.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.MakeFlag_NotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a flag property that indicates whether the <paramref name="prop"/> currently has a non-<c>Null</c> value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.OfType``1(JetBrains.DataFlow.IUntypedProperty,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Softly casts the property value to the given type by creating a new property of that type.
            If the type of the value in the source property is wrong, a <c>Null</c> will be assigned to the target property for that period.
            </summary>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source property of the source type.</param>
            <param name="lifetime">Lifetime synchronization policy for the two properties.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes  before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes  before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Func{``0,System.Boolean},System.Action{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property (if it passes <paramref name="FCondition">the filter</paramref>) and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes  before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Func{``0,System.Boolean},System.Action{JetBrains.Lifetimes.Lifetime,``0,System.Object})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new value of the property (if it passes <paramref name="FCondition">the filter</paramref>) and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes  before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.DisposeEachValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Makes sure each value of the property is disposed of when it exits the property (just after the property is set to some other value).
            When the <paramref name="lifetime"/> terminates, the current value of the property is also disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.ForEachValue_NotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
            <para>Binds a lifetime to each new value of the property.</para>
            <para><paramref name="FHandler">Your handler</paramref> is called for each new non-<c>Null</c> value of the property and is given the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime">lifetime object</see> for that value. This per-value lifetime is terminated whenever a new value is assigned to the property, or when the <paramref name="lifetime"/> you define for this method terminates.</para>
            <para>Using the per-value lifetime, you can define a pair of actions (after-value-comes  before-value-goes) to be executed for each value, or spawn some activity for the duration of this value, etc.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.SetValue``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,``0,System.Object)">
            <summary>
            Temporarily sets the value to the property, for the duration of the <paramref name="lifetime"/>.
            When the <paramref name="lifetime"/> ends, the original value (by the moment of the method call) is restored.
            Prevents all writes to the property while this method holds.
            </summary>
            <param name="property">The property to process.</param>
            <param name="lifetime">Defines the value duration.</param>
            <param name="value">The property value to set.</param>
            <param name="cookie">An optional readonly cookie.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.When``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,``0,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets equal to <paramref name="value"/>.
            Closes the lifetime when the property value changes from <paramref name="value"/> to anything else, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="value">Value to compare <paramref name="property"/> value with.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.When``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Predicate{``0},System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value changes such that <paramref name="predicate"/> returns true.
            Closes the lifetime when the <paramref name="predicate"/> is no longer true, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="predicate">Predicate to test a property's value.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenTrue(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets <c>True</c>.
            Closes the lifetime when the property value changes to <c>False</c>, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenTrueOnce(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            Execute activity once when property becomes true
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenFalseOnce(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            Execute activity once when property becomes false
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenEqualsOnce``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Action,``0)">
            <summary>
            Execute activity once when property becomes equals to specific value
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.WhenFalse(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Creates a lifetime (and calls your handler) whenever the property value gets <c>False</c>.
            Closes the lifetime when the property value changes to <c>True</c>, or the lifetime of this method ends.
            </summary>
            <param name="property">The property whose value is to be monitored.</param>
            <param name="lifetime">Duration for the rules defined by this method.</param>
            <param name="FHandler">The handler that is executed when the value raises.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Select``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.String,System.Func{``0,``1})">
            <summary>
            Creates a new property whose value is produced from the source property value.
            Analogous to the LINQ <c>Select</c> functionality.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source value.</param>
            <param name="comment">Adds a comment suffix to the Property ID.</param>
            <param name="FSelect">Selector.</param>
            <param name="lifetime">Lifetime control.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Select``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.String,System.Func{JetBrains.Lifetimes.Lifetime,``0,``1})">
            <summary>
            Creates a new property whose value is produced from the source property value (allows to create lifetimed values).
            Analogous to the LINQ <c>Select</c> functionality.
            </summary>
            <typeparam name="TSource">Source type.</typeparam>
            <typeparam name="TTarget">Target type.</typeparam>
            <param name="propSource">Source value.</param>
            <param name="comment">Adds a comment suffix to the Property ID.</param>
            <param name="FSelect">Selector.</param>
            <param name="lifetime">Lifetime control.</param>
            <returns>A newly-created target property of the target type.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.TryGetPropertyType(System.Type)">
            <summary>
            When given a <see cref="T:System.Type"/> of a CLR field or property that has the <see cref="T:JetBrains.DataFlow.IProperty`1"/> type wrapping some other type, unwraps and returns the underlying type of the property (generic argument, the same as its <see cref="P:JetBrains.DataFlow.IUntypedProperty.PropertyType"/>). If the <paramref name="type"/> is not a property type, returns <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.FlowDeferredIntoCore``2(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Threading.JetDispatcher},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},JetBrains.Util.Threading.Tasks.TaskPriority)">
            <summary>
             Creates a one-way from-source binding between two properties, deferring the new value until execution gets off stack and collecting all the assignments that happen within that time span. The intermediate values are lost, assignments are not replayed, just the last one is applied. The thread to run the assignment on is determined by the function <paramref name="FGetDispatcher" />.
            </summary>
            <param name="source">The source property.</param>
            <param name="lifetime">Lifetime of the binding.</param>
            <param name="FGetDispatcher">Determines the thread to use.</param>
            <param name="target">The target property.</param>
            <param name="FConvert">Value converter.</param>
            <param name="priority">Priority. Lowest is Idle, would wait the queue to empty.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.CreateUntypedProperty(JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean},JetBrains.Util.ILogger)">
            <summary>
            <para>Creates an instance of the <see cref="T:JetBrains.DataFlow.Property`1"/> class in a context where you cannot have generic specialization to its type and have to operate the <see cref="T:JetBrains.DataFlow.IUntypedProperty"/> interface.</para>
            <para>For help on parameters, see the <see cref="T:JetBrains.DataFlow.Property`1"/> ctor parameters.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.SetValueUnderLifetime``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
                <para>Sets a value to the property. The value has a lifetime until it's removed from the property.</para>
                <para>You're called a function with the prospected value lifetime, to produce the value object.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.CombineCustom``3(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.String,System.Func{``0,``1,``2})">
            <summary>
            Makes a property which combines a LIVE value of two other properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Combine``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Makes a property which combines a LIVE value of two other properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx.Combine``3(JetBrains.DataFlow.IProperty{System.ValueTuple{``0,``1}},JetBrains.DataFlow.IProperty{``2})">
            <summary>
            Makes a property which combines a LIVE value of two other properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushForEachValue``1(JetBrains.DataFlow.IProperty{``0},System.Func{``0,System.IDisposable})">
            <summary>
            Executes a pair of actions for each new value of the <paramref name="property"/>.
            For each new value of the property, the <paramref name="handler"/> is executed.
            Its return value is disposed of when the property looses the value for each it were executed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushValue``1(JetBrains.DataFlow.IProperty{``0},``0,System.Object)">
            <summary>
            Pushes the given value into the property when entering the try-finally brackets, pops (restores the former value) when exiting, which happens when the return value gets disposed of.
            The in-brackets writes are not handled.
            </summary>
            <param name="property">The property to process.</param>
            <param name="value">In-brackets property value.</param>
            <param name="cookie">An optional readonly cookie.</param>
            <returns>An instance to dispose of when leaving the brackets.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.PushValue``1(JetBrains.DataFlow.IProperty{``0},``0)">
            <summary>
            Pushes the given value into the property when entering the try-finally brackets, pops (restores the former value) when exiting, which happens when the return value gets disposed of.
            The in-brackets writes are not handled.
            </summary>
            <param name="property">The property to process.</param>
            <param name="value">In-brackets property value.</param>
            <returns>An instance to dispose of when leaving the brackets.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``0})">
            <summary>
            Establishes a data flow between two properties.
            Creates a "PropertyBindingCore" of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource" /> type.
            Returns a cookie for terminating the flow.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.FlowInto``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1})">
            <summary>
            Establishes a data flow between two properties of different types, thru a converter.
            Creates a "PropertyBindingCore" of the <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource" /> type.
            Returns a cookie for terminating the flow.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.LogChanges``1(JetBrains.DataFlow.IProperty{``0},System.String)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyEx_ObsoleteWithoutLifetime.LogChanges``1(JetBrains.DataFlow.IProperty{``0},System.Object)">
            <summary>
            Logs the changes to the property value.
            </summary>
            <param name="property">The property.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type"/> whose short name will be used.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertySignalEx">
            <summary>
            Extension methods to <see cref="T:JetBrains.DataFlow.ISignal`1"/> specific to the signals of the <see cref="T:JetBrains.DataFlow.IProperty`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value falls.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or unknown (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c>, or when the lifetime ends while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could deactivate something if an option is turned off or the lifetime of your component ends.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Executes the handler whenever the property value falls.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or unknown (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c>, or when the lifetime ends while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could deactivate something if an option is turned off or the lifetime of your component ends.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_FallingFrontHasNew(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{System.Boolean}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value falls (excluding the case when we're acknowleding the last value when unadvising the property change signal).</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or unknown (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes to <c>Null</c> (but not when the lifetime ends while a property value is non-<c>Null</c>).</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasOld``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">old value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the beginning of the lifetime, when there's only the new value of the property, but no old one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasOld``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">old value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the beginning of the lifetime, when there's only the new value of the property, but no old one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NewNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NewNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">new value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the value already in the property.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Advises the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.</para>
            <para>Acknowledgement changes are fired in the beginning of the lifetime (for the event sink to acknowledge the initial value of the property; the old value in the change arguments is undefined) and at the end of the lifetime (to acknowledge the final value of the property and unbind from it correctly as from any other value; the new value in the change arguments is undefined).</para>
            <para>During an acknowledgement change, <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging"/> is <c>True</c>; either <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> or <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> is <c>False</c>; getting the corresponding value throws an exception. When using this method, only real <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> &amp; <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/> changes are let through.</para>
            <para>Useful for user-restricting rather than data-restricting handlers, as those would not pass the value already in the property.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_OldNotNull``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="!:BeforePropertyChangedEventArgs&lt;x&gt;.Old">old value</see> for the property, and it is non-<c>Null</c>.</para>
            <para>This filter skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one; plus any change whose new value is <c>Null</c>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            <para>Filters property change events. Only calls the handler when the change has a <see cref="!:BeforePropertyChangedEventArgs&lt;x&gt;.New">new value</see> for the property.</para>
            <para>This filter only skips the acknowledgement change at the end of the lifetime, when there's only the old value of the property, but no new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            <para>Executes the handler whenever the property value raises.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or unknown (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes from <c>Null</c>, or when the lifetime starts while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could activate something if an option is turned on or the lifetime of your component begins.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            <para>Executes the handler whenever the property value raises.</para>
            <para>A high value is a non-<c>Null</c> value. A low value is a <c>Null</c> or unknown (outside of lifetime).</para>
            <para>This means that the handler will be called when property value changes from <c>Null</c>, or when the lifetime starts while a property value is non-<c>Null</c>.</para>
            <para>For example, in the handler you could activate something if an option is turned on or the lifetime of your component begins.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,``0,System.Action)">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="!:Advise_HasNew&lt;TValue&gt;(JetBrains.DataFlow.ISignal&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;,ObsoleteLifetimeAndDefinitionAtTheSameTime,System.Action)"/> invocations to only those whose new-value is <paramref name="valueWhen"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="!:Advise_HasNew&lt;TValue&gt;(JetBrains.DataFlow.ISignal&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;,ObsoleteLifetimeAndDefinitionAtTheSameTime,System.Action&lt;JetBrains.DataFlow.PropertyChangedEventArgs&lt;TValue&gt;&gt;)"/> invocations to only those whose new-value fits the <paramref name="FFilter"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.Change"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_NoAcknowledgement``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.BeforePropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Sinks the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> so that the handler is not acknwledged.
            Useful for user-restricting rather than data-restricting handlers, as those would not pass the data already in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action)">
            <summary>
            Invokes the handler on the raising front of the boolean property value, that is, when anything changes to <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_RaisingFront``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})">
            <summary>
            Invokes the handler on the raising front of the boolean property value, that is, when anything changes to <c>True</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_When``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Invokes the handler for specific property values only. Filters down the <see cref="M:JetBrains.DataFlow.IPropertySignalEx_ObsoleteWithoutLifetime.Advise_HasNew``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.PropertyChangedEventArgs{``0}},System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{``0}})"/> invocations to only those whose new-value passes the <paramref cref="!:filter"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ISignalEx">
            <summary>
            Extension method helpers for the data flow classes related to signals.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,System.Action)">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            This is an overload for a handler that does not need event arguments.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise_InOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},JetBrains.Lifetimes.Lifetime,System.Func{``0,``1})">
            <summary>
            A helper for sinking IN-OUT events. Gets just the IN-argument for input, returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Advise_Out``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.OutEventArgs{``0}},JetBrains.Lifetimes.Lifetime,System.Func{``0})">
            <summary>
            A helper for sinking OUT events. Returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)">
            <summary>
            For a signal that has an in-out value, fires the signal and collects the out-value.
            </summary>
            <remarks>Method name is not <c>Fire</c> because otherwise the <see cref="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)"/> overload conflicts with <see cref="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)"/>.</remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire(JetBrains.DataFlow.ISimpleSignal,JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            <para>Asynchronously fires the signal on the thread identified by the dispatcher.</para>
            <para>The deferred firing is canceled if the lifetime terminates before it is invoked.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.Fire``1(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.OutEventArgs{``0}})">
            <summary>
            For a signal that has an out-value only, fires the signal and collects the out-value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0)">
            <summary>
            For a signal that has an in-out value, fires the signal and collects the out-value.
            </summary>
            <remarks>Method name is not <c>Fire</c> because otherwise the <see cref="M:JetBrains.DataFlow.ISignalEx.FireInOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},``0,``1)"/> overload conflicts with <see cref="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)"/>.</remarks>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowDeferredInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a one-way binding between two signals, deferring the action until execution gets off stack and collecting all the signals that happen within that time span.
            </summary>
            <param name="source">The source signal.</param>
            <param name="lifetime">Lifetime for the flow set-up. If there are any pending firings to flow to the target when the lifetime terminates, such firings are dropped.</param>
            <param name="target">The target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISignal{``0})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto``2(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISignal{``1},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent signal.</param>
            <param name="FConvert">Function that converts the high value of the source signal to value for the target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.FlowInto(JetBrains.DataFlow.ISimpleSignal,JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two simple signals.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="lifetime">Lifetime for the flow set-up.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="ths">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="prefix">The optional prefix to be prepended in square brackets to each log message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,System.Object)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="ths">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="logprefix">The object whose local name will be used as a logging prefix, ie prepended in square brackets to each log message, or a <see cref="T:System.Type" /> whose short name will be used.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event.
            </summary>
            <param name="ths">The event.</param>
            <param name="lifetime">Lifetime for the logging set-up.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings``1(JetBrains.DataFlow.Signal{``0},JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event. Forever. Fluent, can be used with the .ctor.
            </summary>
            <param name="ths">The event.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx.LogFirings(JetBrains.DataFlow.SimpleSignal,JetBrains.Util.ILogger)">
            <summary>
            Logs the event firings and the payload of the event. Forever. Fluent, can be used with the .ctor.
            </summary>
            <param name="ths">The event.</param>
            <param name="logger">The logger which serves as the logging context. Signal name is added to each logged message.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise``1(JetBrains.DataFlow.ISignal{``0},System.Action)">
            <summary>
            Advises the signal event so that the <paramref name="handler"/> is called when the signal fires.
            Unadvises when the return value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise_InOut``2(JetBrains.DataFlow.ISignal{JetBrains.DataFlow.InOutEventArgs{``0,``1}},System.Func{``0,``1})">
            <summary>
            A helper for sinking IN-OUT events. Gets just the IN-argument for input, returns the OUT-argument.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.Advise``1(JetBrains.DataFlow.ISignal{``0},System.Action{``0})">
            <summary>
            Advises the signal event so that the <paramref name="handler"/> is called when the signal fires.
            Unadvises when the return value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire(JetBrains.DataFlow.ISimpleSignal,JetBrains.Threading.JetDispatcher)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.JetDispatcher,``0)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.BeginFire``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Threading.JetDispatcher,``0,System.Object)">
            <summary>
            Asynhronously fires the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowDeferredInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a one-way binding between two signals, deferring the action until execution gets off stack and collecting all the signals that happen within that time span.
            </summary>
            <param name="source">The source signal.</param>
            <param name="target">The target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``1(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISignal{``0})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto``2(JetBrains.DataFlow.ISignal{``0},JetBrains.DataFlow.ISignal{``1},System.Func{``0,``1})">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two signals, the second one a reduced simple signal.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent signal.</param>
            <param name="converter">Function that converts the high value of the source signal to value for the target signal.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignalEx_ObsoleteWithoutLifetime.FlowInto(JetBrains.DataFlow.ISimpleSignal,JetBrains.DataFlow.ISimpleSignal)">
            <summary>
            Creates a <see cref="F:JetBrains.DataFlow.DataFlowDirection.FromSource"/>-binding for two simple signals.
            </summary>
            <param name="source">The originating signal.</param>
            <param name="target">The dependent simple signal.</param>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyChangeEventArgsEx">
            <summary>
            Extension method helpers for the data flow classes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.GetNewOrNull``1(JetBrains.DataFlow.PropertyChangedEventArgs{``0})">
            <summary>
            <para>If there's the new value in the change (<see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/>), returns it.</para>
            <para>Otherwise, returns <c>Null</c>.</para>
            <para>When the lifetime is terminated, an acknowledgement change is fired to acknowledge your event sink that it's being disconnected from the last value of the property. In this case there's no new value in the change.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.GetOldOrNull``1(JetBrains.DataFlow.PropertyChangedEventArgs{``0})">
            <summary>
            <para>If there's the old value in the change (<see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/>), returns it.</para>
            <para>Otherwise, returns <c>Null</c>.</para>
            <para>When you start sinking the property change events, an acknowledgement change is fired to acknowledge your event sink with the current value of the property, as if it's just being set. In this case there's no old value in the change.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangeEventArgsEx.IsRaising(JetBrains.DataFlow.PropertyChangedEventArgs{System.Boolean})">
            <summary>
            Gets whether the boolean property value is raising (changing from <c>False</c> or unknown to <c>True</c>).
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidationException">
            <summary>
            Thrown when a suggested property value fails to pass the validation.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyValidationException.Property">
            <summary>
            The property that was attempted to be changed.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyValidationException.Value">
            <summary>
            The attempted new value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidator">
            <summary>
            Validates properties by preventing certain values from being assigned to the property.
            Note that for the validator to attach, the original value must pass validation.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates the validtor. It's held by a reference from the property ever since.
            Attaches a validator to the property whose type is an <see cref="T:System.Enum"/>.
            Ensures that the value belongs to the enum values list.
            </summary>
            <param name="ths">The proeprty to validate. Must be of an enum-based type.</param>
            <param name="lifetime">The lifetime for the validation constraint.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateMaximumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            Compares the suggested property values with the maximum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateMinimumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            Compares the suggested property values with the minimum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateNotEmptyValidator(JetBrains.DataFlow.IProperty{System.String},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Enforces non-empty values for the string property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateReadonlyValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the given <paramref name="thread"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.CreateThreadAffinityValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher)">
            <summary>
            Ensures the <paramref name="ths"/> is modified only on the <paramref name="dispatcher"/>'s thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.Freeze``1(JetBrains.DataFlow.IProperty{``0},System.String)">
            <summary>
            Makes the property Frozen, which means its value cannot be changed from now on.
            Allows to specify a custom message.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidator.Freeze``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Makes the property Frozen, which means its value cannot be changed from now on.
            Allows to specify a custom message.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyValidatorFluent">
            <summary>
            Fluent-Api property validators from <see cref="T:JetBrains.DataFlow.PropertyValidator"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.CoerceToRange``1(JetBrains.DataFlow.Property{``0},``0,``0)">
            <summary>
            Coerces the property values so that they fall into the given range, inclusive. No exceptions are thrown. The soft version of <see cref="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotOutside``1(JetBrains.DataFlow.Property{``0},``0,``0)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureEnum``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            <see cref="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureEnum``1(JetBrains.DataFlow.IProperty{``0})">
            <summary>
            <see cref="M:JetBrains.DataFlow.PropertyValidator.CreateEnumValidator``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureInitonly``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            Ensures that only one assignment to the property is allowed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotAbove``1(JetBrains.DataFlow.Property{``0},``0)">
            <summary>
            Compares the suggested property values with the maximum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotBelow``1(JetBrains.DataFlow.Property{``0},``0)">
            <summary>
            Compares the suggested property values with the minimum, which is inclusive.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureNotOutside``1(JetBrains.DataFlow.Property{``0},``0,``0)">
            <summary>
            Ensures that property values fall into the given range, inclusive. Throws if values out of range. The hard version of <see cref="M:JetBrains.DataFlow.PropertyValidatorFluent.CoerceToRange``1(JetBrains.DataFlow.Property{``0},``0,``0)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureReadonly``1(JetBrains.DataFlow.Property{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureReadonly``1(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly property. All the legitimate setters must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureThisThread``1(JetBrains.DataFlow.Property{``0})">
            <summary>
            Ensures the <paramref name="property"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyValidatorFluent.EnsureThisThread``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="property"/> is modified only on the thread this function was called on.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SignalValidator">
            <summary>
            Validations for signal firings.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureReadonly``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly signal. All the legitimate <see cref="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)"/> calls must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureReadonly(JetBrains.DataFlow.SimpleSignal,JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
            <summary>
            Makes a readonly signal. All the legitimate <see cref="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)"/> calls must pass the <paramref name="token"/> as an argument.
            If the <paramref name="token"/> is invalid, an exception is thrown.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThisThread``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="signal" /> is fired only on the current thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThread``1(JetBrains.DataFlow.ISignal{``0},JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="signal" /> is fired only on the given thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThisThread(JetBrains.DataFlow.SimpleSignal,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Ensures the <paramref name="signal" /> is fired only on the thread this function was called on.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SignalValidator.EnsureThread(JetBrains.DataFlow.SimpleSignal,JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Ensures the <paramref name="signal" /> is fired only on the given thread.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ICollectionEvents`1">
            <summary>
            A collection that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added or removed.
            To prevent the add/remove operation, set <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> (decline the operation silently) or throw an exception (the exception is let out to the caller). 
            After the first handler to cancel the operation, the remaining handlers may not be called.
            No <see cref="P:JetBrains.DataFlow.IReadonlyCollectionEvents`1.AddRemove"/> are guaranteed to be executed if the operation is cancelled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ICollectionEvents`1.Count">
            <summary>
            Gets the number of elements contained in the collection.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)">
            <summary>
            Attempts to add the item to the collection.
            </summary>
            <param name="value">The value to be added.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was added to the collection. An addition can be cancelled by the duplicates merger or the before-added handlers.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Executes the <see cref="M:JetBrains.DataFlow.ICollectionEvents`1.Add(`0,System.Object)"/> operation for all the elements in the given collection.
            </summary>
            <param name="items">The collection whose elements should be added.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Modify(JetBrains.Collections.Viewable.AddRemove,`0,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="T:JetBrains.Collections.Viewable.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Remove(`0,System.Object)">
            <summary>
            Attempts to remove a value from the collection.
            </summary>
            <param name="value">The value to be removed.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the item was removed from the collection. A removal may fail either if the item is missing from the collection, or the before-removed handlers have cancelled the operation.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.ICollectionEvents`1.Clear(System.Object)">
            <summary>
            Removes all items from the collection.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IDictionaryEvents`2">
            <summary>
            A dictionary that fires events when items are added or removed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IDictionaryEvents`2.TryGetValue(`0,System.Func{`1})">
            <summary>
            Attempts to look up a value by its <paramref name="key"/> in the dictionary.
            In case there is no such key-value pair present, uses the <paramref name="funcCreateIfMissing"/> function to create a new value, and then places it into the dictionary under the <paramref name="key"/>.
            </summary>
            <param name="key">Key to the value we're trying to look up.</param>
            <param name="funcCreateIfMissing">In case there is no <paramref name="key"/> in the dictionary, produces a new value to be stored in the dictionary and returned to the caller.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.DataFlow.IHaveUntypedProperty">
            <summary>
            An interface for getting <see cref="T:JetBrains.DataFlow.IUntypedProperty"/> from a <see cref="T:JetBrains.DataFlow.IProperty`1"/> in an untyped manner.
            Allows to get the property value in a nongeneric method (e.g. in property value serializer).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IHaveUntypedProperty.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IListEvents`1">
            <summary>
            A list that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">List values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.IListEvents`1.BeforeAddRemove">
            <summary>
            Fires before an item is added or removed.
            To prevent the add/remove operation, set <see cref="P:JetBrains.DataFlow.BeforeAddRemoveEventArgs`1.Cancel"/> to <c>True</c> (decline the operation silently) or throw an exception (the exception is let out to the caller). 
            After the first handler to cancel the operation, the remaining handlers may not be called.
            No <see cref="!:ICollectionEvents&lt;TValue&gt;.AddRemove"/> are guaranteed to be executed if the operation is cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IListEvents`1.Modify(JetBrains.Collections.Viewable.AddRemove,`0,System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="T:JetBrains.Collections.Viewable.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="item">The item to add or remove. When doing the remove operation, this parameter is ignored and the index is used instead.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IListEvents`1.Modify(JetBrains.Collections.Viewable.AddRemove,System.Func{`0},System.Int32,System.Object)">
            <summary>
            A universal method for modifications on the collection. Useful for data flow between the collections, when <see cref="T:JetBrains.Collections.Viewable.AddRemove"/> signal handler is pumping into another collection.
            </summary>
            <param name="action">Whether to add or remove the item.</param>
            <param name="funcGetItemIfAdding">A function that is called only when doing the <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> operation and produces the new item to be added to the list. This allows to create a new item when pumping from one collection to another with creating the wrappers simultaneousely.</param>
            <param name="index">The index at which the modification should occur.</param>
            <param name="cookie">The optional modification cookie.</param>
            <returns>Success code.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.Infra.SignalWithDelegates`1">
            <summary>
            A signal-inheritor that exposes the signal's virtual methods as delegates.
            The signal has virtual methods instead of delegates because it's cheaper to call the virtual method, which is essential for the property case, for example. Less performance-critical scenarios (like collections) would use delegates instead of inheriting custom classes.
            </summary>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.AfterAdviseHandler">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.AfterUnadviseHandler">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SignalWithDelegates`1.BeforeAdviseHandler">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnAfterAdvise(System.Action{`0})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnAfterUnadvise(System.Action{`0})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SignalWithDelegates`1.OnBeforeAdvise(System.Action{`0})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates">
            <summary>
            A signal-inheritor that exposes the signal's virtual methods as delegates.
            The signal has virtual methods instead of delegates because it's cheaper to call the virtual method, which is essential for the property case, for example. Less performance-critical scenarios (like collections) would use delegates instead of inheriting custom classes.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.AfterAdviseHandler">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.AfterUnadviseHandler">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.BeforeAdviseHandler">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnAfterAdvise(System.Action{System.Boolean})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnAfterUnadvise(System.Action{System.Boolean})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Infra.SimpleSignalWithDelegates.OnBeforeAdvise(System.Action{System.Boolean})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.InOutEventArgs`2">
            <summary>
            An event arguments class with one typed constant value, plus one typed mutable value that can be changed by any consumer.
            </summary>
            <typeparam name="TIn">Type of the incoming value that is constant and cannot be changed.</typeparam>
            <typeparam name="TOut">Type of the outgoing value that is intended to be set by the event sink.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.InOutEventArgs`2.#ctor(`0,`1)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> parameter set to its predefined value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.InOutEventArgs`2.#ctor(`0)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> parameter set to <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.InOutEventArgs`2.In">
            <summary>
            Gets the event data specified by the event source.
            Generally, it specifies which/how the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.Out"/> data should be filled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.InOutEventArgs`2.Out">
            <summary>
            Data to be provided by the event sink, based on the event semantics and the <see cref="P:JetBrains.DataFlow.InOutEventArgs`2.In"/> value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IProperty`1">
            <summary>
            A property that tracks the changes, validates new values being assigned, and notifies of the change.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.Value">
            <summary>
            Gets or sets the value by wrapping the <see cref="M:JetBrains.DataFlow.IProperty`1.GetValue"/> and <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0)"/> calls.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IProperty`1.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.GetValue">
            <summary>
            Gets the property value.
            </summary>
            <returns>The current property value, whose nullability depends on <see cref="T:System.Nullable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="T:System.Nullable"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.SetValue(`0)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="T:System.Nullable"/>.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="T:System.Nullable"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBag.GetOrCreateProperty``1(JetBrains.DataFlow.PropertyId{``0},``0,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed">Whether <c>Null</c> values are accepted by the property.</param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBag.Remove``1(JetBrains.DataFlow.PropertyId{``0})">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBag.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyBinding`2">
            <summary>
            Binds together two <see cref="T:JetBrains.DataFlow.IProperty`1"/>s.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding`2.Direction">
            <summary>
            Gets the binding direction.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IPropertyBinding">
            <summary>
            A non-generic version of the <see cref="T:JetBrains.DataFlow.IPropertyBinding`2"/> interface for automated bulk processing.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Direction">
            <summary>
            Gets the binding direction.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IPropertyBinding.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IPropertyBinding.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IReadonlyCollectionEvents`1">
            <summary>
            A collection that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">Collection values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.IReadonlyCollectionEvents`1.AddRemove">
            <summary>
            Fires when an item is added or removed to your view on the collection.
            Throwing an exception does not prevent the item from being added or other handlers from being called.
            The event supports acknowledgment, which means that when you sink the event, all of the items currently in collection come into your view on the collection, so the add is fired for each. Similarly, remove is fired when you unsink and all of the elements go away from your view on the collection.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IReadonlyCollectionEvents`1.Id">
            <summary>
            Gets the identification for this list.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IReadonlyCollectionEvents`1.ToArray">
            <summary>
            <para>A thread-save version of the LINQ call.</para>
            </summary>
            <remarks>
            <para>The regular version for collections takes the <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> and then calls <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>, which is race condition prone.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.DataFlow.IReadonlyCollectionEvents`1.ToList">
            <summary>
            <para>A thread-save version of the LINQ call.</para>
            </summary>
            <remarks>
            <para>The regular version for collections takes the <see cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/> and then calls <see cref="M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)"/>, which is race condition prone.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.DataFlow.IReadonlyListEvents`1">
            <summary>
            A list that fires events when items are added or removed.
            </summary>
            <typeparam name="TValue">List values type.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.IReadonlyListEvents`1.AddRemove">
            <summary>
            Fires when an item is added or removed to your view on the collection.
            Throwing an exception does not prevent the item from being added or other handlers from being called.
            The event supports acknowledgement, which means that when you advise the event, all of the items currently in collection come into your view on the collection, so the add is fired for each. Similarly, remove is fired when you unadvise and all of the elements go away from your view on the collection.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ISignal`1">
            <summary>
            An event-like signal that can be sinked by any number of listeners, fired by any number of external callers, and takes part in the data flow infrastructure.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
            <typeparam name="TValue">The type of the payload, should a signal have any. <see cref="T:System.Boolean"/> is the simplest default.</typeparam>
            <remarks>
            <para>The signal uses an <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/> as its underlying transport.
            The signal is considered to be fired when the property value changes,
            has both <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/> and <see cref="T:JetBrains.DataFlow.PropertyChangedEventArgs`1"/>,
            and the value is falling (changes to <c>default(TValue)</c>).</para>
            <para>For the signal to take part in the data flow, use its underlying property in the bindings.</para>
            </remarks>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.Property">
            <summary>
            Gets the underlying property of the signal.
            Initially, the signal has no underlying property attached (unless you explicitly give it in the constructor).
            When the getter is accessed, an underlying property is created.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ISignal`1.AsUntyped">
            <summary>
            Gets the nongeneric version of the API to this object.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Fire(`0)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ISignal`1.Fire(`0,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)"/> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property"/>.</param>
        </member>
        <member name="T:JetBrains.DataFlow.ISimpleSignal">
            <summary>
            A simple <see cref="T:JetBrains.DataFlow.ISignal`1"/> that has no payload.
            Stands for the simple <see cref="T:System.EventHandler"/>-based event, but encapsulates the firing method, can take part in data flow, can be fired by an external user.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ISimpleSignal.Fire">
            <summary>
            Fires the signal.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IUntypedProperty">
            <summary>
            A non-generic version of the <see cref="T:JetBrains.DataFlow.IProperty`1"/> interface for automated bulk processing.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.PropertyType">
            <summary>
            Gets the type of the generic property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedProperty.AsTyped">
            <summary>
            Gets the generic version of the API to this object (<see cref="T:JetBrains.DataFlow.IProperty`1"/> specialized with <see cref="P:JetBrains.DataFlow.IUntypedProperty.PropertyType"/>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedProperty.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedProperty.SetValue(System.Object,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="E:JetBrains.DataFlow.IUntypedProperty.Disposed">
            <summary>
            Fires when the property disposes.
            This event does not acknowlegde subscriptions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedPropertyBag.GetOrCreateProperty(JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            The type is inferred from the generic data constant type <see cref="T:JetBrains.DataFlow.PropertyId`1"/>.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed"></param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedPropertyBag.Remove(JetBrains.DataFlow.PropertyId)">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.IUntypedSignal">
            <summary>
            A type-invariant interface to the <see cref="T:JetBrains.DataFlow.Signal`1"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.Property">
            <summary>
            Gets the underlying property of the signal.
            Initially, the signal has no underlying property attached (unless you explicitly give it in the constructor).
            When the getter is accessed, an underlying property is created.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.IUntypedSignal.ArgumentType">
            <summary>
            Gets the type of the signal arguments object. This is the type parameter of the typed <see cref="T:JetBrains.DataFlow.ISignal`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedSignal.Advise(JetBrains.Lifetimes.Lifetime,System.Action{System.Object})">
            <summary>
            Advises the signal event for the duration of the <paramref name="lifetime"/> so that the <paramref name="handler"/> is called when the signal fires.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.IUntypedSignal.Fire(System.Object,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)"/> of the underlying <see cref="P:JetBrains.DataFlow.IUntypedSignal.Property"/>.</param>
        </member>
        <member name="T:JetBrains.DataFlow.IViewable`1">
            <summary>
            A viewable collection of items 
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable">
            <summary>
            Serves two things: converts an <see cref="T:System.Action"/> into an <see cref="T:System.IDisposable"/>, and allows to replace a <c>tryfinally</c> construct with a <c>using</c>, which keeps the opening/closing actions together.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.Empty">
            <summary>
            A disposable class that does nothing on <see cref="M:System.IDisposable.Dispose"/>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.EmptyDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> stub.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket(System.Action,System.Action,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of.</para>
            <para>The disposal is optional, the <paramref name="closing"/> action will not be executed unless you explicitly call <see cref="M:System.IDisposable.Dispose"/>.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="trapExceptions">Whethe we must catch exceptions in <paramref name="opening"/> and <paramref name="closing"/> and log them or throw futher</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Disposal is optional.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateCompositeDisposable``1(System.Func{``0}[])">
            <summary>
            Emulates behavior of nested disposables with proper exception throwing, so
            <code>
            using (CreateCompositeDisposable(() => Cookie1(), () => Cookie2()))
            {
               ...
            }
            </code>
            
            is analogous to
            
            <code>
            using (Cookie1())
            {
              using (Cookie2())
              {
               ...
              }
            }
            </code>
            </summary>
            
            <typeparam name="T">inheritor of disposable for client code simplification</typeparam>
            <param name="disposables">functions that returns disposables</param>
            <returns>Disposable that is analogous to nesting disposables in arguments</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateAction(System.Action)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="closing"/> action is executed when the return value is disposed of.</para>
            <para>The disposal is optional, the <paramref name="closing"/> action will not be executed unless you explicitly call <see cref="M:System.IDisposable.Dispose"/>.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Disposal is optional.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalFromAction(System.Action)">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
            <param name="">The function to be executed when the disposable is first disposed of. Note that being a value type it does not have full control over multiple dispose calls if the instance is copied around.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalFromAction``1(``0,System.Action{``0})">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
            <param name="arg">The closure parameter. Allows to avoid creating a closure for <paramref name="" /> on each call, but define a reusable static delegate and pass the closure parameter manually.</param>
            <param name="">The function to be executed when the disposable is first disposed of. Note that being a value type it does not have full control over multiple dispose calls if the instance is copied around.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateAction_FinalizableFreeThreaded(System.String,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="closing"/> action is executed when the return value is disposed of.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket_FinalizableFreeThreaded(System.String,System.Action,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of, or when the finalizer for the object is called.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.CreateBracket_FinalizableSingleThreaded(System.String,System.Action,System.Action,System.String,System.Boolean)">
            <summary>
            <para>Enters the TryFinally bracket.</para>
            <para>The <paramref name="opening"/> action is executed immediately, the <paramref name="closing"/> one is executed when the return value is disposed of, or when the finalizer for the object is called.</para>
            <para>The disposal is mandatory, an exception is reported if the <paramref name="closing"/> action is executed by the finalizer, on the same thread as the opening action, if possible.</para>
            <para>Exceptions in actions are trapped.</para>
            </summary>
            <param name="id">Identifies the activity or its owner in case it fails or gets into the finalizer.</param>
            <param name="opening">An action that opens the two-action bracket. Executes immediately on enter.</param>
            <param name="closing">An action that closes the two-action bracket. Executes when you dispose of the return value.</param>
            <param name="messageFinalization">Optional message to throw out as an exception in case of a missed dispose. If omitted, the default exception will be issued, including the object <paramref name="id"/> in its text. If you replace the message, it's up to you whether to include the identifier with the message text.</param>
            <param name="saveCtorCallStack">Save the creating call stack and include it into exception details in case of a missed dispose.</param>
            <returns>A token that executes the <paramref name="closing"/> action when you dispose of it. Must be disposed of.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.FinalizableDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> adapter for an <see cref="T:System.Action"/> (or a pair of actions) that supports finalization.
            Must be disposed of, otherwise, the finalizer will report an error and invoke the closing action.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.FinalizableDisposable.myDispatcher">
            <summary>
            Non-Null if need to marshal from dtor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinalizableDisposable.#ctor(System.String,System.Action,System.Action,System.Boolean,System.Boolean,System.String,System.Boolean)">
            <summary>
            Defines the opening and closing bracket actions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinalizableDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.FinallyException">
            <summary>
            An exception thrown from the <see cref="T:JetBrains.DataFlow.Disposable"/> class, or any other finalizer representing a missed <see cref="M:System.IDisposable.Dispose"/> or some other problem in dispose.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.FinallyException.Id">
            <summary>
            ID of the object that caused the exception.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinallyException.LogMissedDispose(System.String,System.String,System.String)">
            <summary>
            Logs the error of a missed or failed dispose into the <see cref="T:JetBrains.Util.Logging.Logger"/>
            with <see cref="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)"/>.
            </summary>
            <param name="id">The failed object identity.</param>
            <param name="message">The failure explanation message.</param>
            <param name="sOriginatingStackTrace">The stack trace where the object were created, if available.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.FinallyException.LogMissedDispose(System.String)">
            <summary>
            Logs the error of a missed or failed dispose into the <see cref="T:JetBrains.Util.Logging.Logger"/> with <see cref="M:JetBrains.Util.Logging.Logger.LogException(System.Exception)"/>.
            </summary>
            <param name="id">The failed object identity.</param>
        </member>
        <member name="P:JetBrains.DataFlow.Disposable.FinallyException.StackTrace">
            <summary>
            Gets a string representation of the frames on the call stack at the time the current exception was thrown.
            </summary>
            
            <returns>
            A string that describes the contents of the call stack, with the most recent method call appearing first.
            </returns>
            <filterpriority>2</filterpriority><PermissionSet><IPermission class="System.Security.Permissions.FileIOPermission, mscorlib, Version=2.0.3600.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" version="1" PathDiscovery="*AllFiles*" /></PermissionSet>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.NonFinalizableDisposable">
            <summary>
            An <see cref="T:System.IDisposable"/> adapter for an <see cref="T:System.Action"/> (or a pair of actions) that does not support finalization.
            Nothing happens if the object is not disposed of.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.myId">
            <summary>
            Identifies the owner of a finalizable object.
            For non-finalizables this is optional (reverts to the default name).
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.myOpeningStackTrace">
            <summary>
            Optionally, captures the originating stack trace for the debugging needs.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.#ctor(System.String,System.Action,System.Action,System.Boolean,System.Boolean)">
            <summary>
            Defines the opening and closing bracket actions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Close">
            <summary>
            Exec the closing part.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Open(System.Action)">
            <summary>
            Exec the opening part.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.NonFinalizableDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.LocalDisposable">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.LocalDisposable.my">
            <summary>
            The action to execute on Dispose. In case of an <see cref="F:JetBrains.DataFlow.Disposable.LocalDisposable.Empty" /> value or an uninitialized structure that would be a no-op.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.LocalDisposable.Empty">
            <summary>
            An empty disposable which does nothing on dispose.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalDisposable.Dispose">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalDisposable.FromAction(System.Action)">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
            <param name="">The function to be executed when the disposable is first disposed of. Note that being a value type it does not have full control over multiple dispose calls if the instance is copied around.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalDisposable.FromAction``1(``0,System.Action{``0})">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
            <param name="arg">The closure parameter. Allows to avoid creating a closure for <paramref name="" /> on each call, but define a reusable static delegate and pass the closure parameter manually.</param>
            <param name="">The function to be executed when the disposable is first disposed of. Note that being a value type it does not have full control over multiple dispose calls if the instance is copied around.</param>
        </member>
        <member name="T:JetBrains.DataFlow.Disposable.LocalDisposable`1">
            <summary>
            An <see cref="T:System.IDisposable" /> implementation as a value type. If you are not casting it to <see cref="T:System.IDisposable" /> and only calling <see cref="M:System.IDisposable.Dispose" />, or putting to the C# <c>using</c> construct, there will be no boxing or heap object memory allocation. Reusing the delegate allows to implement allocations-free <c>using</c> construct.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Disposable.LocalDisposable`1.my">
            <summary>
            The action to execute on Dispose. In case of an <see cref="P:JetBrains.DataFlow.Disposable.LocalDisposable`1.Empty" /> value or an uninitialized structure that would be a no-op.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Disposable.LocalDisposable`1.Empty">
            <summary>
            An empty disposable which does nothing on dispose.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Disposable.LocalDisposable`1.Dispose">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AddDispose(JetBrains.Lifetimes.Lifetime,System.IDisposable[])">
            <summary>
             <para>Adds a series of objects to be schedulled for disposal upon termination of the lifetime.</para>
             <para>It is preferrable to pass the lifetime object in the constructor of the object to be terminated rather than to dispose the object explicitly. If this is your own object, it should usually be refactored to take a lifetime instead of exposing an <see cref="T:System.IDisposable"/> interface.</para>
             <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger and terminates the lifetime on the same thread this method was called.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>The calling thread must have a <see cref="T:JetBrains.Threading.JetDispatcher"/> for which async operations are not prohibited (see <see cref="P:JetBrains.Threading.JetDispatcher.IsAsyncBehaviorProhibited"/>).</para>
            <para>Also, if the shutdown is already in progress, the thread might not have a chance to process the request.</para>
            <para>These limitations result from schedulling the request with <see cref="M:JetBrains.Threading.JetDispatcher.BeginInvoke(System.String,System.Action,JetBrains.Util.Threading.Tasks.TaskPriority)"/>.</para>
            <para>Use this method if it's critical for you to terminate on the same thread (e.g. with COM Interop). Otherwise, prefer <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)"/>.</para>
            </remarks>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)"/>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_FreeThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger and terminates the lifetime on the finalizer thread.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>This method might not be suitable if you're guarding COM Interop termination or similar things because of their thread affinity. Consider using <see cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)"/> if this is the case.</remarks>
            <seealso cref="M:JetBrains.Lifetimes.Lifetime.AssertEverTerminated(System.String)"/>
            <seealso cref="M:JetBrains.DataFlow.LifetimeEx.EnsureEverTerminated_SingleThreaded(JetBrains.Lifetimes.LifetimeDefinition,System.String,System.Boolean)"/>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.Lifetimes.OuterLifetime)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.Lifetimes.OuterLifetime)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.AssertIsAlive(JetBrains.Lifetimes.LifetimeDefinition)">
            <summary>
            Throws an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.LogAssertIsAlive(JetBrains.Lifetimes.LifetimeDefinition)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated"/> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.EnsureGuarded(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.ReentrancyGuard)">
            <summary>
            Asserts preconditions for thread affinity and guarded execution for a bracket on this lifetime.
            This means the conditions must be met at the moment of the method call (opening bracket) and lifetime termination (closing bracket).
            This guarantees all of the other adjacent brackets or termination actions on this lifetime will be guarded too.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimeEx.Id(JetBrains.Lifetimes.OuterLifetime)">
            <summary>
            Logs an exception if the lifetime has already been terminated (<see cref="P:JetBrains.Lifetimes.Lifetime.IsTerminated" /> is <c>True</c>), and continues execution.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimesObsolete.Create(System.Boolean)">
            <summary>
            Creates a disposable container that either requires that it is disposed at some moment (<paramref name="finalize" /> = <c>True</c>) or just functions as a one-time composite without any obligations (<paramref name="finalize" /> = <c>False</c>).
            </summary>
            <param name="finalize"><c>False</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimesObsolete.Create(System.String)">
            <summary>
            Creates a disposable container that must be disposed of.
            If the <see cref="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.Dispose" /> method is never called, an exception is reported from the finalizer.
            </summary>
            <param name="id">An arbitrary string tag that helps to identify the origin of a particular disposables container that never gotten disposed of.</param>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimesObsolete.Create">
            <summary>
            Creates a simple lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimesObsolete.Create(System.String,System.Boolean)">
            <summary>
            Creates a disposable container that either requires that it is disposed at some moment (<paramref name="finalize" /> = <c>True</c>) or just functions as a one-time composite without any obligations (<paramref name="finalize" /> = <c>False</c>).
            </summary>
            <param name="id">An arbitrary string tag that helps to identify the origin of a particular disposables container that never gotten disposed of.</param>
            <param name="finalize">Whether the disposal is mandatory for the container. If yes, a finalizer is created that will report an exception. If no, the object does not add a strain to the finalization queue and does not do any implicit dispose on finalization.</param>
        </member>
        <member name="M:JetBrains.DataFlow.LifetimesObsolete.CreateAtomic(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Executes the <paramref name="FAtomic" /> in the transactional manner: if an exception is thrown, all of the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime" /> added during the execution are rolled back, and the exception is let out; in case of no exception, the <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime" /> produced by the <paramref name="FAtomic" /> are returned.
            The <see cref="T:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime" /> created for the <paramref name="FAtomic" /> are of the optional sort.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.IsEmpty">
            <summary>
            Gets whether the container is empty of any disposable items.
            This means that the object is in either non-initialized or already-disposed state.
            The container is not eligible for finalization in this state.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddDispose(System.IDisposable)">
            <summary>
             Adds an object that will be disposed of when the enclosing object is disposed of.
             Returns self to allow queueing the additions.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddAction(System.Action)">
            <summary>
            Adds an action to be executed when the container is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddBracket(System.Action,System.Action)">
            <summary>
            Adds a bracket of actions. The opening one is executed immediately, and the closing one  when the enclosing object is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeAndDefinitionAtTheSameTime.AddRef(System.Object)">
            <summary>
            Holds a reference to the given object <paramref name="object"/> until the container is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ObsoleteLifetimeEx.OpenNested(JetBrains.Lifetimes.Lifetime)">
            <summary>
            <para>Opens the nested lifetime. It will be terminated whenever this lifetime is terminated.</para>
            <para>Note: unlike adding a new lifetime to this one, the nested lifetime will be forgotten upon termination. This allows to open short-lived nested lifetimes repeatedly without overpolluting the parent lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.StackFramesToString(System.Diagnostics.StackFrame[])">
            <summary>
            Formats the stack frames.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureStackTraceConditionally(System.Boolean)">
            <summary>
            Captures stack trace only if <paramref name="bObeyOptionCaptureStackTraces"/> is false or <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/> is true. 
            </summary>
            <param name="bObeyOptionCaptureStackTraces"> if `true` checks <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/>; if false - delegates to <see cref="M:JetBrains.DataFlow.StackTraceUtil.CaptureStackTrace(System.Int32,System.Boolean,System.Exception)"/></param>
            <returns>'null' if (bObeyOptionCaptureStackTraces and OptionCaptureStackTraces); stack traces otherwise </returns>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureStackTrace(System.Int32,System.Boolean,System.Exception)">
            <summary>
            This method simply invokes <code> new StackFrame(...).GetFrames() </code> under lock.
            
            Old .Net framework has not synchronized access to Dictionary in StackTraceSymbols class that leads to deadlock. This is typically happens when you call new <see cref="T:System.Diagnostics.StackTrace"/>.
            To solve this problem we add static lock that acts as linearizer for  `new StackTrace()`'s . 
            
            Here is a typical stacktrace for deadlock:
            <para>
            	at System.Collections.Generic.Dictionary`2[[System.IntPtr, mscorlib],[System.__Canon, mscorlib]].Insert(IntPtr, System.__Canon, Boolean)
               at System.Diagnostics.StackTraceSymbols.TryGetReader(System.String, IntPtr, Int32, IntPtr, Int32)
               at System.Diagnostics.StackTraceSymbols.GetSourceLineInfoWithoutCasAssert(System.String, IntPtr, Int32, IntPtr, Int32, Int32, Int32, System.String ByRef, Int32 ByRef, Int32 ByRef)
               at System.Diagnostics.StackFrameHelper.InitializeSourceInfo(Int32, Boolean, System.Exception)
               at System.Diagnostics.StackTrace.CaptureStackTrace(Int32, Boolean, System.Threading.Thread, System.Exception)
               at System.Diagnostics.StackTrace..ctor(Int32, Boolean)
               at JetBrains.Util.LoggerException.CaptureStackTrace(Int32)
            </para> 
            </summary>
            <returns>stack frames, skipping <paramref name="skipFrames"/>+1</returns>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureAndFormatStackTrace(System.Boolean)">
            <summary>
            Captures the current stack trace, based on the <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/> setting.
            When the setting is <c>False</c>, a faster shortcut method with less info is used.
            If <param name="bObeyOptionCaptureStackTraces"/> is <c>False</c>, the stack trace is always fully-captured.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StackTraceUtil.CaptureAndFormatStackTrace">
            <summary>
            Captures the current stack trace, based on the <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces"/> setting.
            When the setting is <c>False</c>, a faster shortcut method with less info is used.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces">
            <summary>
            Whether to capture stack traces, or not.
            This is the manual switch which might be set to True from the Internal page.,
            Another option is to set logging level to TRACE for this class.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.StackTraceUtil.IsCaptureStackTraces">
            <summary>
            Whether to capture stack traces or not at this moment. Takes into account the <see cref="F:JetBrains.DataFlow.StackTraceUtil.OptionCaptureStackTraces" /> manual override and the <see cref="T:JetBrains.DataFlow.StackTraceUtil" /> logger category (if it's in <see cref="F:JetBrains.Diagnostics.LoggingLevel.TRACE" />).
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge`2">
            <summary>
            Bridges two ordered lists of items.
            The items flow from the first collection to the second one. Conversion and filtering is supported on the items.
            The order of projected items in the target list is kept in sync with the original items order.
            </summary>
            <typeparam name="TSource">Type of the source collection items.</typeparam>
            <typeparam name="TTarget">Type of the target collection items.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge`2.myIndexMapping">
            <summary>
            Stores the mapping from indices in the <see cref="P:JetBrains.DataFlow.ListBridge`2.Source"/> list to those in the <see cref="P:JetBrains.DataFlow.ListBridge`2.Target"/> list.
            Indices in <see cref="F:JetBrains.DataFlow.ListBridge`2.myIndexMapping"/> correspond to those in <see cref="P:JetBrains.DataFlow.ListBridge`2.Source"/>, values  to those in <see cref="P:JetBrains.DataFlow.ListBridge`2.Target"/>.
            A value <c>-1</c> means that the source item is missing from the target list (has been filtered out).
            Items of the target collection missing from the source one (like those manually added) are just missing from the map.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge`2.myMapItems">
            <summary>
            An optional map, can be <c>Null</c> if item-mapping is not needed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListBridge`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{`0},JetBrains.DataFlow.IListEvents{`1},System.Func{`0,`1},System.Func{`0,System.Boolean},JetBrains.DataFlow.ListBridge.MappingInfo,System.Object)">
            <summary>
            Wires up the bridge.
            </summary>
            <param name="lifetime">Lifetime for the bridge.</param>
            <param name="source">The source collection.</param>
            <param name="target">The target collection.</param>
            <param name="funcConverter">The conversion operator.</param>
            <param name="funcFilter">The mapping filter to exclude selected items from the target collection.</param>
            <param name="mappinginfo">Specifies whether the projection mapping information is maintained by the bridge.</param>
            <param name="oTaregtModificationCookie">An otpional cookie to be passed to the <paramref name="target"/> collection when performing modification operations on it.</param>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo">
            <summary>
            Gets whether the projection mapping information is maintained by the bridge.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.MapSourceToTarget">
            <summary>
            Gets the read-only source-to-target mapping.
            Available only if <see cref="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo"/>. Otherwise, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.MapTargetToSource">
            <summary>
            Gets the read-only target-to-source mapping.
            Available only if <see cref="P:JetBrains.DataFlow.ListBridge`2.HaveMappingInfo"/>. Otherwise, throws a <see cref="T:System.NotSupportedException"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.Source">
            <summary>
            Gets the source list.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.ListBridge`2.Target">
            <summary>
            Gets the target list.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge">
            <summary>
            Supplementary class for the <see cref="T:JetBrains.DataFlow.ListBridge`2"/> utility.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ListBridge.BridgeInto``2(JetBrains.DataFlow.IListEvents{``0},JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IListEvents{``1},System.Func{``0,``1},System.Func{``0,System.Boolean},JetBrains.DataFlow.ListBridge.MappingInfo,System.Object)">
            <summary>
            Mirrors one list into another thru a converter.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ListBridge.MappingInfo">
            <summary>
            Specifies which mapping info should be collected by the bridge.
            The mapping allows to translate source items into target ones and vice versa.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge.MappingInfo.None">
            <summary>
            No mapping information collected. No translation possible.
            Wastes less memory.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.ListBridge.MappingInfo.TwoWay">
            <summary>
            Full mapping information collected.
            Self-checks for consistency are also made on the mapping.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.ManualProperty">
            <summary>
            Creates properties bound to simple .NET properties or other manual data sources.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,System.Action{``0})">
            <summary>
            Creates a set-only property manually-bound to some external source via delegates.
            A set-only property is useful for placing at the end of the data flow.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.Lifetimes.Lifetime,System.String,System.Action{``0})">
            <summary>
            Creates a set-only property manually-bound to some external source via delegates.
            A set-only property is useful for placing at the end of the data flow.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,``0,System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="initialvalue">The initial value for the property.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.Lifetimes.Lifetime,System.String,``0,System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="initialvalue">The initial value for the property.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="getter">External value getter.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="M:JetBrains.DataFlow.ManualProperty.Create``1(JetBrains.Lifetimes.Lifetime,System.String,System.Func{``0},System.Action{``0})">
            <summary>
            Creates a property manually-bound to some external source via delegates.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
            <param name="lifetime">Lifetime for the property.</param>
            <param name="id">An identifier to tell the property apart.</param>
            <param name="getter">External value getter.</param>
            <param name="setter">External value setter.</param>
        </member>
        <member name="T:JetBrains.DataFlow.MarshallingBehaviors">
            <summary>
            Defines how the data flow is marshalled to another thread.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.MarshallingBehaviors.QueueAlways">
            <summary>
            Any data flow occurs asynchronously, even within a single thread.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.MarshallingBehaviors.QueueIfNeeded">
            <summary>
            Only cross-thread data flow is async, within a single thread it works just like a simple "PropertyBindingCore".
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.MarshallingPropertyBinding`2">
            <summary>
            A property binding that marshals all of the updates to the primary thread.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Threading.JetDispatcher,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            The ultimate ctor.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.MarshallingPropertyBinding`2.Dispatcher">
            <summary>
            Gets the dispatcher that defines the thread into which the operations are marshalled.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.MarshallingPropertyBinding`2.MarshallingBehavior">
            <summary>
            Gets or sets how the marshaller should behave, see <see cref="T:JetBrains.DataFlow.MarshallingBehaviors"/> for details.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.MarshallingPropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.NullProperty`1">
            <summary>
            The single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.NullProperty`1.Instance">
            <summary>
            The single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.OutEventArgs`1">
            <summary>
            An event arguments class with one typed mutable value that can be changed by any consumer.
            </summary>
            <typeparam name="TOut">Type of the outgoing value that is intended to be set by the event sink.</typeparam>
        </member>
        <member name="M:JetBrains.DataFlow.OutEventArgs`1.#ctor(`0)">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.OutEventArgs`1.Out"/> parameter set to its predefined value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.OutEventArgs`1.#ctor">
            <summary>
            Constructs the universal event args with the <see cref="P:JetBrains.DataFlow.OutEventArgs`1.Out"/> parameter set to <c>Null</c>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.OutEventArgs`1.Out">
            <summary>
            Data to be provided by the event sink, based on the event semantics.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1">
            <summary>
            A property that tracks the changes, validates new values being assigned, and notifies of the change.
            </summary>
            <typeparam name="TValue">Type of the property.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myHandlersDisposed">
            <summary>
            Stores the <see cref="E:JetBrains.DataFlow.Property`1.Disposed"/> handlers.
            Synth thru <see cref="F:JetBrains.DataFlow.Property`1.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myId">
            <summary>
            ID.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myIsNullValueAllowed">
            <summary>
            Determines whether the property can store NULL values.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.mySignalBeforeChange">
            <summary>
            The signal for the BeforeChange on the property.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.mySignalChange">
            <summary>
            The signal for the Change on the property.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Property`1.myValue">
            <summary>
            Stores the value of the property.
            Sync thru <see cref="F:JetBrains.DataFlow.Property`1.myLock"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(System.String)">
            <summary>
            <para>Initializes the property with the default initial value for its type.</para> 
            <para>The property will <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">have <c>Null</c> values allowed</see>, because it's required by the initial value of the property.</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.PropertyId{`0},`0)">
            <summary>
            <para>Initializes the property with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">
            <para>The initial value of the property.</para>
            <para>If set to a non-<c>Null</c> value (of a reference type), the property will not allow setting <c>Null</c> values at runtime (<see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed"/> = <c>False</c>).</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(System.String,`0)">
            <summary>
            <para>Initializes the property with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
            <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">
            <para>The initial value of the property.</para>
            <para>If set to a non-<c>Null</c> value (of a reference type), the property will not allow setting <c>Null</c> values at runtime (<see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed"/> = <c>False</c>).</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.Lifetimes.Lifetime,System.String,`0)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{`0},`0,System.Nullable{System.Boolean},JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.#ctor(JetBrains.DataFlow.PropertyId{`0},`0,System.Nullable{System.Boolean},JetBrains.Util.ILogger)">
            <summary>
            <para>The ultimate ctor.</para>
            <para>Initializes the property with the initial value.</para>
            <para>The property <see cref="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">allows <c>Null</c> values</see> if it's of a value type, and does not allow <c>Null</c> values if it's a reference type (unless explicitly initialized with <c>Null</c>).</para>
            </summary>
             <param name="id">
            <para>ID for the property. Allows to tell properties apart at runtime and when debugging.</para>
            <para>If callstack annotation is on, will appear on callstacks when property is modified. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="value">Initial value for the property. Must agree to <paramref name="isNullValueAllowed"/>.</param>
            <param name="isNullValueAllowed">
            <para>Specifies whether <c>Null</c> values can be assigned to the property. Note that this applies to value types also; a <c>Null</c>-disallowing <see cref="T:System.Int32"/> property will not allow assigning values of <c>0</c>.</para>
            <para>Overloads without this parameter use the Null value which means the default strategy: value types are allowed any values, and reference types are allowed <c>Null</c> values only if the initial <paramref name="value"/> is <c>Null</c>.</para>
            <para>This fits nearly all the cases, and you're encouraged to use overloads which do not set this parameter explicitly.</para>
            </param>
            <param name="logger">Logging facility optional override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ThrowReadonlyFail(JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0},System.Object)">
            <summary>
            Helper to throw an annotated exception whenever a property fails the readonly lock precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ThrowThreadAffinityFail(JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0},System.Threading.Thread)">
            <summary>
            Helper to throw an annotated exception whenever a property fails the threading affinity precondition.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireBeforeChange(`0,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.Property`1.BeforeChange"/> event, in course of assigning a new value to the property.
            If <c>False</c>, the transaction has been cancelled.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireChange(`0,`0,System.Object)">
            <summary>
            Fires the <see cref="P:JetBrains.DataFlow.Property`1.Change"/> event, in course of assigning a new value to the property.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FireDisposed">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.Disposed"/> event to the pre-stored list of handlers.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FirePropertyChanged">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.PropertyChanged"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.FirePropertyChanging">
            <summary>
            Fires the <see cref="E:JetBrains.DataFlow.Property`1.PropertyChanging"/> event.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.ToString">
            <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
            
            <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.Clone">
            <summary>
            Creates a new object that is a copy of the current instance.
            </summary>
            
            <returns>
            A new object that is a copy of this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="E:JetBrains.DataFlow.Property`1.Disposed">
            <summary>
            Fires when the property disposes.
            </summary>
        </member>
        <member name="E:JetBrains.DataFlow.Property`1.PropertyChanged">
            <summary>
            Occurs when a property value changes.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.System#IDisposable#Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.GetValue">
            <summary>
            Gets the property value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.SetValue(`0)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.SetValue(`0,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed" />.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange" /> handlers).</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#GetValue(System.Object)">
            <summary>
            Gets the property value.
            </summary>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>The current property value, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#SetValue(System.Object,System.Object)">
            <summary>
            Sets the property value, validates, notifies the sinks.
            </summary>
            <param name="value">The desired value of the property, whose nullability depends on <see cref="P:JetBrains.DataFlow.IUntypedProperty.IsNullValueAllowed"/>.</param>
            <param name="cookie">An optional cookie that comes along with the notification events data.</param>
            <returns>Whether the value has actually been set (was not cancelled by the <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> handlers).</returns>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.IsNullValueAllowed">
            <summary>
            Gets whether the property can store NULL values of reference types and zero values of value types.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.Value">
            <summary>
            Gets or sets the value by wrapping the <see cref="M:JetBrains.DataFlow.Property`1.GetValue"/> and <see cref="M:JetBrains.DataFlow.Property`1.SetValue(`0)"/> calls.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#BeforeChange">
            <summary>
            Gets the signal that fires when someone attempts to change the property value.
            Allows to cancel the change, either silently (by setting <see cref="P:JetBrains.DataFlow.BeforePropertyChangedEventArgs`1.Cancel"/> to <c>True</c>) or by throwing an exception from the handler.
            The handler is first called when sinking, and sinking is cancelled if the handler fails to pass the current value of the property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#Change">
            <summary>
            Gets the signal that fires when the sink's view on the property value changes.
            Note that the view changes from N/A to whatever value upon sinking, and back upon unsinking.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#Id">
            <summary>
            Gets the identifier of this property.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Property`1.JetBrains#DataFlow#IUntypedProperty#PropertyType">
            <summary>
            Gets the type of the generic property.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal">
            <summary>
            Handles the signals on the property events.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal.Acknowledge(System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0}},JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Acknowledges the <see cref="P:JetBrains.DataFlow.Property`1.BeforeChange"/> sinks.
            Returns whether the change is allowed.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyBeforeChangeSignal.OnBeforeAdvise(System.Action{JetBrains.DataFlow.BeforePropertyChangedEventArgs{`0}})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Property`1.PropertyChangeSignal">
            <summary>
            Handles the signals on the property events.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.Acknowledge(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}},JetBrains.Collections.Viewable.AddRemove)">
            <summary>
            Acknowledges the given handler with the property value, either on add or remove of the handler.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.OnAfterAdvise(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Property`1.PropertyChangeSignal.OnAfterUnadvise(System.Action{JetBrains.DataFlow.PropertyChangedEventArgs{`0}})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.Remove``1(JetBrains.DataFlow.PropertyId{``0})">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.JetBrains#DataFlow#IUntypedPropertyBag#Remove(JetBrains.DataFlow.PropertyId)">
            <summary>
            Tries to remove an existing property from the bag, returns whether successful (ie there really was such a property in the bag).
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBag.JetBrains#DataFlow#IUntypedPropertyBag#GetOrCreateProperty(JetBrains.DataFlow.PropertyId,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Creates a property in the bag, or picks an existing one.
            The type is inferred from the generic data constant type <see cref="T:JetBrains.DataFlow.PropertyId`1"/>.
            </summary>
            <param name="id">An identifier for the property.</param>
            <param name="defaultvalue">Default value to assign to the property initially.</param>
            <param name="isNullValueAllowed">Whether <c>Null</c> values are accepted by the property.</param>
            <returns>The newly-created property, or an existing one, if available.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding`2">
            <summary>
            Binds together two <see cref="T:JetBrains.DataFlow.IProperty`1"/>s.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myConverterSourceToTarget">
            <summary>
            The convertor implementation.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myConverterTargetToSource">
            <summary>
            The convertor implementation.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myDirection">
            <summary>
            Data flow direction, set to None initially to allow for initialization of the properties from their <c>Null</c> values.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.mySource">
            <summary>
            Stores the source property in yet another property, to allow for changing it later.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myTarget">
            <summary>
            Stores the target property in yet another property, to allow for changing it later.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding`2.myFreeze">
            <summary>
            Prevents recursion.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},System.Func{`0,`1})">
            <summary>
            Creates a one-way binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Creates a two-way binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Creates a binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0})">
            <summary>
            Creates a binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`1},JetBrains.DataFlow.DataFlowDirection,System.Func{`0,`1},System.Func{`1,`0},System.Object,System.Object)">
            <summary>
            The ultimate ctor.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.SourceCookie">
            <summary>
            An optional readonly cookie for reading and writing the source property values.
            <c>Null</c> by default.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Tag">
            <summary>
            A freehand tag for marking the instance, mostly for the debugging needs.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.TargetCookie">
            <summary>
            An optional readonly cookie for reading and writing the target property values.
            <c>Null</c> by default.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.OnConvertSourceToTargetDefault(`0)">
            <summary>
            The default converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.OnConvertTargetToSourceDefault(`1)">
            <summary>
            The default converter.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.CopySourceToTarget">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding`2.CopyTargetToSource">
            <summary>
            Executes the binding by copying the source value to the target value.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Direction">
            <summary>
            Gets or sets the binding direction.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Source">
            <summary>
            Gets or sets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.Target">
            <summary>
            Gets or sets the binding target.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.JetBrains#DataFlow#IPropertyBinding#Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBinding`2.JetBrains#DataFlow#IPropertyBinding#Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding`2.UsingNoneDirection">
            <summary>
            Make sure the bindings (and who's the value source) execute in their normal order, when the value is popped.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBinding">
            <summary>
            A non-generic static class that helps creating specific property bindings.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.False">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.True">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBinding.Zero">
            <summary>
            Gets a cached instance of a property that always has the same value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``0,``1},System.Func{``1,``0})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateBidirectional``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a two-way property binding.
            Initially, <paramref name="target"/> will be assighned the value of <paramref name="source"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},System.Func{``1,``0})">
            <summary>
            Creates a one-way property binding to source
            Initially, <paramref name="source"/> will be assighned the value of <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOneWayToSource``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1})">
            <summary>
            Creates a one-way property binding to source
            Initially, <paramref name="source"/> will be assighned the value of <paramref name="target"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create2``3(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},System.Func{``0,``1,``2},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create3``4(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.IProperty{``3},System.Func{``0,``1,``2,``3},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Create4``5(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.IProperty{``3},JetBrains.DataFlow.IProperty{``4},System.Func{``0,``1,``2,``3,``4},System.Object)">
            <summary>
            Creates a simple many-to-one binding.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAnd(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            ANDs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAnd(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},System.String)">
            <summary>
            ANDs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateAndMultibinding(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            Binds two <see cref="T:System.Boolean"/> properties to a third by ANDing their values.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateCascading``3(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{``0},System.Func{``0,JetBrains.DataFlow.IProperty{``1}},JetBrains.DataFlow.IProperty{``1},JetBrains.DataFlow.IProperty{``2},JetBrains.DataFlow.DataFlowDirection)">
            <summary>
            Creates a cascading binding, Owner.Source  Target, where Source is a property inside the Owner. Owner may change, and each time the Source is taken from the new Owner, and its changes are tracked.
            </summary>
            <param name="lifetime">Lifetime for the binding.</param>
            <param name="sourceowner">The owner object that may change with time, from which the Source for the binding is extracted by the means of the <paramref name="FGetSourceFromOwner"/> converter. Its value may become <c>Null</c>.</param>
            <param name="FGetSourceFromOwner">A function that knows how to find a source for the binding in each new <paramref name="sourceowner"/>. The owner object passed to it is always non-<c>Null</c>, because the <paramref name="propSourceWhenNoOwner"/> value is used automatically when <paramref name="sourceowner"/>'s value gets <c>Null</c>.</param>
            <param name="propSourceWhenNoOwner">When the <paramref name="sourceowner"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.Value"/> gets <c>Null</c>, this property is used for the binding source instead.</param>
            <param name="target">The target property for the binding.</param>
            <param name="direction">Binding direction.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateIsNotNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a bool property that is bound to whether <paramref name="source"/> is not <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateIsNull``1(JetBrains.DataFlow.IProperty{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates a bool property that is bound to whether <paramref name="source"/> is <c>Null</c>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateNot(JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Creates a binding that negates a value of the boolean property.
            The negated property is created inplace, and returned as a result.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOr(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            ORs two boolean properties.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.CreateOrMultibinding(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean},JetBrains.DataFlow.IProperty{System.Boolean})">
            <summary>
            Binds two <see cref="T:System.Boolean"/> properties to a third by ORing their values.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBinding.Null``1">
            <summary>
            Gets the single instance of a <see cref="T:JetBrains.DataFlow.IProperty`1">Property</see> whose value is always <c>Null</c>.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyBindingDeferred`1">
            <summary>
            Establishes a one-way property binding that defers application of the changes for some grace period.
            If a new change occurs within the grace period, the period is prolongated.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyBindingDeferred`1.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.IProperty{`0},JetBrains.DataFlow.IProperty{`0},System.TimeSpan,System.Object)">
            <summary>
            The ultimate ctor.
            Wires up the binding.
            </summary>
            <param name="lifetime">Lifetime of the binding. Recommended, but not 100% necessary, as the timer is held on weak ref.</param>
            <param name="source">The source property.</param>
            <param name="target">The target property.</param>
            <param name="graceperiod">The grace period for the changes to be withheld and accumulated.</param>
            <param name="targetcookie">An optional cookie for the <paramref name="target"/>'s write access.</param>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.GracePeriod">
            <summary>
            Gets or sets the grace period in which the changes to the <see cref="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Source"/> are accumulated.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.IncomingCommit">
            <summary>
            Immediately applies the pending changes, if there are any. Otherwise, does nothing.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.PropertyBindingDeferred`1.IsPending">
            <summary>
            Gets whether there currently are any pending changes.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Source">
            <summary>
            Gets the binding source.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyBindingDeferred`1.Target">
            <summary>
            Gets the binding target.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyChangedEventArgs`1">
            <summary>
            Notifies of the property change.
            Acknowledges the fact that the property change can be either from no value to something, or from something to no value.
            </summary>
            <typeparam name="TValue">Type of the value.</typeparam>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Cookie">
            <summary>
            Gets the property modification cookie (a freehand parameter).
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew">
            <summary>
            Gets whether the property will have a new value, ie <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New"/> is defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld">
            <summary>
            Gets whether the property had an old value, ie <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old"/> is defined.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.IsAcknowledging">
            <summary>
            Gets whether the handler is being called in the acknowledgement mode, that is, because the property is coming into view
            or going off the view, and its value effectively changes either from not known yet to some value, or the other way.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New">
            <summary>
            Gets the new value of the property.
            It's an error to request the value if not <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasNew"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old">
            <summary>
            Gets the old value of the property.
            It's an error to request the value if not <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.HasOld"/>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Property">
            <summary>
            Gets the property that has changed.
            You should use the <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.Old"/> and <see cref="P:JetBrains.DataFlow.PropertyChangedEventArgs`1.New"/> properties on this object instead of quering values from the property directly.
            You should not set new values to the property, unless you're sure you know what you're doing.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateBoth(JetBrains.DataFlow.IProperty{`0},`0,`0,System.Object)">
            <summary>
            Creates an instance that has both values defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateNew(JetBrains.DataFlow.IProperty{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the new value defined.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyChangedEventArgs`1.CreateOld(JetBrains.DataFlow.IProperty{`0},`0,System.Object)">
            <summary>
            Creates an instance that has only the old value defined.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyId`1">
            <summary>
            A typed identifier for a <see cref="T:JetBrains.DataFlow.Property`1"/> that specifies the property name and sets its type.
            Works as a typesafe <see cref="T:JetBrains.DataFlow.PropertyBag"/> accessor.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId`1.#ctor(System.String)">
            <summary>
            Creates the identifier.
            </summary>
            <param name="id">A non-empty string identifier.</param>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyId`1.Id">
            <summary>
            Gets the non-empty identifier text.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.PropertyId">
            <summary>
            The untyped base class for a <see cref="T:JetBrains.DataFlow.PropertyId`1">property identifier</see>.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.PropertyId.Id">
            <summary>
            Gets the non-empty identifier text.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.PropertyId.Create``1(System.String)">
            <summary>
            Creates a new strongly-typed property ID.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.Signal`1">
            <summary>
            <para>An event-like signal that can be advised by any number of event sinks, fired by any number of external callers, and takes part in the data flow infrastructure.</para>
            <para>Suitable for use in MVC's codebehind, when the event should be fireable by the views.</para>
            </summary>
            <typeparam name="TValue">The type of the payload, should a signal have any. <see cref="T:System.Boolean"/> is the simplest default.</typeparam>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myId">
            <summary>
            Stores the identifier of the signal. This is always not <c>Null</c>.
            Used for lazy-creating the <see cref="F:JetBrains.DataFlow.Signal`1.myProperty"/> with this ID.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myProperty">
            <summary>
            The underlying property useful for data flow bindings.
            Lazy-created at the moment when it's first requested externally via <see cref="P:JetBrains.DataFlow.Signal`1.Property"/>.
            Until that moment, is <c>Null</c> unless passed into the ctor.
            This is done to break the property-signal-property chain and allow for using both signals in the property and properties in the signal.
            Access must be synchronized via <see cref="F:JetBrains.DataFlow.Signal`1.myLock"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myReadOnlyLock">
            <summary>
            Non-<c>Null</c> when the object has a standard precondition on read-only lock set thru <see cref="T:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.mySinks">
            <summary>
            Stores the event sinks.
            Write access must be synchronized with <see cref="F:JetBrains.DataFlow.Signal`1.myLock"/> and should do copy-on-write.
            Read access is free-threaded.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myThreadAffinedTo">
            <summary>
            Non-<c>Null</c> when the object has a standard precondition on thread affinity set thru <see cref="T:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition"/>.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myUnderlyingPropertyAffineToThread">
            <summary>
            Helps with propagating <see cref="M:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(JetBrains.Lifetimes.Lifetime,System.Threading.Thread)" /> to the underlying property, if it exists.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.Signal`1.myUnderlyingPropertyReadOnlyLock">
            <summary>
            Helps with propagating <see cref="M:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)" /> to the underlying property, if it exists.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(System.String)">
            <summary>Creates the signal.</summary>
            <param name="id">
              <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
              <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{`0},JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.#ctor(JetBrains.DataFlow.PropertyId{`0},JetBrains.Util.ILogger)">
            <summary>Creates the signal.</summary>
            <param name="id">
              <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
              <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Optional logging engine override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnAfterAdvise(System.Action{`0})">
            <summary>
            Called after a new sink is attached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnAfterUnadvise(System.Action{`0})">
            <summary>
            Called after a sink is detached.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnBeforeAdvise(System.Action{`0})">
            <summary>
            Called before a new sink is attached.
            Returns whether the attachment is allowed.
            Throwing an exception will effectively cancel the attachment.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.AdviseCore(System.Action{`0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Core implementation of the Advise methods family
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.LazyCreateUnderlyingProperty">
            <summary>
            It's assumed that a lock is taken externally by the caller, as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.NotifySinks(`0)">
            <summary>
            Iterates on the sinks registered for handling the signal.
            Invokes each in turn, maintaining the exception isolation.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.OnUnderlyingPropertyChanged(JetBrains.DataFlow.PropertyChangedEventArgs{`0})">
            <summary>
            When working over a property, checks for its changes, whether to notify the sinks of the event happening.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.ToString">
            <summary>
            Returns a <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </summary>
            
            <returns>
            A <see cref="T:System.String"></see> that represents the current <see cref="T:System.Object"></see>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.JetBrains#DataFlow#StandardPreconditions#IReadOnlyPrecondition#LockReadOnly(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
             <summary>
             Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
             It's an error to call this method more than once (without disposing of the previous result first).
             </summary>
            <param name="lifetime"></param>
            <param name="token">A token that must be provided by all the parties trying to change the object state.
            <c>Null</c>
            is ignored and no precondition is set.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Fire(`0)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.Fire(`0,System.Object)">
            <summary>
            Fires the signal.
            </summary>
            <param name="value">The payload of the signal. Must not be <c>default(TValue)</c>.</param>
            <param name="cookie">A cookie for the <see cref="M:JetBrains.DataFlow.IProperty`1.SetValue(`0,System.Object)" /> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property" />.</param>
        </member>
        <member name="P:JetBrains.DataFlow.Signal`1.Id">
            <summary>
            Gets the identifier of this signal.
            Getting the ID from the underlying property will lazy-create the property, while this getter is cheap.
            </summary>
        </member>
        <member name="P:JetBrains.DataFlow.Signal`1.Property">
            <summary>
            Gets the underlying property of the signal.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Signal`1.JetBrains#DataFlow#StandardPreconditions#IThreadAffinityPrecondition#AffineToThread(JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            It's an error to call this method more than once (without disposing of the previous result first).
            </summary>
            <param name="lifetime"></param>
            <param name="thread">The thread to which the object should be affined for writing/firing from now on.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.SimpleSignal">
            <summary>
            A simple <see cref="T:JetBrains.DataFlow.ISignal`1" /> that has no payload.
            Stands for the simple <see cref="T:System.EventHandler" />-based event, but encapsulates the firing method, can take part in data flow, can be fired by an external user.
            Suitable for use in MVC's codebehind, when the event should be fireable by the views.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(JetBrains.DataFlow.PropertyId{System.Boolean},JetBrains.Util.ILogger)">
            <summary>Creates the signal.</summary>
            <param name="id">
              <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
              <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
            <param name="logger">Optional logging engine override.</param>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(System.String)">
            <summary>Creates the signal.</summary>
            <param name="id">
              <para>ID for the signal. Allows to tell signals apart at runtime and when debugging.</para>
              <para>If callstack annotation is on, will appear on callstacks when signal is fired. Thus, only compile-time-defined values should be used, to avoid spawning too many dynamic methods at runtime.</para>
            </param>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{System.Boolean},JetBrains.Util.ILogger)">
            <summary>Use overloads without lifetime.</summary>
        </member>
        <member name="M:JetBrains.DataFlow.SimpleSignal.Fire">
            <summary>
            Fires the signal.
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.SingleDisposable">
            <summary>
            Holds one disposable at most. When a new one is assigned, the old one goes away.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.SingleDisposable.myContainee">
            <summary>
            The current value.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Clear">
            <summary>
            <para>Disposes of the current contained value, if any.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)">
            <summary>
            <para>Disposes of the old contained value, and places a new one instead.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})">
            <summary>
            <para>Disposes of the old contained value, and places a new one instead.
            Guarantees that the old value is disposed of BEFORE the new value is evaluated by <paramref name="funcNew"/>.</para>
            <para>If you'd like to make sure the old value is disposed of BEFORE you evaluate the new one, either use <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.Func{System.IDisposable})"/> or pipe a <see cref="M:JetBrains.DataFlow.SingleDisposable.Clear"/> call before the <see cref="M:JetBrains.DataFlow.SingleDisposable.Put(System.IDisposable)"/> call. This might be necessary for sequencing the disposables brackets, to close the previous bracked before opening the new one.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.PutBracket(System.Action,System.Action)">
            <summary>
            Disposes of the old contained value first. Then executes the <paramref name="FEnter"/> action and schedulles <paramref name="FLeave"/> for execution when the contained value is disposed of.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.SingleDisposable.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition">
            <summary>
            Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.IReadOnlyPrecondition.LockReadOnly(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.StandardPreconditions.ReadonlyToken)">
             <summary>
             Locks writes/firings on the object by requiring all the modification attempts to provide a valid token equal to the given one.
             It's an error to call this method more than once (without disposing of the previous result first).
             </summary>
            <param name="lifetime">Lifetime for the readonly lock.</param>
            <param name="token">A token that must be provided by all the parties trying to change the object state.
            <c>Null</c>
            is ignored and no precondition is set.</param>
            <returns>Undo token.</returns>
             <remarks>A <c>Null</c> value for <paramref name="token"/> is allowed only to support temporary [debug] conditions where some component has a readonly token data field set to <c>Null</c> for use in both preconditions and callers, to temporarily allow foreign writers/firers.</remarks>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition">
            <summary>
            <para>Base interface for standard preconditions.</para>
            <para>These exist to allow fast implementations for standard preconditions on signals and properties, such as thread affinity and readonly validators.</para>
            <para>When implemented as custom preconditions on a property, handlers are attached to <see cref="T:JetBrains.DataFlow.IProperty`1"/>'s <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> event. In case of a <see cref="T:JetBrains.DataFlow.ISignal`1"/> or <see cref="T:JetBrains.DataFlow.ISimpleSignal"/>, the handlers are attached to <see cref="P:JetBrains.DataFlow.IProperty`1.BeforeChange"/> of the underlying <see cref="P:JetBrains.DataFlow.ISignal`1.Property"/> of the signal, which causes the property to be created in the first place and cause all the firings routed thru it. Standard preconditions are implemented in the object core and do not cause any external handlers called or underlying properties created.</para>
            </summary>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.IThreadAffinityPrecondition.AffineToThread(JetBrains.Lifetimes.Lifetime,System.Threading.Thread)">
            <summary>
            Makes the object operable for writing/firing on the given thread only.
            It's an error to call this method more than once (without disposing of the previous result first).
            </summary>
            <param name="lifetime">Lifetime of the validator.</param>
            <param name="thread">The thread to which the object should be affined for writing/firing from now on.</param>
            <returns>Undo token.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken">
            <summary>
            <para>A special object that locks property writes to the authorized owner, one who can provide the correct token.</para>
            <para>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken.#ctor(System.String)">
            <summary>
            Creates a special object that locks property writes to the authorized owner, one who can provide the correct token.
            </summary>
            <param name="info">Provides information about the readonly lock: who the owner of the lock is (usually, the owner of the locked object), and why the object is locked.</param>
            <remarks>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</remarks>
        </member>
        <member name="F:JetBrains.DataFlow.StandardPreconditions.ReadonlyToken.Info">
            <summary>
            Provides information about the readonly lock: who the owner of the lock is (usually, the owner of the locked object), and why the object is locked.
            </summary>
            <remarks>Even though the token has a comment string, it's used for failure diagnostic only and does not affect tokens equality. Each new token instance is unique, regardless of the comment string.</remarks>
        </member>
        <member name="T:JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions">
            <summary>
            Some options related to <see cref="T:JetBrains.DataFlow.StandardPreconditions.IStandardPrecondition"/> entities, mostly for tests/debug.
            </summary>
        </member>
        <member name="F:JetBrains.DataFlow.StandardPreconditions.StandardPreconditionOptions.UseStandardPreconditionsInHelperMethods">
            <summary>
            <para>Whether helper extension methods should use standard preconditions whenever possible.</para>
            <para><c>True</c>: production setting. Hard-coded standard preconditions are used wherever possible for speed.</para>
            <para><c>False</c>: test environment settings. Slower, but allows to test the code paths not available with standard preconditions.</para>
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Viewable.ToLiveHashSet``2(JetBrains.DataFlow.IViewable{``0},JetBrains.Lifetimes.Lifetime,System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            TODO: implement live hashset with multiple occurrenceos of elements.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.Viewable.SelectMany``2(JetBrains.DataFlow.IViewable{``0},JetBrains.Lifetimes.Lifetime,System.Func{``0,JetBrains.DataFlow.IViewable{``1}})">
            <summary>
            Similar to <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/> on <see cref="T:System.Collections.Generic.IEnumerable`1"/>, but live: as you have a live collection of providers each giving a live collection of items, builds a live flat collection of items from all the providers.
            </summary>
            <typeparam name="TItemsProvider">Provider type (has a collection of items inside).</typeparam>
            <typeparam name="TItem">Item type.</typeparam>
            <param name="ths">Live collection of providers.</param>
            <param name="lifetime"></param>
            <param name="FGetItemsFromProvider">How to get the live collection of items out of each provider.</param>
            <returns>The live flat collection of items from all the providers.</returns>
        </member>
        <member name="T:JetBrains.DataFlow.WinFormsProperty">
            <summary>
            Wraps a property with an event into an <see cref="T:JetBrains.DataFlow.IProperty`1"/>.
            </summary>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``2(JetBrains.Lifetimes.Lifetime,``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TSource">Source object type.</typeparam>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="lifetime"></param>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyExpression">Expression to retrieve property</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+Changed name.</param>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``2(``0,System.Linq.Expressions.Expression{System.Func{``0,``1}},System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TSource">Source object type.</typeparam>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyExpression">Expression to retrieve property</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+Changed name.</param>
        </member>
        <member name="M:JetBrains.DataFlow.WinFormsProperty.Create``1(System.Object,System.String,System.Boolean)">
            <summary>
            Returns a data flow property bound to a WinForms standard property (one usually coupled with an event).
            </summary>
            <typeparam name="TValue">Property value type.</typeparam>
            <param name="source">The source winforms property owner.</param>
            <param name="propertyName">The source winforms property name.</param>
            <param name="sinkEvents">Whether to sink the events from the WinForms property about its updates. Looks for an event with the {PropertyName}+Changed name.</param>
        </member>
        <member name="T:JetBrains.Reflection.StringConversion">
            <summary>
            Helps with converting arbitrary types to and from strings.
            Calls into <see cref="T:System.ComponentModel.TypeDescriptor"/>'s <see cref="T:System.ComponentModel.TypeConverter"/>, and WPF's <see cref="T:System.Windows.Markup.ValueSerializer"/>, and handles some trivial cases on its own.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ToInvariantString(System.Object,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">Value to be converted to a string.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ParseInvariantString(System.String,System.Type,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">String representation.</param>
            <param name="type">Desired type of the object to be restored from the string representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.ParseInvariantString``1(System.String,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <typeparam name="T">Desired type of the object to be restored from the string representation.</typeparam>
            <param name="value">String representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.GetSomeLogger(System.ComponentModel.ITypeDescriptorContext)">
            <summary>
            Either the <see cref="T:JetBrains.Util.ILogger"/> obtained from the <see cref="T:System.ComponentModel.ITypeDescriptorContext"/>, or the default logger dumping into the static <see cref="T:JetBrains.Util.Logging.Logger"/> otherwise.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.GetTypeConverter(System.Type)">
            <summary>
            Caches <see cref="M:System.ComponentModel.TypeDescriptor.GetConverter(System.Type)"/> results because it seems to walk the attributes every time, which takes considerable amount of times when doing repeated serializations in Settings.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.StringConversion.TryGetValueSerializer(System.Type)">
            <summary>
            <para>Looks up a serializer. Does not construct a fake serializer for wrapping the type converter (like <see cref="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)"/> does) if not found, but returns NULL.</para>
            <para>This is because a type-descriptor-converter wrapped into a value-converter would operate in the en-US locale while all previous calls of type-descriptor-converters operated in an invariant locale. We want all data previously written with an invariant type-converter to be now readable from persistent media, so we'd be calling type-descriptor-converters manually at the next stage.</para>
            <para>NOTE: logic for finding a <see cref="T:System.Windows.Markup.ValueSerializer"/>, as implemented at <see cref="M:System.Windows.Markup.ValueSerializer.GetSerializerFor(System.Type)"/>, is really this simple. That's why we can do it ourselves. On the contrary, getting a <see cref="T:System.ComponentModel.TypeConverter"/> is a hell of a work for the whole <see cref="T:System.ComponentModel.TypeDescriptor"/> subsystem, that's why we're not reimplementing it. Also, <see cref="T:System.Windows.Markup.ValueSerializerAttribute"/> refers to a type when given a <see cref="T:System.Type"/>, while <see cref="T:System.ComponentModel.TypeConverterAttribute"/> commits it into a string and sometimes has problems getting it back as a type.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ParseInvariantString(System.String,System.Type,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">String representation.</param>
            <param name="type">Desired type of the object to be restored from the string representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ParseInvariantString``1(System.String,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <typeparam name="T">Desired type of the object to be restored from the string representation.</typeparam>
            <param name="value">String representation.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.ToInvariantString(System.Object,JetBrains.Util.ILogger)">
            <summary>
            Wraps the <see cref="T:System.ComponentModel.TypeConverter"/>.
            </summary>
            <param name="value">Value to be converted to a string.</param>
            <param name="logger">Optional. The logger to be passed to the converter.</param>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.EnumRelatedTypesForReflection(System.Type,System.Boolean)">
            <summary>
            Self, then base classes from self to basest, then implemented interfaces exactly once (BFS where first level is in order of base classes enum).
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetBaseClassesAndInterfaces(System.Type)">
            <summary>
            Performs a BFS for base classes and interfaces of a type, self not included.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetAllAssignableToTypes(System.Type)">
            <summary>
            Performs a BFS (I don't think so anymore) for base classes and interfaces of a type, self included.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public string Field; }
            </code>
            Getting its name (Field):
            <code>ReflectionExtensions.GetInstanceMemberName&lt;Class&gt;(c=>c.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetStaticMemberName(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public static string Field; }
            </code>
            Getting its name (Field):
            <code>ReflectionExtensions.GetStaticMemberName(()=>Class.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMember``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetStaticMember(System.Linq.Expressions.Expression{System.Func{System.Object}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``1(System.Linq.Expressions.Expression{System.Func{``0,System.Object}})" />.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
              <para>This overload has the member return value strongly typed, for use in accessor APIs where an expression returning <see cref="T:System.Object" /> is not applicable.</para>
            </summary>
            <example>
            Class field declaration:
            <code>
            public class Class { public string Field; }
            </code>
            Getting its name (Field):
            <code>ReflectionExtensions.GetInstanceMemberName&lt;Class&gt;(c=>c.Field)</code>
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName(System.Linq.Expressions.LambdaExpression)">
            <summary>
              <para>Pass in a simple field/property access expression, or method call expression, and its name will get parsed and returned to you.</para>
              <para>This overload has the member return value strongly typed, for use in accessor APIs where an expression returning <see cref="T:System.Object" /> is not applicable.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            <para>Pass in a simple field/property access expression, or method call expression, and you'll get the member it's pointing to.</para>
            </summary>
            <example>
            See <see cref="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})"/>.
            </example>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.GetInstanceMembersChain(System.Linq.Expressions.Expression)">
            <summary>
            Gets the chain of member access based on the expression passed in, from outermost to innermost members.
            Could be used e.g. for creating Avalon early-bound data binding property path.
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.SubscribeToEvent(JetBrains.Lifetimes.Lifetime,System.Object,System.String,System.Action)">
            <summary>
            Subscribe to event via reflection
            </summary>
        </member>
        <member name="M:JetBrains.Reflection.ReflectionExtensions.SubscribeToEventHandler``2(JetBrains.Lifetimes.Lifetime,``0,System.String,System.EventHandler{``1})">
            <summary>
            Subscribe to event via reflection.
            Specifically handles <see cref="T:System.EventHandler`1" /> event delegate types, which does not require runtime codegen.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.AssemblyHashAlgorithm">
            <summary>
            From ".NET IL Assembler" by Serge Lidin. 
            The value of HashAlgId must be one of the CALG_* values defined in the Wincrypt.h.
            The default hash algorithm is CALG_SHA (aka CALG_SHA1) (0x8004).
            CLR version 1.0, 1.1, and 2.0 support only MD5 (0x8003) and SHA1 (0x8004) algorithms.
            CLR 4.0 introduced support of SHA256 (0x800C), SHA384 (0x800D), and SHA512 (0x800E) algorithms.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.AssemblyHashAlgorithm.SHA256">
            <since>CLR 4</since>
        </member>
        <member name="F:JetBrains.Metadata.Access.AssemblyHashAlgorithm.SHA384">
            <since>CLR 4</since>
        </member>
        <member name="F:JetBrains.Metadata.Access.AssemblyHashAlgorithm.SHA512">
            <since>CLR 4</since>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.FAVOR_MAJOR_MINOR_DISTANCE">
            <summary>
            Favors the short assembly name and Major.Minor version components when comparing.
            TODO: what happens to culture, PK, etc?
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.AllPossibleExtensionsForModules">
            <summary>
            A list of the valid assembly file extensions.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameExtensions.ParseAssemblyName(System.String)">
            <summary>
            Safe method to parse assembly name without an exception.
            </summary>
            <param name="assemblyFullName"></param>
            <returns>Parsed <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo" /> if successful, null otherwise</returns>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameExtensions.DistanceAwareComparer">
            <summary>
            A comparer which calculates the distance between assembly names and applies a threshold.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameExtensions.DistanceAwareComparer.DefaultFavorMajorMinorComparer">
            <summary>
            Favors the short assembly name and Major.Minor version components when comparing.
            TODO: what happens to culture, PK, etc?
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameExtensions.NameAndVersionComparer">
            <summary>
            Compares only the <see cref="P:JetBrains.Metadata.Utils.AssemblyNameInfo.Name">Simple Name</see> and <see cref="P:JetBrains.Metadata.Utils.AssemblyNameInfo.Version">Version</see> out of the assembly name fields.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameInfo">
            <summary>
            Managed-code class which incorporates assembly display name and its parts.
            Use it instead of the <see cref="T:System.Reflection.AssemblyName"/> because AssemblyName
            relies on reflection and other unmanaged code to store and read name.
            Call <c>AssemblyNameReader::GetAssemblyName</c> to get AssemblyNameInfo of an assembly file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myCulture">
            <summary>
            String representation of the culture.
            <c>NULL</c> means culture is not set.
            <see cref="F:JetBrains.Metadata.Utils.AssemblyNameInfo.CultureNeutral"/> means the culture is set to Neutral (in CLR or Invariant Culture, they have an empty string for a name).
            Any other value is the culture name.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myProcessorArchitecture">
            <summary>
            The processor architecture. A value of <c>NULL</c> means that it has not been set (its text representation of None is not a valid value for the attribute text).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyNameInfo.myCustom">
            <summary>
            The Custom field.
            <c>NULL</c> means not set.
            <see cref="F:System.Reflection.Missing.Value"/> means explicitly set to null.
            A byte array value means the real custom data.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.AssemblyNameInfo.IsStrongName">
            <summary>
            True if the assembly identity has a strong name, ie. either a full public key or a token.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.#ctor(System.String)">
            <exception cref="T:System.ArgumentException"></exception>
        </member>
        <member name="P:JetBrains.Metadata.Utils.AssemblyNameInfo.AssemblyManifestHashAlgorithm">
            <summary>
            This is not used by the assembly name itself, nor when calculating the public key token from the public key (it's always SHA1). Mirrors the <see cref="P:System.Reflection.AssemblyName.HashAlgorithm" /> or the <c>HashAlgId</c> column in the <c>Assembly</c> metadata table.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.TryParse(System.String)">
            <summary>
              <para>A no-throw version of the <see cref="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)" />.</para>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName" /> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(System.String)">
            <summary>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName" /> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
            <exception cref="T:System.ArgumentException">Any parse errors.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Parse(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
              <para>Parses the string as an assembly textual identity string, i.e. a full name of an assembly.</para>
              <para>Mostly same as the CLR <see cref="T:System.Reflection.AssemblyName" /> does with its .ctor, but in a more memory-efficient manner, and with caching.</para>
              <para>Matches very closely the Fusion/CLR parsing rules, and can handle most of the complicated escaping/formatting cases, according to the grammar.</para>
            </summary>
            <exception cref="T:System.ArgumentException">Any parse errors.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameInfo.Create(System.String,System.Version,JetBrains.Metadata.Utils.PublicKeyToken,System.String,System.String,System.Byte[],System.Reflection.ProcessorArchitecture,System.Boolean,JetBrains.Util.Reflection.AssemblyIdentityContentTypes,System.Object,JetBrains.Metadata.Access.AssemblyHashAlgorithm)">
            <summary>
            This method takes all of the Assembly Name components and interns the resulting Assembly Name within the <see cref="T:JetBrains.Util.Reflection.AssemblyNameInfoFactory" />.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PublicKeyToken">
            <summary>
            Wraps the Public Key Token value for the assembly identity.
            Possible values:
            (1) A valid 64-bit token is assigned.
            (2) A NULL value is explicitly assigned (results in <c>PublicKeyToken=null</c> or <c>=neutral</c> in the identity string).
            (3) No value assigned (runtime tells this apart from the NULL case, and no <c>PublicKeyToken=null</c> string is added to the textual identity string in this case).
            Holds these states, and allows to get/set the token as a byte array.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra">
            <summary>
            <c>NULL</c> value => no token has been set on this object (neither NULL or value).
            <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra_NullOrNeutral" /> value => either NULL or Neutral has been set as the token.
            <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myExtra_Deferred" /> => the token has been set, <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue" /> has the value, the array hasn't been computed yet.
            Otherwise, a byte[], the token has been set, <see cref="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue" /> has the value, and this is its array version.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PublicKeyToken.myValue">
            <summary>
            The value, unless it's NotSet or NULL or Neutral.
            Otherwise, must be zero.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.Parse(System.String)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Throws an argument exception on error.
            </summary>
            <exception cref="T:System.ArgumentException">Parse error.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.TryParse(System.String)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Silently returns <see cref="P:JetBrains.Metadata.Utils.PublicKeyToken.NotSet" /> on a parse error.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PublicKeyToken.TryParseCore(System.String,JetBrains.Util.OnError)">
            <summary>
            Parses the token value text, just like the value of the PublikKeyToken attribute in this assembly textual identity string.
            Throws an argument exception on error.
            </summary>
        </member>
        <member name="M:JetBrains.Text.ArrayBuffer.AssertOffsetAndLength(System.Int32,System.Int32)">
            <summary>
            Assertion method to avoid creating closure objects when no exceptions are thrown
            </summary>
            <param name="offset"></param>
            <param name="length"></param>
        </member>
        <member name="T:JetBrains.Text.IBuffer">
            <summary>
            Buffer that allows retrieval of contents by position
            </summary>
        </member>
        <member name="T:JetBrains.Text.IEditableBuffer">
            <summary>
            Interface for a buffer supporting efficient editing of content in arbitrary positions
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.Add``2(System.Collections.Generic.IDictionary{``0,``1},JetBrains.Lifetimes.Lifetime,``0,``1)">
            <summary>
            Adds an element with the provided key and value to the <see cref="T:System.Collections.Generic.IDictionary`2"/>, for a limited lifetime.
            </summary>
            <typeparam name="TKey">The type of keys in the dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the dictionary.</typeparam>
            <param name="lifetime">Lifetime for the item to be present in the dictionary.</param>
            <param name="key">The object to use as the key of the element to add.</param>
            <param name="value">The object to use as the value of the element to add.</param>
            <param name="dictionary">Dictionary.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="key"/> is null.</exception>
            <exception cref="T:System.ArgumentException">An element with the same key already exists in the <see cref="T:System.Collections.Generic.IDictionary`2"/>.</exception>
            <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IDictionary`2"/> is read-only.</exception>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryEquals``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.ReadOnlyDictionaryEquals``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.ReadOnlyDictionaryEquals``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>
            Checks that two dictionaries contain the same values under the same keys.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryGetHashCode``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Computes hash code for Dictionary.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.ReadOnlyDictionaryGetHashCode``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
            <summary>
            Computes hash code for Dictionary.
            </summary>
        </member>
        <member name="M:JetBrains.DictionaryEx.DictionaryGetHashCodeInternal``2(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Computes hash code for Dictionary.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.GetCustomAttributeByTypeSafe``1(System.Reflection.ICustomAttributeProvider,System.Boolean)">
            <summary>
            Gets custom attribute from reflection object that can provide custom attributes.
            </summary>
            <typeparam name="TAttribute">The type of attribute to find.</typeparam>
            <param name="attributeProvider">A reflection object that can provide custom attributes.</param>
            <param name="inherit">When true, look up the hierarchy chain for the inherited custom attribute.</param>
            <returns>The attribute instance if it is found successfully; otherwise, false.</returns>
            <exception cref="T:System.TypeLoadException">If the custom attribute type (<typeparamref name="TAttribute"/>) cannot be loaded.</exception>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.GetCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has exactly one custom attribute of the given type, returns that attribute.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.HasCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has zero or one custom attribute of the given type, returns whether it's one not zero.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.ICustomAttributeProviderEx.TryGetCustomAttributeNoInherit``1(System.Reflection.ICustomAttributeProvider)">
            <summary>
            For an attribute provider that has zero or one custom attribute of the given type, returns that attribute, or <c>Null</c> if none.
            Otherwise, throws.
            Inherited attributes are ignored.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Read(System.IO.Stream,System.Byte[])">
            <summary>
            Reads a sequence of bytes from the current stream and advances the position within the stream by the number of bytes read.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadAllBytes(System.IO.Stream)">
            <summary>
            Reads the whole stream contents.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadAllBytesImmutable(System.IO.Stream)">
            <summary>
            Reads the whole stream contents.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ToMemoryStream(System.IO.Stream)">
            <summary>
            Reads the whole stream contents.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamReader(System.IO.Stream,System.Action{System.IO.StreamReader})">
            <summary>
            Creates a stream reader over a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamWriter(System.IO.Stream,System.Action{System.IO.StreamWriter})">
            <summary>
            Creates a stream writer over a stream.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Write(System.IO.Stream,System.Byte[])">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Write(System.IO.Stream,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Writes a sequence of bytes to the current stream and advances the current position within this stream by the number of bytes written.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.AsImmutable(System.IO.UnmanagedMemoryStream)">
            <summary>
            A helper to get immutable byte streams from ResX generated accessors with MemoryStream type in ResX.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.CopyStreamAsync(System.IO.Stream,JetBrains.Lifetimes.OuterLifetime,System.IO.Stream)">
            <summary>
            Copies streams asynchronously.
            Supports cancelation on a lifetime.
            Returns the total number of bytes copied.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Rewind(System.IO.Stream)">
            <summary>
            <para>Rewinds the stream to the beginning so that it could be reused for reading.</para>
            <para>For example, this should be done to a <see cref="T:System.IO.MemoryStream"/> after writing and before each reading.</para>
            <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.EraseAndRewind(System.IO.Stream)">
            <summary>
            <para>Rewinds the stream to the beginning and removes its content so that it could be reused for writing.</para>
            <para>For example, this should be done to a <see cref="T:System.IO.MemoryStream"/> before reusing it for writing.</para>
            <para>Fluent.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.StreamEquals(System.IO.Stream,System.IO.Stream)">
            <summary>
            Compares the contents of two streams (both must be at position zero).
            </summary>
        </member>
        <member name="T:JetBrains.Extension.StreamEx.Utf8Automaton">
            <summary>
            Detects 0xEFBBBF in stream of bytes 
            </summary>
        </member>
        <member name="F:JetBrains.Extension.StreamEx.Utf8Automaton.ourClasses">
            <summary>
            Equivalence classes for bytes. Required to quickly skip non-BOM characters
            Also used to accept chains of 1-2-3 byte sequence.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.Utf8Automaton.Next(System.Byte)">
            <summary>
            Feed input byte to automaton
            </summary>
            <param name="input"></param>
            <returns>true, if accepted sequence found</returns>
        </member>
        <member name="T:JetBrains.Extension.StreamEx.EncodingData">
            <summary>
            A nested class for lazy-creating stuff such as regexes and encodings when they are needed and not on any first access to this class.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.IsDeterministic(JetBrains.Extension.StreamEx.DecodedText,JetBrains.Util.OnError)">
            <summary>
            Checks that decoding the file does not depend on the current environment, such as default 8-bit encoding of this machine. Only ASCII and Unicode encodings are allowed, and illegal byte sequences are an error.
            </summary>
            <param name="this"></param>
            <param name="onerror">Optional. Submits the error message. NULL means don't.</param>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.AssertDeterministic(JetBrains.Extension.StreamEx.DecodedText)">
            <inheritdoc cref="M:JetBrains.Extension.StreamEx.IsDeterministic(JetBrains.Extension.StreamEx.DecodedText,JetBrains.Util.OnError)"/>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadTextFromStreamDeterministic(System.IO.Stream)">
            <summary>
            Calls <see cref="M:JetBrains.Extension.StreamEx.ReadTextFromStream(System.IO.Stream,System.Text.Encoding)" /> and asserts that decoding the file does not depend on the current environment, such as default 8-bit encoding of this machine. Only ASCII and Unicode encodings are allowed, and illegal byte sequences are an error.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadTextFromBuffer(System.ReadOnlySpan{System.Byte},System.Text.Encoding)">
            <summary>
            <para>Reads text from a buffer with smart detection of encodings.</para>
            <para>Files with an explicit Byte Order Mark or a valid XML header specify their encoding explicitly, and we take it from the content itself.
            Others are either ASCII, or we try to detect between ANSI and UTF-8 by checking if there're UTF-illegal chars or ANSI-unlikely chars in the data.</para>
            <para>This behavior is supposed to be in sync with Visual Studio, because we must have a match in file text when we read files from disk for indexing vs. get them from the Running Documents Table when the file gets opened in VS. As a softer requirement, we want the compiler to see the files as we do.</para>
            </summary>
            <param name="buffer">The input buffer with bytes of the text encoded with some encoding.</param>
            <param name="defaultMbcsEncodingOverride">If <c>NULL</c>, <see cref="P:JetBrains.Util.Text.EncodingUtil.DefaultEncoding"/> will be used as the fallback, which is ANSI/UTF-8 on Windows and UTF-8 on Linux. Otherwise, your value (must be a multi-byte-character-string encoding, not a wide-string encoding).</param>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.ReadTextFromStream(System.IO.Stream,System.Text.Encoding)">
            <inheritdoc cref="M:JetBrains.Extension.StreamEx.ReadTextFromBuffer(System.ReadOnlySpan{System.Byte},System.Text.Encoding)"/>
        </member>
        <member name="T:JetBrains.Extension.StreamEx.DecodedText">
            <summary>
            A result of reading text from a stream with smart encoding detection.
            </summary>
            <param name="Text">Decoded text, as a runtime string.</param>
            <param name="ExactEncoding">The exact encoding of the text, which will be <see cref="P:System.Text.Encoding.ASCII" /> if the text has ASCII-only symbols.</param>
            <param name="WriteBackEncoding">The legacy detected encoding which is wider than ASCII even for pure ASCII text, like ANSI or UTF (Default Encoding). Kind of, which encoding you should use if saving after adding non-ASCII chars to the file. This might be machine-dependent regardless of <paramref name="IsMachineIndependentDetection" /> because we have to assume the extended charset.</param>
            <param name="IsValidUtf">If there were no Unicode errors in the file, like broken UTF-8, broken UTF-16 surrogate pairs, etc. <c>NULL</c> if not UTF or we have not run the check.</param>
            <param name="IsMachineIndependentDetection"><c>True</c> if we have not used the Default Encoding when inferring <paramref name="ExactEncoding" /> and decoding the text. <c>False</c> if the text were 8-bit not not clearly UTF.</param>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.DecodedText.#ctor(System.String,System.Text.Encoding,System.Text.Encoding,System.Nullable{System.Boolean},System.Boolean)">
            <summary>
            A result of reading text from a stream with smart encoding detection.
            </summary>
            <param name="Text">Decoded text, as a runtime string.</param>
            <param name="ExactEncoding">The exact encoding of the text, which will be <see cref="P:System.Text.Encoding.ASCII" /> if the text has ASCII-only symbols.</param>
            <param name="WriteBackEncoding">The legacy detected encoding which is wider than ASCII even for pure ASCII text, like ANSI or UTF (Default Encoding). Kind of, which encoding you should use if saving after adding non-ASCII chars to the file. This might be machine-dependent regardless of <paramref name="IsMachineIndependentDetection" /> because we have to assume the extended charset.</param>
            <param name="IsValidUtf">If there were no Unicode errors in the file, like broken UTF-8, broken UTF-16 surrogate pairs, etc. <c>NULL</c> if not UTF or we have not run the check.</param>
            <param name="IsMachineIndependentDetection"><c>True</c> if we have not used the Default Encoding when inferring <paramref name="ExactEncoding" /> and decoding the text. <c>False</c> if the text were 8-bit not not clearly UTF.</param>
        </member>
        <member name="P:JetBrains.Extension.StreamEx.DecodedText.Text">
            <summary>Decoded text, as a runtime string.</summary>
        </member>
        <member name="P:JetBrains.Extension.StreamEx.DecodedText.ExactEncoding">
            <summary>The exact encoding of the text, which will be <see cref="P:System.Text.Encoding.ASCII" /> if the text has ASCII-only symbols.</summary>
        </member>
        <member name="P:JetBrains.Extension.StreamEx.DecodedText.WriteBackEncoding">
            <summary>The legacy detected encoding which is wider than ASCII even for pure ASCII text, like ANSI or UTF (Default Encoding). Kind of, which encoding you should use if saving after adding non-ASCII chars to the file. This might be machine-dependent regardless of <paramref name="IsMachineIndependentDetection" /> because we have to assume the extended charset.</summary>
        </member>
        <member name="P:JetBrains.Extension.StreamEx.DecodedText.IsValidUtf">
            <summary>If there were no Unicode errors in the file, like broken UTF-8, broken UTF-16 surrogate pairs, etc. <c>NULL</c> if not UTF or we have not run the check.</summary>
        </member>
        <member name="P:JetBrains.Extension.StreamEx.DecodedText.IsMachineIndependentDetection">
            <summary><c>True</c> if we have not used the Default Encoding when inferring <paramref name="ExactEncoding" /> and decoding the text. <c>False</c> if the text were 8-bit not not clearly UTF.</summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.WriteUtf8(System.IO.Stream,System.String)">
            <summary>
            Writes text in UTF-8 encoding.
            Spares additional allocations for strings which are not too long.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.AsSeekable(System.IO.Stream,System.Nullable{System.Int64})">
            <summary>
              <para>Wraps the stream if it's sequential-only, but leaves AS IS if it can seek already.</para>
              <para>If required, wraps a sequential stream with a view which supports seek operations. For that, it has to keep a copy of already-passed bytes, even if you skip them when seeking, so use only when needed (like, when you want to analyze a header of a sequential stream with a reader which requires seeking).</para>
            </summary>
            <param name="maybeSequential">Passthru if declares itself as seekable with <see cref="P:System.IO.Stream.CanSeek" />, otherwise a wrapper implementation with seeking support.</param>
            <param name="customlength">If the <see cref="P:System.IO.Stream.Length" /> property of the underlying stream is irrelevant (which might be a case with a sequential stream), you must provide its value by some external knowledge, otherwise the seekable APIs might not be able to operate. Leave empty to use from the underlying stream.</param>
        </member>
        <member name="M:JetBrains.Extension.StreamEx.TransformBlock(System.Security.Cryptography.ICryptoTransform,System.IO.Stream)">
            <summary>
            Adds the stream contents to the hasher.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TimeSpanEx.CoerceInfiniteForWinApi(System.TimeSpan)">
            <summary>
            Coerces <see cref="F:System.TimeSpan.MaxValue" /> to the special <c>WinAPI</c> <c>INFINITE</c> value of <c>FFFFFFFFh</c> reinterpreted as timespan milliseconds.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TimeSpanEx.CoerceInfiniteForWinApi(System.Nullable{System.TimeSpan})">
            <summary>
            Coerces <see cref="F:System.TimeSpan.MaxValue" /> or <c>NULL</c> to the special <c>WinAPI</c> <c>INFINITE</c> value of <c>FFFFFFFFh</c> reinterpreted as timespan milliseconds.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TimeSpanEx.IsAnyInfinite(System.TimeSpan)">
            <summary>
            Checks for <see cref="F:System.TimeSpan.MaxValue" /> and the special <c>WinAPI</c> <c>INFINITE</c> value of <c>FFFFFFFFh</c> reinterpreted as timespan milliseconds.
            </summary>
        </member>
        <member name="T:JetBrains.Extension.TypeEx">
            <summary>
            Extension methods for <see cref="T:System.Type"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetDefaultValue(System.Type)">
            <summary>
            Gets the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValue(System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValue(System.Type,System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValueOrEmptyString(System.Type,System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for this reference or value type, or an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.IsDefaultValueOrEmptyString(System.Object)">
            <summary>
            Gets whether the <paramref name="value"/> is the default value for its reference or value type, or an empty string.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.CoercePrimitiveValueToType(System.Object,System.Type,JetBrains.Util.ILogger)">
            <summary>
            <para>When a value has to be specified on an attribute, its type is limited to primitive types. Also, the primitive types might not match if an integer is specified where a floating-point type is expected.</para>
            <para>This method tries the following coersions:</para>
            <para>(*) NULL value: means the default value of the expected type. Also works for value types.</para>
            <para>(*) Exact type match: the given value is exactly of the expected type. Returns the value transparently.</para>
            <para>(*) Given a string value (the expected type is not a string): applies <see cref="T:System.ComponentModel.TypeConverter"/> to parse the invariant string into an object of the expected type.</para>
            <para>(*) Enum special case: if the expected type is an enum, and we're given its underlying type (maybe non-exact underlying type), <see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> cannot handle that on its own.</para>
            <para>(*) System coersion (<see cref="M:System.Convert.ChangeType(System.Object,System.Type)"/> in invariant culture). Works for similar yet different primitive types, eg <see cref="T:System.Int32"/> and <see cref="T:System.UInt32"/>.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(System.String,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(JetBrains.Util.StringSlice,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetLocalNameFromFullTypeName(JetBrains.Util.dataStructures.Sources.StringSource,System.Boolean)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(System.String)">
            <summary>
            Strips possible generic args off the type name: grave accent `, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Strips possible generic args off the type name: grave accent `, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.EqualsTypeNameWithoutGenericArgs(JetBrains.Util.dataStructures.Sources.StringSource,JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Strips possible generic args off the type name: grave accent `, angle brackets, square brackets, etc;
            then checks if the result is equal to the given name which must have been already stripped of such.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetTypeNameWithoutGenericArgs(JetBrains.Util.StringSlice)">
            <summary>
            Strips possible generic args off the type name: grave accent `, angle brackets, square brackets, etc.
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(JetBrains.Util.StringSlice)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(System.String)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx.GetNamespaceFromFullTypeName(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
              <para>Takes the type local name out of the full name.</para>
              <para>Accepted formats: generic parameters number denoted with ` or &lt;&gt;, generic parameters recusrively specified inside &lt;&gt;, nested classes delimited with . or +.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Extension.TypeEx_NetCore15.QuoteIfNeeded(System.Type)">
            <summary>
            Takes the type presentation, surrounds it with quotes if it contains spaces.
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnum``1(System.String,System.Boolean)">
            <summary>
            Parse string to enum without any checking
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnum``1(System.String,``0,System.Boolean)">
            <summary>
            Parse string to enum with returning specified default value if parameter is null
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumSafe``1(System.String,``0,System.Boolean)">
            <summary>
            Parse string to enum with returning specified default value if parameter is null or invalid
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumNullable``1(System.String)">
            <summary>
            Parse string to nullable enum with returning null if parameter is null
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.ToEnumNullableSafe``1(System.String,System.Nullable{``0},System.Boolean)">
            <summary>
            Parse string to nullable enum with returning specified default value if parameter is null or invalid
            </summary>
        </member>
        <member name="M:JetBrains.StringEx.FormatEx(System.String,System.Object[])">
            <summary>
            <para>
            Replaces the format item in a specified <see cref="T:System.String"/> 
            with the text equivalent of the value of a corresponding <see cref="T:System.Object"/> 
            instance in a specified array.
            </para>
            <para>
            This method just call <see cref="M:System.String.Format(System.String,System.Object[])"/> 
            but can be used in more cool way:
            </para>
            <code>
            "Hello, {0}!".FormatEx("World")
            </code>
            </summary>
            <param name="format">A composite format string. </param>
            <param name="args">An <see cref="T:System.Object"/> array containing zero or more objects to format. </param>
            <returns>
            A copy of <paramref name="format"/> in which the format items have been replaced by the <see cref="T:System.String"/> 
            equivalent of the corresponding instances of <see cref="T:System.Object"/> in <paramref name="args"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="format"/> or <paramref name="args"/> is null. 
            </exception>
            <exception cref="T:System.FormatException"> 
            <paramref name="format"/> is invalid.-or- The number indicating an argument to format is less than zero, 
            or greater than or equal to the length of the <paramref name="args"/> array. 
            </exception>
        </member>
        <member name="M:JetBrains.StringEx.FormatNoInline(System.String,System.Object[])">
            <summary>
            The original <c>String::Format</c> method, if inlined, brings allocation of the <c>System.ParamsArray</c> value type on the stack (even if not called), which assumes zeroing its memory and for small and fast functions might make up the longest slice of own cpu time. If this string formatting is on the cold path, use the non-inlineable function.
            </summary>
        </member>
        <member name="M:JetBrains.NumberUtil.FloatingToStringRoundtrip``1(``0)">
            <summary>
            Converts the value to a string.
            If it's of a floating-point format, applies round-trip conversion to avoid losing precision.
            </summary>
        </member>
        <member name="M:JetBrains.NumberUtil.AreClose(System.Double,System.Double)">
            <summary>
            AreClose returns whether or not two doubles are "close".  That is, whether or
            not they are within epsilon of each other.
            There are plenty of ways for this to return false even for numbers which
            are theoretically identical, so no code calling this should fail to work if this
            returns false.
            </summary>
            <param name="value1">The first double to compare.</param>
            <param name="value2">The second double to compare.</param>
            <returns>The result of the AreClose comparision.</returns>
        </member>
        <member name="F:JetBrains.NumberUtil.Epsilon">
            <summary>
            Epsilon - more or less random, more or less small number.
            This value has been borrowed from WPF.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>
            Indicates that a parameter captures the expression passed for another parameter as a string.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>
            Gets the name of the parameter whose expression should be captured as a string.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>
            The name of the compiler feature.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            If true, the compiler can choose to allow access to the location where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>
            The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsReadOnlyAttribute">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This attribute should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c>
            flag should not be set in method headers.
            </summary>
            <remarks>
            This attribute is unsafe because it may reveal uninitialized memory to
            the application in certain instances (e.g., reading from uninitialized
            stackalloc'd memory). If applied to a method directly, the attribute
            applies to that method and all nested functions (lambdas, local
            functions) below it. If applied to a type or module, it applies to all
            methods nested inside. This attribute is intentionally not permitted on
            assemblies. Use at the module level instead to apply to multiple type
            declarations.
            </remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks>
            Index is used by the C# compiler to support the new index syntax
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code>
            </remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means pointing at beyond last element.
            </remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">The length of the collection that the Index will be used with. length has to be a positive value</param>
            <remarks>
            For performance reason, we don't validate the input length parameter and the returned offset value against negative values.
            we don't validate either the returned offset is greater than the input length.
            It is expected Index will be used with collections which always have non negative length/count. If the returned offset is negative and
            then used to index a collection will get out of range exception which will be same affect as the validation.
            </remarks>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <summary>Indicates whether the current Index object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <summary>Indicates whether the current Index object is equal to another Index object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Index.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.ToString">
            <summary>Converts the value of the current Index object to its equivalent string representation.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>
            Specifies that null is allowed as an input even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>
            Specifies that null is disallowed as an input even if the corresponding type allows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>
            Specifies that an output may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter may be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified return value condition.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>
            Specifies that the output will be non-null if the named parameter is non-null.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes the attribute with the associated parameter name.
            </summary>
            <param name="parameterName">The associated parameter name. The output will be non-null if the argument to the parameter specified is non-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>
            Applied to a method that will never return under any circumstance.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>
            Specifies that the method will not return if the associated Boolean parameter is passed the specified value.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes the attribute with the specified parameter value.
            </summary>
            <param name="parameterValue">The condition parameter value. Code after the method will be considered unreachable
            by diagnostics if the argument to the associated parameter matches this value.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field and property members have not-null values.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>
            Specifies that the method or property will ensure that the listed field
            and property members have not-null values when returning with the specified return value condition.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes the attribute with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="member">The field or property member that is promised to be not-null.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes the attribute with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">The return value condition. If the method returns this value, the associated parameter will not be null.</param>
            <param name="members">The list of field and property members that are promised to be not-null.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type, and callers
            do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>Used to indicate a byref escapes and is not scoped.</summary>
            <remarks>
            <para>
            There are several cases where the C# compiler treats a <see langword="ref"/> as implicitly
            <see langword="scoped"/> - where the compiler does not allow the <see langword="ref"/> to escape the method.
            </para>
            <para>
            For example:
            <list type="number">
              <item><see langword="this"/> for <see langword="struct"/> instance methods.</item>
              <item><see langword="ref"/> parameters that refer to <see langword="ref"/> <see langword="struct"/> types.</item>
              <item><see langword="out"/> parameters.</item>
            </list>
            </para>
            <para>This attribute is used in those instances where the <see langword="ref"/> should be allowed to escape.</para>
            <para>
            Applying this attribute, in any form, has impact on consumers of the applicable API. It is necessary for
            API authors to understand the lifetime implications of applying this attribute and how it may impact their users.
            </para>
            </remarks>
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks>
            Range is used by the C# compiler to support the range syntax.
            <code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code>
            </remarks>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <summary>Indicates whether the current Range object is equal to another object of the same type.</summary>
            <param name="value">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <summary>Indicates whether the current Range object is equal to another Range object.</summary>
            <param name="other">An object to compare with this object</param>
        </member>
        <member name="M:System.Range.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:System.Range.ToString">
            <summary>Converts the value of the current Range object to its equivalent string representation.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="M:System.Range.GetOffsetAndLength(System.Int32)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <param name="length">The length of the collection that the range will be used with. length has to be a positive value.</param>
            <remarks>
            For performance reason, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </remarks>
        </member>
        <member name="T:System.Text.Rune">
            <summary>
            Represents a Unicode scalar value ([ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive).
            </summary>
            <remarks>
            This type's constructors and conversion operators validate the input, so consumers can call the APIs
            assuming that the underlying <see cref="T:System.Text.Rune"/> instance is well-formed.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 code unit.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="ch"/> represents a UTF-16 surrogate code point
            U+D800..U+DFFF, inclusive.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Char,System.Char)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="highSurrogate"/> does not represent a UTF-16 high surrogate code point
            or <paramref name="lowSurrogate"/> does not represent a UTF-16 low surrogate code point.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.Int32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="M:System.Text.Rune.#ctor(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> from the provided Unicode scalar value.
            </summary>
            <exception cref="T:System.ArgumentOutOfRangeException">
            If <paramref name="value"/> does not represent a value Unicode scalar value.
            </exception>
        </member>
        <member name="P:System.Text.Rune.IsAscii">
            <summary>
            Returns true if and only if this scalar value is ASCII ([ U+0000..U+007F ])
            and therefore representable by a single UTF-8 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.IsBmp">
            <summary>
            Returns true if and only if this scalar value is within the BMP ([ U+0000..U+FFFF ])
            and therefore representable by a single UTF-16 code unit.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Plane">
            <summary>
            Returns the Unicode plane (0 to 16, inclusive) which contains this scalar.
            </summary>
        </member>
        <member name="P:System.Text.Rune.ReplacementChar">
            <summary>
            A <see cref="T:System.Text.Rune"/> instance that represents the Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="P:System.Text.Rune.Utf16SequenceLength">
            <summary>
            Returns the length in code units (<see cref="T:System.Char"/>) of the
            UTF-16 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 or 2.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Utf8SequenceLength">
            <summary>
            Returns the length in code units of the
            UTF-8 sequence required to represent this scalar value.
            </summary>
            <remarks>
            The return value will be 1 through 4, inclusive.
            </remarks>
        </member>
        <member name="P:System.Text.Rune.Value">
            <summary>
            Returns the Unicode scalar value as an integer.
            </summary>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-16 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="charsConsumed"/> the
            number of <see langword="char"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a standalone UTF-16 high surrogate character, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-16 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="charsConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="charsConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the beginning of the provided UTF-8 source buffer.
            </summary>
            <returns>
            <para>
            If the source buffer begins with a valid UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.Done"/>,
            and outs via <paramref name="result"/> the decoded <see cref="T:System.Text.Rune"/> and via <paramref name="bytesConsumed"/> the
            number of <see langword="byte"/>s used in the input buffer to encode the <see cref="T:System.Text.Rune"/>.
            </para>
            <para>
            If the source buffer is empty or contains only a partial UTF-8 subsequence, returns <see cref="F:System.Buffers.OperationStatus.NeedMoreData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the length of the input buffer.
            </para>
            <para>
            If the source buffer begins with an ill-formed UTF-8 encoded scalar value, returns <see cref="F:System.Buffers.OperationStatus.InvalidData"/>,
            and outs via <paramref name="result"/> <see cref="P:System.Text.Rune.ReplacementChar"/> and via <paramref name="bytesConsumed"/> the number of
            <see langword="char"/>s used in the input buffer to encode the ill-formed sequence.
            </para>
            </returns>
            <remarks>
            The general calling convention is to call this method in a loop, slicing the <paramref name="source"/> buffer by
            <paramref name="bytesConsumed"/> elements on each iteration of the loop. On each iteration of the loop <paramref name="result"/>
            will contain the real scalar value if successfully decoded, or it will contain <see cref="P:System.Text.Rune.ReplacementChar"/> if
            the data could not be successfully decoded. This pattern provides convenient automatic U+FFFD substitution of
            invalid sequences while iterating through the loop.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-16 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf16(System.ReadOnlySpan{System.Char},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="charsConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.DecodeLastFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)">
            <summary>
            Decodes the <see cref="T:System.Text.Rune"/> at the end of the provided UTF-8 source buffer.
            </summary>
            <remarks>
            This method is very similar to <see cref="M:System.Text.Rune.DecodeFromUtf8(System.ReadOnlySpan{System.Byte},System.Text.Rune@,System.Int32@)"/>, but it allows
            the caller to loop backward instead of forward. The typical calling convention is that on each iteration
            of the loop, the caller should slice off the final <paramref name="bytesConsumed"/> elements of
            the <paramref name="source"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf16(System.Span{System.Char})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <returns>The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.EncodeToUtf8(System.Span{System.Byte})">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-8 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <returns>The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>.</returns>
            <exception cref="T:System.ArgumentException">
            If <paramref name="destination"/> is not large enough to hold the output.
            </exception>
        </member>
        <member name="M:System.Text.Rune.GetRuneAt(System.String,System.Int32)">
            <summary>
            Gets the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <remarks>
            Throws if <paramref name="input"/> is null, if <paramref name="index"/> is out of range, or
            if <paramref name="index"/> does not reference the start of a valid scalar value within <paramref name="input"/>.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.Int32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.IsValid(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Rune.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> representation of this <see cref="T:System.Text.Rune"/> instance.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Char,System.Char,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided UTF-16 surrogate pair.
            Returns <see langword="false"/> if the input values don't represent a well-formed UTF-16surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryCreate(System.UInt32,System.Text.Rune@)">
            <summary>
            Attempts to create a <see cref="T:System.Text.Rune"/> from the provided input value.
            </summary>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf16(System.Span{System.Char},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a UTF-16 destination buffer.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-16.</param>
            <param name="charsWritten">
            The number of <see cref="T:System.Char"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf16SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryEncodeToUtf8(System.Span{System.Byte},System.Int32@)">
            <summary>
            Encodes this <see cref="T:System.Text.Rune"/> to a destination buffer as UTF-8 bytes.
            </summary>
            <param name="destination">The buffer to which to write this value as UTF-8.</param>
            <param name="bytesWritten">
            The number of <see cref="T:System.Byte"/>s written to <paramref name="destination"/>,
            or 0 if the destination buffer is not large enough to contain the output.</param>
            <returns>True if the value was written to the buffer; otherwise, false.</returns>
            <remarks>
            The <see cref="P:System.Text.Rune.Utf8SequenceLength"/> property can be queried ahead of time to determine
            the required size of the <paramref name="destination"/> buffer.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.TryGetRuneAt(System.String,System.Int32,System.Text.Rune@)">
            <summary>
            Attempts to get the <see cref="T:System.Text.Rune"/> which begins at index <paramref name="index"/> in
            string <paramref name="input"/>.
            </summary>
            <returns><see langword="true"/> if a scalar value was successfully extracted from the specified index,
            <see langword="false"/> if a value could not be extracted due to invalid data.</returns>
            <remarks>
            Throws only if <paramref name="input"/> is null or <paramref name="index"/> is out of range.
            </remarks>
        </member>
        <member name="M:System.Text.Rune.UnsafeCreate(System.UInt32)">
            <summary>
            Creates a <see cref="T:System.Text.Rune"/> without performing validation on the input.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeDebug.ToHexString(System.UInt32)">
            <summary>
            Formats a code point as the hex string "U+XXXX".
            </summary>
            <remarks>
            The input value doesn't have to be a real code point in the Unicode codespace. It can be any integer.
            </remarks>
        </member>
        <member name="F:System.Text.UnicodeUtility.ReplacementChar">
            <summary>
            The Unicode replacement character U+FFFD.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetPlane(System.UInt32)">
            <summary>
            Returns the Unicode plane (0 through 16, inclusive) which contains this code point.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetScalarFromUtf16SurrogatePair(System.UInt32,System.UInt32)">
            <summary>
            Returns a Unicode scalar value from two code points representing a UTF-16 surrogate pair.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-16 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf16SurrogatesFromSupplementaryPlaneScalar(System.UInt32,System.Char@,System.Char@)">
            <summary>
            Decomposes an astral Unicode scalar into UTF-16 high and low surrogate code units.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.GetUtf8SequenceLength(System.UInt32)">
            <summary>
            Given a Unicode scalar value, gets the number of UTF-8 code units required to represent this value.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsAsciiCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is an ASCII
            character ([ U+0000..U+007F ]).
            </summary>
            <remarks>
            Per http://www.unicode.org/glossary/#ASCII, ASCII is only U+0000..U+007F.
            </remarks>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsBmpCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is in the
            Basic Multilingual Plane (BMP).
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsHighSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 high surrogate code point,
            i.e., is in [ U+D800..U+DBFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsInRangeInclusive(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is between
            <paramref name="lowerBound"/> and <paramref name="upperBound"/>, inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsLowSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 low surrogate code point,
            i.e., is in [ U+DC00..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsSurrogateCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a UTF-16 surrogate code point,
            i.e., is in [ U+D800..U+DFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidCodePoint(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="codePoint"/> is a valid Unicode code
            point, i.e., is in [ U+0000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.UnicodeUtility.IsValidUnicodeScalar(System.UInt32)">
            <summary>
            Returns <see langword="true"/> iff <paramref name="value"/> is a valid Unicode scalar
            value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt32AreAscii(System.UInt32)">
            <summary>
            Returns true iff the UInt32 represents two ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.AllCharsInUInt64AreAscii(System.UInt64)">
            <summary>
            Returns true iff the UInt64 represents four ASCII UTF-16 characters in machine endianness.
            </summary>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToLowercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            lowercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.ConvertAllAsciiCharsInUInt32ToUppercase(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns the invariant
            uppercase representation of those characters. Requires the input value to contain
            two ASCII UTF-16 characters in machine endianness.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyLowercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more lowercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32ContainsAnyUppercaseAsciiChar(System.UInt32)">
            <summary>
            Given a UInt32 that represents two ASCII UTF-16 characters, returns true iff
            the input contains one or more uppercase ASCII characters.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt32OrdinalIgnoreCaseAscii(System.UInt32,System.UInt32)">
            <summary>
            Given two UInt32s that represent two ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="M:System.Text.Unicode.Utf16Utility.UInt64OrdinalIgnoreCaseAscii(System.UInt64,System.UInt64)">
            <summary>
            Given two UInt64s that represent four ASCII UTF-16 characters each, returns true iff
            the two inputs are equal using an ordinal case-insensitive comparison.
            </summary>
            <remarks>
            This is a branchless implementation.
            </remarks>
        </member>
        <member name="T:System.Linq.EnumerableExJet">
            <summary>
            Extension methods that mimic or extend the standard <see cref="T:System.Linq.Enumerable"/> methods, sharing the same names.
            Thus, this class MUST be in the same namespace, so that there were no problems when importing one of them at random.
            </summary>
        </member>
        <member name="M:System.Linq.EnumerableExJet.First``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Returns the first element of a sequence. 
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to return the first element of. </param>
            <param name="sExceptionMessageEmpty">The message for an exception to be thrown if the <paramref name="source"/> is empty.</param>
            <returns>The first element in the specified sequence. </returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, throws an exception  (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)" />).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg4"></param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)">
            <summary>
            Returns the only element of a sequence that satisfies a specified condition.
            If there're no such elements, returns NULL (hence difference with <see cref="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)" />).
            If there're multiple such elements, logs an exception and uses the first one.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from. </param>
            <param name="sContextSentence">The context for the exception message. Must be a complete sentence. Will be added to the message which says there're no/multiple items.</param>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.Single``1(System.Collections.Generic.IEnumerable{``0},System.String,System.String)">
            <seealso cref="M:System.Linq.EnumerableExJet.SingleOrFirstErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>
            <seealso cref="M:System.Linq.EnumerableExJet.SingleOrFirstOrDefaultErr``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Object,System.Object,System.Object,System.Object)"/>
            <summary>
            Returns the only element of a sequence that satisfies a specified condition, and throws an exception if more than one such element exists.
            </summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> to return a single element from. </param>
            <param name="sExceptionMessageEmpty">The message for an exception to be thrown if the <paramref name="source" /> is empty.</param>
            <param name="sExceptionMessageAmbiguous">The message for an exception to be thrown if the <paramref name="source" /> contains more than one element.</param>
            <returns>The single element of the input sequence that satisfies a condition.</returns>
        </member>
        <member name="M:System.Linq.EnumerableExJet.Sort``2(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Sort components by priority from from greatest to least
            </summary>
            <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of components to sort. </param>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.#ctor(System.Collections.Generic.ICollection{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.#ctor(JetBrains.Util.dataStructures.FrugalLocalList{`0},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Frugal local list constructor.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.SetEquals(System.Collections.Generic.IJetSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.IsSupersetOf(System.Collections.Generic.ICollection{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="M:System.Collections.Generic.JetHashSet`1.IsSupersetOf(System.Collections.Generic.IJetSet{`0})">
            <summary>
            Static overload to prevent runtime type checks.
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.HashCode">
            <summary>
            Cached hash code of the key, -1 means entry is free
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.NextEntryIndex">
            <summary>
            Index of next entry in the chain of keys with the same hashcodes (modulo size), -1 means last
            </summary>
        </member>
        <member name="F:System.Collections.Generic.JetHashSet`1.Entry.Element">
            <summary>
            Element of set
            </summary>
        </member>
        <member name="T:System.Collections.Generic.JetHashSetSorted`1">
            <summary>
            Makes sure you have quick hash-access to items and proper sorting order on items.
            This is fulfilled by maintaining an add-only regular hashset where all of the adds are in the correct order. This way the hashset operates right in the desired fashion.
            This wrapper only validates that there're no removes and all additions are properly sorted.
            </summary>
            <typeparam name="TItem"></typeparam>
        </member>
        <member name="F:System.Collections.Generic.JetHashSetSorted`1.myLastItem">
            <summary>
            Valid if <see cref="F:System.Collections.Generic.JetHashSetSorted`1.myHashSet"/> is nonempty.
            </summary>
        </member>
    </members>
</doc>
