<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.TextControl</name>
    </assembly>
    <members>
        <member name="T:JetBrains.TextControl.Actions.TextControlActionsFinalHandler">
            <summary>
            When a text control action is executed, at first all registered overridden handlers are called (features' special processing for the action).
            Finally (unless prevented), it falls back to the text control, which sends it to the text control frontend to do the real thing (say, move caret on <see cref="F:JetBrains.Application.UI.ActionSystem.Text.TextControlActions.ActionIds.Left" />).
            This class manages around this final handler in backend text control user data, specific to each backend text control instance. The creator of a text control should put this handler. <see cref="T:JetBrains.TextControl.Actions.TextControlActionBase" /> inheritors would read the user data and delegate to the handler.
            </summary>
            <seealso cref="T:JetBrains.TextControl.TextControlFinalTypingHandler" />
        </member>
        <member name="F:JetBrains.TextControl.Actions.TextControlActionsFinalHandler.TextControlActionsFinalHandlerUserDataKey">
            <summary>
            Storage key on the text control instance.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Actions.TextControlActionsFinalHandler.Registrar">
            <summary>
            Adds handlers to the action system, tracks which is what.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.AnonymousTextControl">
            <summary>
            The retained-state implementation which is based on properties and can be fully driven by outside clients without deriving from the class.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.AnonymousTextControl.myDocument">
            <summary>
            The Document. This is backend-only, used for exposing on the text control APIs, transporting is controlled by whoever creates our instance.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.AnonymousTextControl.myTransport">
            <summary>
            This is the transport model. The main data storage component, exposed by our interfaces.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.ToString">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.AnonymousTextControl.JetBrains#TextControl#ITextControl#Transport">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.System#IEquatable{JetBrains#TextControl#Coords#ITextControlPos}#Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToDocLineColumn">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffset">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffsetAndVirtual">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToScreen">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.AnonymousTextControl.Position.JetBrains#TextControl#Coords#ITextControlPos#ToTextControlLineColumn">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.BackendTextControlServices">
            <summary>
            When landing a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> on the backend side, an <see cref="T:JetBrains.TextControl.AnonymousTextControl" /> object exposes the data model and direct API calls to the clients, while this class binds the parts of the text control behaviors which got to be executed on the backend to other backend features (such as typing handlers).
            The communication with the <see cref="T:JetBrains.TextControl.AnonymousTextControl" /> of the <see cref="T:JetBrains.TextControl.ITextControl" /> should happen via <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" />. The instance is given so that we had the <see cref="T:JetBrains.TextControl.ITextControl" /> to expose to other features.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.BackendTextControlServices.BindOnImplementation(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.AnonymousTextControl,JetBrains.Application.Threading.IShellLocks,JetBrains.Application.UI.Actions.ActionManager.IActionManager)">
            <summary>
            Binds parts of the text control implementation which require additional components or complicated logic (and thus are not handled by <see cref="T:JetBrains.TextControl.AnonymousTextControl" /> itself), but do not involve working with the model.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.BackendTextControlServices.BindOnTransport(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.ITextControl,JetBrains.TextControl.Transport.TransportTextControl,JetBrains.TextControl.TextControlTypingHandlers,JetBrains.Application.UI.ActionsRevised.Loader.IActionDefs,JetBrains.Application.DataContext.DataContexts,JetBrains.Application.UI.ActionsRevised.Handlers.IActionHandlers,JetBrains.Application.Threading.IShellLocks,JetBrains.Application.Settings.ISettingsStore,JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager,JetBrains.Application.changes.ChangeManager,JetBrains.Application.UI.Components.IIsApplicationActiveState,JetBrains.Util.ILogger)">
            <summary>
            Binds on the model (<see cref="T:JetBrains.TextControl.Transport.TransportTextControl" />) and uses <see cref="T:JetBrains.TextControl.ITextControl" /> as reference in the client APIs.
            Implements the parts of the model which should be done backend-only.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.BackendTextControlServices.GetBackendDocument(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId,JetBrains.Application.Components.IComponentContainer,JetBrains.Util.ILogger)">
            <summary>
            We get a transport identity for document, get the <see cref="T:JetBrains.DocumentModel.IDocument" /> which is the document's backend representation, and lock for the lifetime of the text control.
            NOTE: <see cref="T:JetBrains.TextControl.TextControlsManagement.LockDocumentsWhenOpenedInTextControls" /> also does this for all text controls as a convenience, but we do not want to rely on that of course.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons">
             <summary>
            	<para>
            		<para>Autogenerated identifier classes and identifier objects to Themed Icons registered with <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see>.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <c>Id</c> field of the identifier class.</para>
            	</para>
            </summary>
            <remarks>
            	<para>This code was compile-time generated to support Themed Icons in the JetBrains application.</para>
            	<para>It has two primary goals: load the icons of this assembly to be registered with <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> so that they were WPF-accessible and theme-sensitive; and emit early-bound accessors for referencing icons in codebehind in a compile-time-validated manner.</para>
            	<h1>XAML</h1>
            	<para>For performance reasons, the icons are not individually exposed with application resources. There is a custom markup extension to bind an image source in markup.</para>
            	<para>To use an icon from XAML, set an <see cref="T:System.Windows.Media.ImageSource"></see> property to the <see cref="T:System.CodeDom.CodeTypeReference"></see> markup extension, which takes an icon identifier class (nested in <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons"></see> class) as a parameter.</para>
            	<para>Example:</para>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+Trinity}" /&gt;</code>
            	<h1>Attributes</h1>
            	<para>Sometimes you have to reference an icon from a type attriute when you're defining objects in code. Typical examples are Options pages and Tool Windows.</para>
            	<para>To avoid the use of string IDs which are not validated very well, we've emitted identifier classes to be used with <c>typeof()</c> expression, one per each icon. Use the attribute overload which takes a <see cref="T:System.Type"></see> for an image, and choose your icon class from nested classes in the <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons"></see> class.</para>
            	<para>Example:</para>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.Trinity))]</code>
            	<h1>CodeBehind</h1>
            	<para>In codebehind, we have two distinct tasks: (a) specify some icon in the APIs and (b) render icon images onscreen.</para>
            	<para>On the APIs stage you should only manipulate icon identifier objects (of type <see cref="T:JetBrains.UI.Icons.IconId"></see>, statically defined in <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons"></see> in <c>Id</c> fields). Icon identifier classes (nested in <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons"></see>) should be turned into icon identifier objects as early as possible. Rendering is about getting an <see cref="T:System.Windows.Media.ImageSource"></see> to assign to WPF, or <see cref="T:System.Drawing.Bitmap"></see> to use with GDI+ / Windows Forms.</para>
            	<para>You should turn an identifier object into a rendered image as late as possible. The identifier is static and lightweight and does not depend on the current theme, while the image is themed and has to be loaded or generated/rasterized. You need an <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> instance to get the image out of an icon identifier object. Once you got the image, you should take care to change it with theme changes — either by using a live image property, or by listening to the theme change event. See <see cref="T:JetBrains.Application.Icons.IThemedIconManager"></see> and its extensions for the related facilities.</para>
            	<para>Example:</para>
            	<code>// Getting IconId identifier object to use with APIs
            IconId iconid = ErrorStripeThemedIcons.Trinity.Id;</code>
            	<code>// Getting IconId out of an Icon Identifier Class type
            IconId iconid = new JetBrains.Application.Icons.CompiledIconsCs.CompiledIconCsId(typeof(ErrorStripeThemedIcons.Trinity));</code>
            	<code>// Getting image for screen rendering by IconId
            themediconmanager.Icons[icnoid]</code>
            	<code>// Getting image for screen rendering by Icon Identifier Class
            themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.Trinity&gt;()</code>
            	<h1>Icons Origin</h1>
            	<para>This code was generated by a pre-compile build task from a set of input files which are XAML files adhering to a certain convention, as convenient for exporting them from the Illustrator workspace, plus separate PNG files with raster icons. In the projects, these files are designated with <c>ThemedIconsXamlV3</c> and <c>ThemedIconPng</c> build actions and do not themselves get into the output assembly. All of such files are processed, vector images for different themes of the same icon are split and combined into the single list of icons in this assembly. This list is then written into the genearted XAML file (compiled into BAML within assembly), and serves as the source for this generated code.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError">
             <summary>
            	<para>
            		<para>ErrorStripeError Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                      _=+)t266a{T+=_         
                   ^tADA6VoIttxoS6HDR1=      
                 +H8RV7++++++++++++Ta#8#L`   
               _48#{?rrrrrrrrrrrrrrrrrld8H"  
              ,D%kcLLLLLLLLLLLLLLLLLLLLL2%8~ 
             `DMh))))))))))))))))))))))))yM%-
             l0DTTTT"````````````````"TTTTR0a
             d$wTTTT:                :TTTTE$%
             R$w7777,                ,7777P$B
             nQ8lJJJ~````````````````~JJJJDQ4
             -$Q6llllllllllllllllllllllllkQQ,
              ;Qg6ttttttttttttttttttttttkQgr 
               =$g8utttttttttttttttttt1RgQ*  
                `IggMw3}}}}}}}}}}}}16%ggS.   
                  `cRgg0DAwXVVh9GDWgg87.     
                     `!ij6D$ggQDwai*`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeError}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeError))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeError.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeError&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.Id">
             <summary>
            	<para>
            		<para>ErrorStripeError Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError"></see> identifier class.</para>
            		<para>
            			<code>
                      _=+)t266a{T+=_         
                   ^tADA6VoIttxoS6HDR1=      
                 +H8RV7++++++++++++Ta#8#L`   
               _48#{?rrrrrrrrrrrrrrrrrld8H"  
              ,D%kcLLLLLLLLLLLLLLLLLLLLL2%8~ 
             `DMh))))))))))))))))))))))))yM%-
             l0DTTTT"````````````````"TTTTR0a
             d$wTTTT:                :TTTTE$%
             R$w7777,                ,7777P$B
             nQ8lJJJ~````````````````~JJJJDQ4
             -$Q6llllllllllllllllllllllllkQQ,
              ;Qg6ttttttttttttttttttttttkQgr 
               =$g8utttttttttttttttttt1RgQ*  
                `IggMw3}}}}}}}}}}}}16%ggS.   
                  `cRgg0DAwXVVh9GDWgg87.     
                     `!ij6D$ggQDwai*`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeError}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeError))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeError.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeError&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeError theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeError theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeError theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeError.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeError.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext">
             <summary>
            	<para>
            		<para>ErrorStripeFindNext Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                          -;*)ltl)*;-        
                       '+Ia{+!~~~!+{aI+-     
                      +VV+_`._:":_.`_+SVr    
                     cKa^.-"==="^=="-."2Ks   
                    _XX!--,,-`    -,,--=XX"  
                    /ww_---'       '----6w+  
                    ~dd;_-````}bbbdHGORtdd=  
                     kAV"_-   I8DJ)))7DB%k   
                   _|3qRbT??+/rD8R+"""~4$R_  
                 _|]l;_THDDDHGGGAOG)"",,{$$+ 
               _|]l;_"=+oDDP~~~~^^"""",,:*8$a
             _|]l;_"=+oRRXDP~~~~^^"""",,:~d$D
             Cu[^"=+oRR|`7DAoojoooo|"",,+8$5`
             `+EXIoRR|`  =ziJJlR88F""""{$B+  
               .)3o|`         788{++*+4BR_   
                              5888%%MN0o`    
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeFindNext}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeFindNext))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeFindNext.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeFindNext&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.Id">
             <summary>
            	<para>
            		<para>ErrorStripeFindNext Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext"></see> identifier class.</para>
            		<para>
            			<code>
                          -;*)ltl)*;-        
                       '+Ia{+!~~~!+{aI+-     
                      +VV+_`._:":_.`_+SVr    
                     cKa^.-"==="^=="-."2Ks   
                    _XX!--,,-`    -,,--=XX"  
                    /ww_---'       '----6w+  
                    ~dd;_-````}bbbdHGORtdd=  
                     kAV"_-   I8DJ)))7DB%k   
                   _|3qRbT??+/rD8R+"""~4$R_  
                 _|]l;_THDDDHGGGAOG)"",,{$$+ 
               _|]l;_"=+oDDP~~~~^^"""",,:*8$a
             _|]l;_"=+oRRXDP~~~~^^"""",,:~d$D
             Cu[^"=+oRR|`7DAoojoooo|"",,+8$5`
             `+EXIoRR|`  =ziJJlR88F""""{$B+  
               .)3o|`         788{++*+4BR_   
                              5888%%MN0o`    
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeFindNext}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeFindNext))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeFindNext.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeFindNext&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeFindNext theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeFindNext theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeFindNext theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeFindNext.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeFindNext.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid">
             <summary>
            	<para>
            		<para>ErrorStripeInvalid Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lssc+!~,-         
                   _+F3l?/=^__"~!?73]r,      
                 ~{oF!-  -~~/      .;tox=    
               -l5l_  ^IGDDDD         -T5F_  
              -oa/` ^XRRRRRRR           ~a5_ 
             `oV*``(HHHHHHHHH````````````=VS.
             +EI``/bbbbbbbbbb`````````````lET
             1hr``u6666666666`````````````!hk
             o6?``uPPPPPPPPPP{\,``````````!6P
             )wo..+kkkkkkkkkkkkke)=-......twY
             .4b+'-Taaaaaaaaaaaaaaaa}\_'';bb-
              ^bH+--!uoooooooooooooou+--;dH; 
               "6OI"-_!l3333333333}\_-:lOb=  
                `|ARar"_:=//rr//=,_,+o##J`   
                  `/5DDyfT?*;;/r|f5RDk+`     
                     `~r7IVbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeInvalid}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeInvalid))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeInvalid.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeInvalid&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.Id">
             <summary>
            	<para>
            		<para>ErrorStripeInvalid Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid"></see> identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lssc+!~,-         
                   _+F3l?/=^__"~!?73]r,      
                 ~{oF!-  -~~/      .;tox=    
               -l5l_  ^IGDDDD         -T5F_  
              -oa/` ^XRRRRRRR           ~a5_ 
             `oV*``(HHHHHHHHH````````````=VS.
             +EI``/bbbbbbbbbb`````````````lET
             1hr``u6666666666`````````````!hk
             o6?``uPPPPPPPPPP{\,``````````!6P
             )wo..+kkkkkkkkkkkkke)=-......twY
             .4b+'-Taaaaaaaaaaaaaaaa}\_'';bb-
              ^bH+--!uoooooooooooooou+--;dH; 
               "6OI"-_!l3333333333}\_-:lOb=  
                `|ARar"_:=//rr//=,_,+o##J`   
                  `/5DDyfT?*;;/r|f5RDk+`     
                     `~r7IVbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeInvalid}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeInvalid))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeInvalid.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeInvalid&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeInvalid theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeInvalid theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeInvalid theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeInvalid.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeInvalid.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff">
             <summary>
            	<para>
            		<para>ErrorStripeOff Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lzzc+!~,-         
                   _+Y3jyEU6ww6XEy23[r,      
                 ~{oeZHDDDDDDDDDDDDGU5o]=    
               -leyw#RRRRRRRRRRRRRRRRRbVe{_  
              -oaUGGGGGGGGGGGGGGGGGGGGGGXa5_ 
             `oVUbbbbba    -bb-    abbbbbXVy.
             +EP9wwwww5    _ww_    5wwwwwwPET
             xhUXXXXXXj````:XX:````jXXXXXXXhk
             uXXZZZZZZo...."ZZ"....oZZZZZZXXP
             )96kkkkkku----^kk^----ukkkkkk69{
             .4bhSSSSSI----~SS~----ISSSSSPbb-
              ^bHZaaaaexxxxIaaIxxxxeaaaakHH; 
               "6Owaoooooooooooooooooo56Ob=  
                `|ARbEo333333333333okbR#J`   
                  `/5DDd9UEVaaSkh9bRDk+`     
                     `~r71VbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeOff}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeOff))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeOff.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeOff&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.Id">
             <summary>
            	<para>
            		<para>ErrorStripeOff Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff"></see> identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lzzc+!~,-         
                   _+Y3jyEU6ww6XEy23[r,      
                 ~{oeZHDDDDDDDDDDDDGU5o]=    
               -leyw#RRRRRRRRRRRRRRRRRbVe{_  
              -oaUGGGGGGGGGGGGGGGGGGGGGGXa5_ 
             `oVUbbbbba    -bb-    abbbbbXVy.
             +EP9wwwww5    _ww_    5wwwwwwPET
             xhUXXXXXXj````:XX:````jXXXXXXXhk
             uXXZZZZZZo...."ZZ"....oZZZZZZXXP
             )96kkkkkku----^kk^----ukkkkkk69{
             .4bhSSSSSI----~SS~----ISSSSSPbb-
              ^bHZaaaaexxxxIaaIxxxxeaaaakHH; 
               "6Owaoooooooooooooooooo56Ob=  
                `|ARbEo333333333333okbR#J`   
                  `/5DDd9UEVaaSkh9bRDk+`     
                     `~r71VbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeOff}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeOff))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeOff.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeOff&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeOff theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeOff theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeOff theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOff.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeOff.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK">
             <summary>
            	<para>
            		<para>ErrorStripeOK Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
             $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
             QQ6TTTTTTTTTTTTTTTTTTTTTTTTTTVQQ
             QQV++ttttttttttttttttttttttr+IQQ
             gghLLXXXXXXXXXXXXXXXE}}}oXX)Legg
             gg4TTXXXXXXXXXXXXXXE_  .yXX7TVgg
             ggHJJXXXXXXXXXXXXXE_  .yXXXtJhgg
             gg#CCXXXXXXXXXXXXE_  .yXXXX1Cwgg
             ggDuuXXXXh!~~!hXE_  .yXXXXXjuHgg
             gg8SSXXXXXo`  "V_  .yXXXXXXVSRgg
             @@NhhXXXXXXo`  `  .yXXXXXXXXhD@@
             @@$bbXXXXXXXo`   .yXXXXXXXXbb%@@
             @@QOOXXXXXXXXV222EXXXXXXXXXAO$@@
             @@gDDXXXXXXXXXXXXXXXXXXXXXXDDQ@@
             @@gMMGGGGGGGGGGGGGGGGGGGGGG8Mg@@
             @@@ggggggggggggggggggggggggggg@@
             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeOK}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeOK))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeOK.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeOK&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.Id">
             <summary>
            	<para>
            		<para>ErrorStripeOK Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK"></see> identifier class.</para>
            		<para>
            			<code>
             $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
             QQ6TTTTTTTTTTTTTTTTTTTTTTTTTTVQQ
             QQV++ttttttttttttttttttttttr+IQQ
             gghLLXXXXXXXXXXXXXXXE}}}oXX)Legg
             gg4TTXXXXXXXXXXXXXXE_  .yXX7TVgg
             ggHJJXXXXXXXXXXXXXE_  .yXXXtJhgg
             gg#CCXXXXXXXXXXXXE_  .yXXXX1Cwgg
             ggDuuXXXXh!~~!hXE_  .yXXXXXjuHgg
             gg8SSXXXXXo`  "V_  .yXXXXXXVSRgg
             @@NhhXXXXXXo`  `  .yXXXXXXXXhD@@
             @@$bbXXXXXXXo`   .yXXXXXXXXbb%@@
             @@QOOXXXXXXXXV222EXXXXXXXXXAO$@@
             @@gDDXXXXXXXXXXXXXXXXXXXXXXDDQ@@
             @@gMMGGGGGGGGGGGGGGGGGGGGGG8Mg@@
             @@@ggggggggggggggggggggggggggg@@
             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeOK}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeOK))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeOK.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeOK&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeOK theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeOK theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeOK theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOK.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeOK.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial">
             <summary>
            	<para>
            		<para>ErrorStripeErrorPartial Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                      :;*Tz2665}|*;:         
                   ~zGDdXV2fzzt3aXpDmt;      
                 *p8#V7*r(}3Vk3}|L*|jm8m?`   
               :48mF??IRggggggggggD2crlH8q_  
              :D8kcc3Qgggggggggggggggacco88^ 
             `DMUTTbQQQQQQQQQQQQQQQQQQm|TyMW-
             i%8||hQQ8UUUUUUUUUUUUUU8QQb||#%e
             H$9778$$F              F$$$77E$W
             m$wvv8$$z              z$$%ivK$%
             nQ8iJ6MM#aaaaaaaaaaaaaa#MMpJJDQ6
             -$Q6l}q888888888888888888m{lkQQ,
              ;QQ6zzE8888888888888888XzzkQQr 
               ;$g83}tkqDDDDDDDDDDGKf}f#gQ+  
                `IggBwI}C2SZXXKSoI}f6WggS.   
                  `cmgg%DRwXVVUwADWgg87.     
                     `!v24D$gg$8wjv+`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:WufozefThemedIconsThemedIcons+ErrorStripeErrorPartial}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(WufozefThemedIconsThemedIcons.ErrorStripeErrorPartial))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = WufozefThemedIconsThemedIcons.ErrorStripeErrorPartial.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;WufozefThemedIconsThemedIcons.ErrorStripeErrorPartial&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.Id">
            <inheritdoc cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeErrorPartial theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeErrorPartial theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeErrorPartial theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeErrorPartial.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeErrorPartial.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial">
             <summary>
            	<para>
            		<para>ErrorStripeOKPartial Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
             88888888888888888888888888888888
             WWKvvvvvvvvvvvvvvvvvvvvvvvvvvyWW
             %%e**OOOOOOOOOOOOOOOOOOOOOOc*t%%
             $$a**@@@@@@@@@@@@@@@@888g@@|*f$$
             QQV**@@@@@@@@@@@@@@@"  -g@@|*IQQ
             QQk**@@@@@@@@@@@@@g"  -g@@@|*uQQ
             ggZ**ggggggggggggg_  -ggggg|*3gg
             ggU**gggggT==Tggg_  -Qggggg|*2gg
             ggX**ggggg8`  ;Q,  -$gggggg|*ogg
             gg6**ggggggD`  `  -Bggggggg)*ogg
             gg9**QQQQQQQ#`   -8QQQQQQQQT*egg
             @@w**$$$$$$$$8###8$$$$$$$$$T*y@@
             @@b**WWWWWWWWWWWWWWWWWWWWWWT*a@@
             @@p**kkkkkkkkkkkkkkkkkkkkkk?*V@@
             @@8tttttttttttttttttttttttttt#@@
             @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:WufozefThemedIconsThemedIcons+ErrorStripeOKPartial}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(WufozefThemedIconsThemedIcons.ErrorStripeOKPartial))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = WufozefThemedIconsThemedIcons.ErrorStripeOKPartial.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;WufozefThemedIconsThemedIcons.ErrorStripeOKPartial&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.Id">
            <inheritdoc cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeOKPartial theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeOKPartial theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeOKPartial theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeOKPartial.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeOKPartial.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial">
             <summary>
            	<para>
            		<para>ErrorStripeWarningPartial Themed Icon generated identifiers:</para>
            		<para>— <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial"></see> identifier class, for use in attributes, XAML, and generic parameters;</para>
            		<para>— <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.Id"></see> identifier object, as a field in the identifier class, for use where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected.</para>
            		<para>
            			<code>
                         ^eeeeee!            
                        ^Se;""^oS=           
                       ^VS^-:_-"jV=          
                      ^Ek;-:Kw_-~yE=         
                     ;KE;-:Emm6"-~VK\        
                    ;Xh;-:VAAAAX"-^kX*       
                   ;6X;-,SHx``xHh"-^Z6*      
                  ;46!:_ewwz  zwwP~:^h4*     
                 ;w4!:_5444i  i444V~:;Xw*    
                ;bw=:"2XXXXz``zXXXXS^:;6br   
               ;pb/:"3KKKKKKKKKKKKKKj^:;9pr  
              ;qp+,~ukkkkkkJ``Jkkkkkk2^,;wqr 
             !OA*,~fVVVVVVVI**IVVVVVVV2^,!HO?
             wmk^_;(|||||||||||||||||||;_^omq
             `|#R7======================Tp#}`
               :kDDDDDDDDDDDDDDDDDDDDDDDDX"  
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:WufozefThemedIconsThemedIcons+ErrorStripeWarningPartial}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(WufozefThemedIconsThemedIcons.ErrorStripeWarningPartial))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = WufozefThemedIconsThemedIcons.ErrorStripeWarningPartial.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;WufozefThemedIconsThemedIcons.ErrorStripeWarningPartial&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.Id">
            <inheritdoc cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial">identifier class</inheritdoc>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeWarningPartial theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeWarningPartial theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeWarningPartial theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarningPartial.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeWarningPartial.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning">
             <summary>
            	<para>
            		<para>ErrorStripeRunning Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lssc+!~,-         
                   _+F3l?/=^__"~!?73]r,      
                 ~{oF!-  -~~/      .;tox=    
               -l5l_  ^1HRRRR         -T5F_  
              -oa/` ^PGGGGGGG           ~a5_ 
             `oV*``cwwwwwwwww````````````=VS.
             +EI``!XXXXXXXXXX`````````````lET
             1hr``[kkkkkkkkkk`````````````!hk
             o6?``CaaaaaaaJ/:`````````````!6P
             )wo..\ooo[r~-................twY
             .4b+''+!,''''''''''''''''''';bb-
              ^bH+----------------------;dH; 
               "6OI"------------------:lOb=  
                `|ARar"____________,+o##J`   
                  `/5DDyfT?*;;/r|f5RDk+`     
                     `~r7IVbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeRunning}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeRunning))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeRunning.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeRunning&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.Id">
             <summary>
            	<para>
            		<para>ErrorStripeRunning Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning"></see> identifier class.</para>
            		<para>
            			<code>
                      ',~;+Lssc+!~,-         
                   _+F3l?/=^__"~!?73]r,      
                 ~{oF!-  -~~/      .;tox=    
               -l5l_  ^1HRRRR         -T5F_  
              -oa/` ^PGGGGGGG           ~a5_ 
             `oV*``cwwwwwwwww````````````=VS.
             +EI``!XXXXXXXXXX`````````````lET
             1hr``[kkkkkkkkkk`````````````!hk
             o6?``CaaaaaaaJ/:`````````````!6P
             )wo..\ooo[r~-................twY
             .4b+''+!,''''''''''''''''''';bb-
              ^bH+----------------------;dH; 
               "6OI"------------------:lOb=  
                `|ARar"____________,+o##J`   
                  `/5DDyfT?*;;/r|f5RDk+`     
                     `~r7IVbDDdE3ir=`        
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeRunning}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeRunning))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeRunning.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeRunning&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeRunning theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeRunning theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeRunning theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeRunning.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeRunning.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning">
             <summary>
            	<para>
            		<para>ErrorStripeWarning Themed Icon autogenerated identifier class.</para>
            		<para>Identifier classes should be used in attributes, XAML, or generic parameters. Where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected, use the identifier object in the <see cref="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.Id"></see> field of the identifier class.</para>
            		<para>
            			<code>
                         ,777777~            
                        ,J7_..-TJ~           
                       "ll-    .7l~          
                      "tt_      'Jt=         
                     "{}_        -l{=        
                    "C{_   ~@@~   -tC=       
                   "xC_````~@@~````-tx=      
                  ^I1,`````~@@~`````-fI=     
                 ^nI,``````=@@=``````_[n;    
                ^ou"```````~gg~```````_1o!   
               ~2o"````````````````````_n2!  
              ~a2^`````````=gg=`````````:ua! 
             ~ya^.........._cc_..........,oy/
             oV}_........................-7Va
             `+kS\""""""""""""""""""""""!5k)`
               -CEEEEEEEEEEEEEEEEEEEEEEEE3:  
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeWarning}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeWarning))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeWarning.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeWarning&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="F:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.Id">
             <summary>
            	<para>
            		<para>ErrorStripeWarning Themed Icon autogenerated identifier object.</para>
            		<para>Identifier objects should be used where an <see cref="T:JetBrains.UI.Icons.IconId"></see> value is expected. In attributes, XAML, or generic parameters use the containing <see cref="T:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning"></see> identifier class.</para>
            		<para>
            			<code>
                         ,777777~            
                        ,J7_..-TJ~           
                       "ll-    .7l~          
                      "tt_      'Jt=         
                     "{}_        -l{=        
                    "C{_   ~@@~   -tC=       
                   "xC_````~@@~````-tx=      
                  ^I1,`````~@@~`````-fI=     
                 ^nI,``````=@@=``````_[n;    
                ^ou"```````~gg~```````_1o!   
               ~2o"````````````````````_n2!  
              ~a2^`````````=gg=`````````:ua! 
             ~ya^.........._cc_..........,oy/
             oV}_........................-7Va
             `+kS\""""""""""""""""""""""!5k)`
               -CEEEEEEEEEEEEEEEEEEEEEEEE3:  
            </code>
            		</para>
            	</para>
            </summary>
            <remarks>
            	<para>For details on Themed Icons and their use, see Remarks on the outer class.</para>
            </remarks>
            <example>
            	<code>&lt;Image Source="{icons:ThemedIcon myres:ErrorStripeThemedIcons+ErrorStripeWarning}" /&gt;        &lt;!-- XAML --&gt;</code>
            </example>
            <example>
            	<code>[Item(Name="Sample", Icon=typeof(ErrorStripeThemedIcons.ErrorStripeWarning))]        // C# Type attribute</code>
            </example>
            <example>
            	<code>IconId iconid = ErrorStripeThemedIcons.ErrorStripeWarning.Id;        // IconId identifier object</code>
            </example>
            <example>
            	<code>themediconmanager.GetIcon&lt;ErrorStripeThemedIcons.ErrorStripeWarning&gt;()        // Icon image for rendering</code>
            </example>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.Load_Color">
            <summary>Loads the image for Themed Icon ErrorStripeWarning theme aspect Color.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.Load_Gray">
            <summary>Loads the image for Themed Icon ErrorStripeWarning theme aspect Gray.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.Load_GrayDark">
            <summary>Loads the image for Themed Icon ErrorStripeWarning theme aspect GrayDark.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Src.BaseImpl.ErrorStripeThemedIcons.ErrorStripeWarning.GetThemeImages">
            <summary>Returns the set of theme images for Themed Icon ErrorStripeWarning.</summary>
        </member>
        <member name="T:JetBrains.TextControl.BaseImpl.ScrollsTextControlAfterCaretMove">
            <summary>
            Helper to share the code which applies scrolling after moving the caret.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.BaseImpl.ScrollsTextControlAfterCaretMove.IsLayoutKnownByUser">
            <summary>
              <para>Gets whether the user is likely to know the visual layout of this text control.</para>
              <para>This means that scrollings and caret movements should better be relative to the current position rather than absolute.</para>
              <para>Formally, it's a bool state that raises some time after the control gets visible, and keeps for some small time after it gets hidden.
            These delays guarantee that (1) short switches back and forth when eg creating from usage in another text control do not affect the picture
            and (2) after the fresh new text control is opened for the first time the first positioning is done with layout “unknown”.</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.BaseImpl.UselessTextControl">
            <summary>Helps with creating a text control which cannot do anything but track its selection/caret/document.</summary>
        </member>
        <member name="T:JetBrains.TextControl.CaretVisualPlacement">
            <summary>
            After positioning the caret in the document, scrolls the text control to reveal the caret position.
            This affects the visual location of the caret after scrolling.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.CaretVisualPlacement.DontScrollIfVisible">
            <summary>
            Does not do any scrolling if the new caret position is already visible.
            If the caret gets too close to the edge, <see cref="F:JetBrains.TextControl.CaretVisualPlacement.Generic"/> would scroll it away. This mode avoids the effect.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.CaretVisualPlacement.Generic">
            <summary>
            When moving within the active text control, ensures the caret is not too close to the edge with minimal amount of scrolling.
            When jumping to another text control, places the caret at the predefined position.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.CaretVisualPlacement.DirectionalUp">
            <summary>
            When moving within the active text control, works almost as <see cref="F:JetBrains.TextControl.CaretVisualPlacement.Generic"/>, but avoids scrolling the caret away from a too-near edge if this means scrolling against the caret movement direction.
            When jumping to another text control, places the caret at the predefined position consistent with generic scrolling in the given direction within the same text control.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.CaretVisualPlacement.DirectionalDown">
            <summary>
            When moving within the active text control, works almost as <see cref="F:JetBrains.TextControl.CaretVisualPlacement.Generic"/>, but avoids scrolling the caret away from a too-near edge if this means scrolling against the caret movement direction.
            When jumping to another text control, places the caret at the predefined position consistent with generic scrolling in the given direction within the same text control.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.ITextControlCoords">
            <summary>
            An entry point to the text control coordinate conversions.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.ITextControlPos">
            <summary>
            Represents an abstracted point on the text control that can be converted to any more or less equivalent representation.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.ITextControlPos.TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToDocLineColumn">
            <summary>
            Converts the position to document line-column coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToDocOffset">
            <summary>
            Converts the position to an offset from the beginning of the document text.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToDocOffsetAndVirtual">
            <summary>
            Converts the position to an offset from the beginning of the document text, plus,
            if the position represented a point in the editor virtual space, the number of virtual
            spaces from the last real document character to the addressed position.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos" /> method allows to precalculate all of the positions for the given moment in time,
            which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the
            unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToScreen">
            <summary>
            Converts the position to screen pixel coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.ITextControlPos.ToTextControlLineColumn">
            <summary>
            Converts the position to text control line-column coordinates.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn">
            <summary>
            Coordinate conversion from document line/column coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn.Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="iother"/> parameter; otherwise, false.
            </returns>
            <param name="iother">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocLineColumn.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual">
            <summary>
            Coordinate conversion from document offset with virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual.Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="iother"/> parameter; otherwise, false.
            </returns>
            <param name="iother">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.PositionKinds.TextControlPosDocOffsetAndVirtual.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained">
            <summary>
            Stores a retained coordinate snapshot.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.OptionDontRetainPixels">
            <summary>
            Allows to exclude <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToScreen"/> pixel coordinates from precalculation.
            <see cref="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained"/>-type properties won't be reliable on change regarding these, but each calculation won't be so slow.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.myPosOriginal">
            <summary>
            The position from which this retained position has been created by pre-calculating all of the transformations.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.#ctor(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Creates a snapshot of all the <paramref name="pos"/> aspects.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.#ctor(JetBrains.TextControl.ITextControl)">
            <summary>
            Only for <see cref="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.CreateEmpty(JetBrains.TextControl.ITextControl)"/>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.CreateEmpty(JetBrains.TextControl.ITextControl)">
            <summary>
            Creates an all-<c>Null</c> position. Text control must be specified in any case.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.Freeze(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Creates a snapshot of all the <paramref name="pos"/> aspects.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="iother"/> parameter; otherwise, false.
            </returns>
            <param name="iother">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToDocLineColumn">
            <summary>
            Converts the position to document line-column coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffset">
            <summary>
            Converts the position to an offset from the beginning of the document text.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToDocOffsetAndVirtual">
            <summary>
            Converts the position to an offset from the beginning of the document text, plus, if the position represented a point in the editor virtual space, the number of virtual spaces from the last real document character to the addressed position.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToScreen">
            <summary>
            Converts the position to screen pixel coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#ToTextControlLineColumn">
            <summary>
            Converts the position to text control line-column coordinates.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.PositionKinds.TextControlPosRetained.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen">
            <summary>
            Coordinate conversion from screen pixel coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen.Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="iother"/> parameter; otherwise, false.
            </returns>
            <param name="iother">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.PositionKinds.TextControlPosScreen.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn">
            <summary>
            Coordinate conversion from text control line/column coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn.Equals(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="iother"/> parameter; otherwise, false.
            </returns>
            <param name="iother">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn.JetBrains#TextControl#Coords#ITextControlPos#ToRetainedPos">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.ITextControlPos.ToRetainedPos"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Coords.PositionKinds.TextControlPosTextControlLineColumn.JetBrains#TextControl#Coords#ITextControlPos#TextControl">
            <summary>
            Gets the text control that will be translating the position to various coordinate systems.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore">
            <summary>
            Implements the few methods that make it possible to implement the multitude of conversions supported by <see cref="T:JetBrains.TextControl.Coords.ITextControlCoords" />-<see cref="T:JetBrains.TextControl.Coords.ITextControlPos" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.#ctor(JetBrains.TextControl.ITextControl)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocLineColumn_To_DocOffset(JetBrains.DocumentModel.DocumentCoords)">
            <summary>
            Standard implementation that uses platform doc line index.
            May be out of sync with VS model at times.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocLineColumn_To_DocOffset_Core(JetBrains.DocumentModel.DocumentCoords,JetBrains.DocumentModel.IDocument)">
            <summary>
            Standard implementation that uses platform doc line index.
            May be out of sync with VS model at times.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocLineColumn_To_TextControlLineColumn(JetBrains.DocumentModel.DocumentCoords)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocOffset_To_DocLineColumn(JetBrains.TextControl.DocOffsetAndVirtual)">
            <summary>
            Standard implementation that uses platform doc line index.
            May be out of sync with VS model at times.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocOffset_To_DocLineColumn(JetBrains.TextControl.DocOffsetAndVirtual,JetBrains.DocumentModel.IDocument)">
            <summary>
            Standard implementation that uses platform doc line index.
            May be out of sync with VS model at times.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.DocOffset_To_TextControlLineColumn(JetBrains.TextControl.DocOffsetAndVirtual)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.Screen_To_TextControlLineColumn(JetBrains.Util.Media.JetPhysicalPoint)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.TextControlLineColumn_To_DocLineColumn(JetBrains.TextControl.TextControlLineColumn)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.TextControlLineColumn_To_DocOffset(JetBrains.TextControl.TextControlLineColumn)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.TextControlLineColumn_To_Screen(JetBrains.TextControl.TextControlLineColumn)">
            <summary>
            Conversion method.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.Screen_To_Viewport(JetBrains.Util.Media.JetPhysicalPoint)">
            <summary>
            Helper conversion for deriving screen conversions from canvas ones.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlCoordinateConversionCore.Viewport_To_Screen(JetBrains.Util.Media.JetPhysicalPoint)">
            <summary>
            Helper conversion for deriving screen conversions from canvas ones.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.TextControlCoords">
            <summary>
            Implements the creation of <see cref="T:JetBrains.TextControl.Coords.ITextControlPos" /> from various sources.
            Supply with the conversion core.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Coords.TextControlPosRange">
            <summary>
            Defines a range between two <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/>.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Coords.TextControlPosRange.End">
            <summary>
            Range end. This position belongs to <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.TextControl"/>.
            Note that it's not guaranteed that <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.Start"/> goes before <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.End"/>.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Coords.TextControlPosRange.Start">
            <summary>
            Range start. This position belongs to <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.TextControl"/>.
            Note that it's not guaranteed that <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.Start"/> goes before <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.End"/>.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Coords.TextControlPosRange.TextControl">
            <summary>
            Both <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.Start"/> and <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.End"/> belong to this text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.FromDocLineColumnRange(JetBrains.TextControl.ITextControl,JetBrains.DocumentModel.DocLineColumnRange)">
            <summary>
            Creates a text control range in universal positions based on the document range.
            </summary>
            <param name="textControl">The text control that will be used for translating the range into the text control coordinate space.</param>
            <param name="range">The range, in document coordinates.</param>
            <returns>Text control range in universal coordinates.</returns>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.FromDocRange(JetBrains.TextControl.ITextControl,JetBrains.Util.TextRange)">
            <summary>
            Creates a text control range in universal positions based on the document range.
            See also the <see cref="M:JetBrains.TextControl.Coords.TextControlPosRange.FromDocRange(JetBrains.TextControl.ITextControl,System.Int32,System.Int32)"/> overload that supports unnormalized ranges.
            </summary>
            <param name="textControl">The text control that will be used for translating the range into the text control coordinate space.</param>
            <param name="range">The range, in document coordinates.</param>
            <returns>Text control range in universal coordinates.</returns>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.FromDocRange(JetBrains.TextControl.ITextControl,System.Int32,System.Int32)">
            <summary>
            Creates a text control range in universal positions based on the document range.
            Unlike the <see cref="M:JetBrains.TextControl.Coords.TextControlPosRange.FromDocRange(JetBrains.TextControl.ITextControl,JetBrains.Util.TextRange)"/> overload, accepts unnormalized ranges.
            </summary>
            <param name="textControl">The text control that will be used for translating the range into the text control coordinate space.</param>
            <param name="start">The range start, in document coordinates.</param>
            <param name="end">The range end, in document coordinates.</param>
            <returns>Text control range in universal coordinates.</returns>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.FromTextControlLineCol(JetBrains.TextControl.ITextControl,JetBrains.TextControl.TextControlLineColumnRange)">
            <summary>
            Creates a text control range in universal positions based on the text control line-col coordinates.
            </summary>
            <param name="textControl">The text control that will be used for translating the range into the text control coordinate space.</param>
            <param name="range">The range, in text control line-col coordinates.</param>
            <returns>Text control range in universal coordinates.</returns>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToDocLineColumnRangeNormalized">
            <summary>
            Converts both ends to the document range.
            Normalizes the range, so that the start goes before the end.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToDocLineColumnRangeUnnormalized">
            <summary>
            Converts both ends to the document range.
            Does not normalize the range, the start might go after the end.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToDocRangeNormalized">
            <summary>
            Converts both ends to the document range.
            Makes sure the range is properly normalized, ie the start goes before the end.
            Raw ranges of the document selection, for instance, might be inverted if user selects with shift+left.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToDocRangeUnnormalized">
            <summary>
            Converts both ends to the document range.
            The range might not be normalized (start might go beyond the end).
            Raw ranges of the document selection, for instance, might be inverted if user selects with shift+left.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToRetained">
            <summary>
            Normally, an <see cref="T:JetBrains.TextControl.Coords.ITextControlPos"/> starts as a position of a specific kind and calculates the conversions as needed.
            The <see cref="M:JetBrains.TextControl.Coords.TextControlPosRange.ToRetained"/> method allows to precalculate all of the positions for the given moment in time, which provides for retaining the values in the <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded context</see> even after the unmanaged text control gets destroyed.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToTextControlLineColumnRangeNormalized">
            <summary>
            Converts both ends to the text control line-column range.
            Normalizes the range, so that the start goes before the end.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToTextControlLineColumnRangeUnnormalized">
            <summary>
            Converts both ends to the text control line-column range.
            Does not normalize the range, the start might go after the end.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            true if the specified <see cref="T:System.Object"/> is equal to the current <see cref="T:System.Object"/>; otherwise, false.
            </returns>
            <param name="obj">The <see cref="T:System.Object"/> to compare with the current <see cref="T:System.Object"/>. </param><exception cref="T:System.NullReferenceException">The <paramref name="obj"/> parameter is null.</exception><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.GetHashCode">
            <summary>
            Serves as a hash function for a particular type. 
            </summary>
            <returns>
            A hash code for the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.ToString">
            <summary>
            Returns a <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </summary>
            <returns>
            A <see cref="T:System.String"/> that represents the current <see cref="T:System.Object"/>.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.Coords.TextControlPosRange.Equals(JetBrains.TextControl.Coords.TextControlPosRange)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="E:JetBrains.TextControl.Data.IRangeableContainer`1.RemovedOnDocumentChange">
            <summary>
            Fired at the end of document change processing when invalidated items are automatically removed from container due to document change.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Data.RangeableContainer`2.EnsureUpdated">
            <summary>
            Make the container updated for the recent document change, and return if the futher container modification should be reflected in <see cref="F:JetBrains.TextControl.Data.RangeableContainer`2.myDocumentChangeData"/>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocOffset">
            <summary>
              <para>Represents an (<see cref="F:JetBrains.TextControl.DocOffset.Offset" />) in a text <see cref="T:JetBrains.DocumentModel.IDocument">document</see>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocOffset.Offset">
            <summary>
            An offset from the specific character to the beginning of the document, calculated as the number of bytes in the character string preceding this character when encoded with UTF-16LE variable-length encoding, divided by two. This matches the indexing of late Windows NT LPCWSTR and .NET CLI System.String in-memory string representations.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.Limited(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)">
            <summary>
            Limits the current value. Returns a copy that's guaranteed to be in the <c>[</c><paramref name="minInclusive" /><c>, </c><paramref name="maxExclusive" /><c>)</c> limits.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.Minus1">
            <summary>
            Subtracts one from the current value.
            Does not modify the original object.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.Plus1">
            <summary>
            Adds one to the current value.
            Does not modify the original object.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IComparable#CompareTo(System.Object)">
            <summary>
            Compares the current instance with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings: Value Meaning Less than zero This instance is less than <paramref name="obj" />. Zero This instance is equal to <paramref name="obj" />. Greater than zero This instance is greater than <paramref name="obj" />.
            </returns>
            <param name="obj">An object to compare with this instance. </param>
            <exception cref="T:System.ArgumentException"><paramref name="obj" /> is not the same type as this instance. </exception>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.CompareTo(JetBrains.TextControl.DocOffset)">
            <summary>
            Compares the current object with another object of the same type.
            </summary>
            <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has the following meanings: Value Meaning Less than zero This object is less than the <paramref name="other" /> parameter.Zero This object is equal to <paramref name="other" />. Greater than zero This object is greater than <paramref name="other" />.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#GetTypeCode">
            <summary>
            Returns the <see cref="T:System.TypeCode" /> for this instance.
            </summary>
            <returns>
            The enumerated constant that is the <see cref="T:System.TypeCode" /> of the class or value type that implements this interface.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToBoolean(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Boolean value using the specified culture-specific formatting information.
            </summary>
            <returns>
            A Boolean value equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 8-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToChar(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent Unicode character using the specified culture-specific formatting information.
            </summary>
            <returns>
            A Unicode character equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToDateTime(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.DateTime" /> using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.DateTime" /> instance equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToDecimal(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.Decimal" /> number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.Decimal" /> number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToDouble(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent double-precision floating-point number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A double-precision floating-point number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 16-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 32-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 64-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToSByte(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 8-bit signed integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 8-bit signed integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToSingle(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent single-precision floating-point number using the specified culture-specific formatting information.
            </summary>
            <returns>
            A single-precision floating-point number equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToString(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent <see cref="T:System.String" /> using the specified culture-specific formatting information.
            </summary>
            <returns>
            A <see cref="T:System.String" /> instance equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToType(System.Type,System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an <see cref="T:System.Object" /> of the specified <see cref="T:System.Type" /> that has an equivalent value, using the specified culture-specific formatting information.
            </summary>
            <returns>
            An <see cref="T:System.Object" /> instance of type <paramref name="conversionType" /> whose value is equivalent to the value of this instance.
            </returns>
            <param name="conversionType">The <see cref="T:System.Type" /> to which the value of this instance is converted. </param>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToUInt16(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 16-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 16-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToUInt32(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 32-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 32-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IConvertible#ToUInt64(System.IFormatProvider)">
            <summary>
            Converts the value of this instance to an equivalent 64-bit unsigned integer using the specified culture-specific formatting information.
            </summary>
            <returns>
            An 64-bit unsigned integer equivalent to the value of this instance.
            </returns>
            <param name="provider">An <see cref="T:System.IFormatProvider" /> interface implementation that supplies culture-specific formatting information. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.Equals(JetBrains.TextControl.DocOffset)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="M:JetBrains.TextControl.DocOffset.System#IFormattable#ToString(System.String,System.IFormatProvider)">
            <summary>
            Formats the value of the current instance using the specified format.
            </summary>
            <returns>
            A <see cref="T:System.String" /> containing the value of the current instance in the specified format.
            </returns>
            <param name="format">The <see cref="T:System.String" /> specifying the format to use.-or- null to use the default format defined for the type of the <see cref="T:System.IFormattable" /> implementation. </param>
            <param name="formatProvider">The <see cref="T:System.IFormatProvider" /> to use to format the value.-or- null to obtain the numeric format information from the current locale setting of the operating system. </param>
            <filterpriority>2</filterpriority>
        </member>
        <member name="T:JetBrains.TextControl.DocOffsetAndVirtual">
            <summary>
            <para>Represents the (<see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.Offset"/>) in a text <see cref="T:JetBrains.DocumentModel.IDocument">document</see>, which is basically a document offset.</para>
            <para>However, this position is often derived from a <see cref="T:JetBrains.TextControl.TextControlLineColumn"/>, which is in the text control Line-Column coordinate system, and not all column indices map into document offsets. If the column index is beyond the EOL of that line, then it's said to be in the Virtual Space. <see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.TextControlVirtualDelta"/> is the offset into the Virtual Space from the nearest valid document <see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.Offset"/>.</para>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocOffsetAndVirtual.myNeutralVirtualDelta">
            <summary>
            Number of virtual columns past the last real document position.
            Neutral means that it is equally presented in document and text control columns (<see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.TextControlVirtualDelta"/>, <see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.DocVirtualDelta"/>).
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.#ctor(JetBrains.TextControl.DocOffset,JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.TextControl.TextControlColumn})">
            <summary>
            Creates an offset that represents some point within the text control's virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.#ctor(JetBrains.TextControl.DocOffset,JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocColumn})">
            <summary>
            Creates an offset that represents some point within the text control's virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.#ctor(JetBrains.TextControl.DocOffset,System.Int32)">
            <summary>
            Creates an offset that represents some point within the text control's virtual space.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.#ctor(JetBrains.TextControl.DocOffset@)">
            <summary>
            Creates an offset that corresponds to a real document offset, without any shift to the virtual space.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocOffsetAndVirtual.DocVirtualDelta">
            <summary>
            For logical positions over actual document characters this is zero. For logical positions over the Virtual Space (column indices beyond the end of line), the number of virtual space characters from the EOL.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocOffsetAndVirtual.IsInVirtualSpace">
            <summary>
            Gets whether the point isn't over document chars, but somewhere in the virtual space of the text control.
            This means that <see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.DocVirtualDelta"/> and <see cref="P:JetBrains.TextControl.DocOffsetAndVirtual.TextControlVirtualDelta"/> are both above zero.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocOffsetAndVirtual.Offset">
            <summary>
            For logical positions over actual document characters, the <see cref="T:JetBrains.DocumentModel.IDocument">document</see> offset. For logical positions over the Virtual Space (column indices beyond the end of line), the EOL offset.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocOffsetAndVirtual.TextControlVirtualDelta">
            <summary>
            For logical positions over actual document characters this is zero. For logical positions over the Virtual Space (column indices beyond the end of line), the number of virtual space characters from the EOL.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj" /> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetAndVirtual.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#Generic#IComparer{JetBrains#TextControl#DocOffset}#Compare(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#IComparer#Compare(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#IEqualityComparer#Equals(System.Object,System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#Generic#IEqualityComparer{JetBrains#TextControl#DocOffset}#Equals(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#IEqualityComparer#GetHashCode(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetComparer.System#Collections#Generic#IEqualityComparer{JetBrains#TextControl#DocOffset}#GetHashCode(JetBrains.TextControl.DocOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.ContainsOrTouches(JetBrains.Util.TextRange,JetBrains.TextControl.DocOffset)">
            <inheritdoc cref="M:JetBrains.Util.TextRange.Contains(System.Int32)"/>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.ContainsCharIndex(JetBrains.Util.TextRange,JetBrains.TextControl.DocOffset)">
            <inheritdoc cref="M:JetBrains.Util.TextRange.ContainsCharIndex(System.Int32)"/>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.GetCoordsByOffset(JetBrains.DocumentModel.IDocument,JetBrains.TextControl.DocOffset)">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.GetCoordsByOffset(System.Int32)" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.GetDocOffsetByCoords(JetBrains.DocumentModel.IDocument,JetBrains.DocumentModel.DocumentCoords)">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.GetOffsetByCoords(JetBrains.DocumentModel.DocumentCoords)" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.GetLineEndDocOffsetNoLineBreak(JetBrains.DocumentModel.IDocument,JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.GetLineEndOffsetNoLineBreak(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.GetLineEndDocOffsetWithLineBreak(JetBrains.DocumentModel.IDocument,JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.GetLineEndOffsetWithLineBreak(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.GetLineStartDocOffset(JetBrains.DocumentModel.IDocument,JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.GetLineStartOffset(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.DocumentModel.DocLine})" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.InsertText(JetBrains.DocumentModel.IDocument,JetBrains.TextControl.DocOffset,System.String)">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.InsertText(System.Int32,System.String)" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.InsertText(JetBrains.DocumentModel.IDocument,JetBrains.TextControl.DocOffset,System.String,JetBrains.DocumentModel.TextModificationSide)">
            <inheritdoc cref="M:JetBrains.DocumentModel.IDocument.InsertText(System.Int32,System.String,JetBrains.DocumentModel.TextModificationSide)" />
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.RangeNormalized(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)">
            <summary>
            Makes a normalized range, meaning it will always go forward and have a nonnegative length, but its ends might be flipped. <see cref="M:JetBrains.TextControl.DocOffsetEx.RangeTo(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.RangeOfLength(JetBrains.TextControl.DocOffset,System.Int32)">
            <summary>
            Makes an unnormalized range, meaning it might be going backwards if <paramref name="length" /> is less than <c>0</c>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocOffsetEx.RangeTo(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)">
            <summary>
            Makes an unnormalized range, meaning it might be going backwards if <paramref name="end" /> is less than <see cref="!:start" />. See <see cref="M:JetBrains.TextControl.DocOffsetEx.RangeNormalized(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocOffset)" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.AnonymousDocumentMarkupEventsSink.JetBrains#TextControl#DocumentMarkup#IDocumentMarkupEvents#OnDocumentMarkupChanged(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup,System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter},System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter},System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.AnonymousDocumentMarkupEventsSink.JetBrains#TextControl#DocumentMarkup#IDocumentMarkupEvents#OnDocumentMarkupReset(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager">
            <summary>
            Document markup factory.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager.GetMarkupModel(JetBrains.DocumentModel.IDocument)">
            <summary>
            Get or create a document markup model.
            <para>If markup has not been created yet or garbage collected, a new markup will be created.
            Note: If markup was garbage collected and then recreated, the <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents.OnDocumentMarkupReset(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup)"/> will be called.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager.TryGetMarkupModel(JetBrains.DocumentModel.IDocument)">
            <summary>
            Try to get a document markup model. 
            If markup has not been created yet or garbage collected, the return value is null.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager.GetMarkupModelAndKeepAlive(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)">
            <summary>
            Get or create a document markup model and keep it alive (protect from garbage collection) for the given lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager.AdviseMarkupEvents(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument,JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents)">
            <summary>
            Subscribe to document markup events.
            <para>Note: That doesn't create a markup for the document nor protect an existing markup from garbage collection (see <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents.OnDocumentMarkupReset(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup)"/>).</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents">
            <summary>
            Implements methods that fire in response to changes to document markup model.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents.OnDocumentMarkupChanged(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup,System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter},System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter},System.Collections.Generic.ICollection{JetBrains.TextControl.DocumentMarkup.IHighlighter})">
            <summary>
            Document markup is changed.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupEvents.OnDocumentMarkupReset(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup)">
            <summary>
            Document markup for the document is recreated because the previous one was garbage collected.
            </summary>
            <param name="newMarkup">The new markup model (the previous one is not available).</param>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes">
            <summary>
            On an <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighter" /> instance, describes if/how to paint a marker on the Error Stripe.
            For registered highlighters, derived from <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.#ctor(JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind,System.String)">
            <summary>
              <inheritdoc cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes" />
            </summary>
            <param name="kind"><inheritdoc cref="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.MarkerKind" /></param>
            <param name="idErrorStripeColorHighlighterAttribute"><inheritdoc cref="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.ErrorStripeColorHighlighterAttributeId" /></param>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.ErrorStripeColorHighlighterAttributeId">
            <summary>
              <para>If this highlighter, when applied to a document, is to be shown on the error stripe, defines the ID of another <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute" /> whose foreground color gives the error stripe mark color.</para>
              <para>When not set, a <c>NULL</c> is used here (and never an empty string).</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.ErrorStripeColorHighlighterAttributeIdHash">
            <inheritdoc cref="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.ErrorStripeColorHighlighterAttributeId"/>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.MarkerKind">
            <summary>
            Default value if not <see cref="P:JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes.IsShowingMarkerOnErrorStripe" />, otherwise the (possibly still default) marker kind.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories">
            <summary>
            Groups of <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.Info">
            <summary>
            <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Info" /> markers only.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.CodeAnalysis">
            <summary>
            <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Error" />, <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Warning" />, <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Suggestion" />. Just common markers.
            Errors and warnings and suggestions from the Daemon.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.Usage">
            <summary>
            <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Usage" /> markers only.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.Any">
            <summary>
            Any <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind" />.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind">
            <summary>
            The sort of a marker this highlighter makes on the Error Stripe (“Marker Bar”).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Info">
            <summary>
            A common marker which is not from code analysis (Daemon) and not a highlighted usage.
            Example: T O D O item. Your custom markers probably go here.
            Lowest priority of the mall.
            <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories" />: <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.Info" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Suggestion">
            <summary>
            A code analysis (Daemon) marker which is not an error nor a warning, but still important enough to be shown on the Error Stripe as a marker and navigated to. Usually, a suggestion.
            Lowest priority of the Daemon markers.
            <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories" />: <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.CodeAnalysis" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Warning">
            <summary>
            A warning-level code analysis (Daemon) marker.
            Wins over suggestion, loses to error.
            <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories" />: <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.CodeAnalysis" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Error">
            <summary>
            An error-level code analysis (Daemon) marker.
            Wins over suggestion and warning.
            <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories" />: <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.CodeAnalysis" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Usage">
            <summary>
            A highlight-usages marker. When present, has the highest priority because it's context-specific.
            However, an error stripe can split a marker into two sub-parts to simultaneously display a usage marker and a code analysis marker.
            <see cref="T:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories" />: <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerCategories.Usage" />.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers">
            <summary>
            Common helpers for all impls, including protocol-based, which means it's not UI-Interactive-bound.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult">
            <summary>
            A non-UI-interactive clone of the interactive struct.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.FOnMouseClick">
            <summary>
            After handling mouse down, tells how the corresponding click event should be handled.
            <c>NULL</c>: not interested in click. The capture and wait for mouse up scaffolding is not initiated. Either you don't want to handle mouse at this time, or maybe you've opened a drop-down and took the capture for it.
            Non-<c>NULL</c>: interested in getting click. Mouse will be captured and tracked for clicks. The callback will be executed when it's a mouse click. If mouse is released without a valid click, this will be silently dropped without being called.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.IsReportHandled">
            <summary>
            If this result is returned synchronously, then this goes to <see cref="P:System.Windows.RoutedEventArgs.Handled" />.
            If not ready synchronously, then <c>True</c> is assumed, and then the value is ignored.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.DontNeedClick">
            <summary>
            Assume handled, but do not need the click.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.WaitingForClick(JetBrains.TextControl.DocumentMarkup.GutterMarkBackendHelpers.GutterMarkMouseDownResult.OnMouseClickHandler)">
            <summary>
            Waiting for click, assumes handled.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarkMenuLayouter">
            <summary>
            A factory for the gutter mark menu layouters.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarkMenuLayouter.GetPopupWindowContextForWhateverSomething">
            <summary>
            Creates a popup window context with a layouter for the gutter mark menu.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarkMenuLayouter.GetPopupWindowContextForWhateverSomethingCore">
            <summary>
            Creates a popup window context with a layouter for the gutter mark menu.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarksBackendServices">
            <summary>
            Runs on backend text control side, provides backend services for Jet Action Margin to run on the front.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksBackendServices.FallbackIcon">
            <summary>
            When smth is broken and we can't get a valid icon.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarksBackendServices.GetBestGutterMarkIcon(JetBrains.Util.dataStructures.FrugalLocalList{JetBrains.TextControl.DocumentMarkup.IHighlighter}@,JetBrains.Util.ILogger)">
            <summary>
            For a set of highlighters which have gutter mark infos contributing to a gutter mark on the same line, chooses the best single icon to show as a gutter mark icon.
            On problems, reports an error and fallbacks to just a bulb.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport">
            <summary>
            Transport for the gutter marks logic over the text control, serving both IDE Glyph Margin and Jet Action Margin, placed in <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.PropertyBag" /> by backend when ready to serve.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.PropertyBagId">
            <summary>
            Text control transport has a bag for per-text-control extensions, like this class, and that's the ID for putting this class in the bag.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.BwdGetTooltip">
            <summary>
            The tooltip manager wants a tooltip on front end, a request goes backwards to calculate text for the tooltip.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.BwdGutterMarksInLinesSessions">
            <summary>
            A list of request-response sessions for getting gutter marks in specific text view lines layout, kept by independent clients.
            Normally, should be only one session per text control, but as formally one can be from Jet Action Margin and one from VS Glyph Margin, let them be independent to avoid crosstalk.
            Created by frontend when it has a new view of either kind which needs gutter marks.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.BwdOnMouseDown">
            <summary>
            Mouse down on front, asked backward to do something (like show drop down menu on mousedown), or tell it needs a click.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.FwdTmpTryGetGutterMarkPopupWindowContext">
            <summary>
            Query popup over gutter mark of whatever kind.
            // TODO: when we think up a transport for popup window contexts, this could just originate on backend, and be attached to the context correctly on frontend
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.IsJetActionMarginMode">
            <summary>
            When <c>True</c>, gutter marks are only put on the Jet Action Margin. IDE Glyph Margin is kept clean..
            When <c>False</c>, gutter marks are only put on the IDE Glyph Margin, and the Jet Action Margin is hidden.
            Applies mainly to VS.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession">
            <inheritdoc cref="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.BwdGutterMarksInLinesSessions" />
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession.BwdLinesRequest">
            <summary>
            Most recent request for info on lines, sent to backend. The response (directed forward) is expected in <see cref="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession.FwdGlyphsInLinesResponse" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession.FwdGlyphsInLinesResponse">
            <summary>
            Last response to some <see cref="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.GutterMarksInLinesSession.BwdLinesRequest" />, maybe to some prev value in that prop.
            Must be sorted by start offset in text view coordinates (line identity).
            The view is designed to use an older value when the latest one is not available yet, so this isn't a problem if the response here is not for the freshest request, provided that a response to the fresh request is given later. The view will paint with previous info in the period.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.LineGlyphInfo.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.LineRequestOption">
            <summary>
            Custom option that can be passed to backend along with <see cref="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.LineRequest" />.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.MouseDownRequest">
            <summary>
            </summary>
            <param name="DocumentRanges">Doc ranges covered by clicked glyph position.</param>
            <param name="GlyphIcon">Actual displayed icon which were clicked, to show as menu title.</param>
            <param name="TmpPopupWindowContext">TODO: transport popup window contexts correctly. Front knows how to show the menu correctly, and should provide context here.</param>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.MouseDownRequest.#ctor(System.Collections.Immutable.ImmutableArray{JetBrains.Util.TextRange},JetBrains.Application.Changes.ModificationStamp,JetBrains.UI.Icons.IconId,JetBrains.Platform.RdFramework.Reflection.RdReflectInProcessBlackBox{JetBrains.Application.UI.PopupLayout.PopupWindowContextSource})">
            <summary>
            </summary>
            <param name="DocumentRanges">Doc ranges covered by clicked glyph position.</param>
            <param name="GlyphIcon">Actual displayed icon which were clicked, to show as menu title.</param>
            <param name="TmpPopupWindowContext">TODO: transport popup window contexts correctly. Front knows how to show the menu correctly, and should provide context here.</param>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.MouseDownRequest.DocumentRanges">
            <summary>Doc ranges covered by clicked glyph position.</summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.MouseDownRequest.GlyphIcon">
            <summary>Actual displayed icon which were clicked, to show as menu title.</summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.MouseDownRequest.TmpPopupWindowContext">
            <summary>TODO: transport popup window contexts correctly. Front knows how to show the menu correctly, and should provide context here.</summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.TooltipResponse.ToString">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.VisualLineIdentity.VisualBufferSnapshotVersion">
            <summary>
            Indicates if outdated. Visual buffer snapshot (in which the range is taken) version number.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.VisualLineIdentity.VisualBufferRangeNoLineBreak">
            <summary>
            Range in the specific version of the visual text buffer of the text view.
            Not incl line break.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.GutterMarksTransport.VisualLineIdentity.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IconGutterMarkInfo">
            <summary>
            Takes from <see cref="T:JetBrains.TextControl.DocumentMarkup.IconGutterMarkType" /> (that's one-for-all-of-this-kind, so common props) and <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighter" /> (that's a specific instance, so what's instance-specific).
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IconGutterMarkType">
            <summary>
            Base class for gutter marks of a type which looks like an icon and is created over a highlighter.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IconGutterMarkType.Priority">
            <summary>
            For an icon-based gutter mark, makes its <see cref="P:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.Priority" />.
            </summary>
            <inheritdoc cref="P:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.Priority" />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo">
            <inheritdoc cref="T:JetBrains.TextControl.DocumentMarkup.IGutterMarkType" />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.IconId">
            <summary>
            Icon to display on gutter.
            If the implementation is based on menu items, it should elect the best icon here.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.Priority">
            <summary>
            If more than one gutter mark icon lays up claim on the same text view line, this is used to determine whose icon wins and is actually displayed.
            The other icons won't be immediately visible. <c>NULL</c> means lowest priority.
            Note that this priority only affects choosing which icon to show if there're multiple candidates, but does not affect sorting of menu items yielded by <see cref="M:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.GetBulbMenuItems" /> when displaying a menu, those items got their own anchors.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.RichText">
            <summary>
            Tooltip for the gutter mark icon.
            If the implementation is based on menu items, it should elect relevant text here.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo.GetBulbMenuItems">
            <summary>
            Fills in the bulb menu items when opening a menu on the gutter mark. A <c>NULL</c> or empty list means there will be a gutter mark with a tooltip, but no clickable actions on it.
            If more than one gutter mark sits on the same text view line, their actions are combined on the menu; those with no actions are not represented on the menu.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IGutterMarkType">
            <summary>
              <para>A gutter mark is rendered to the left of the text view line and displays information such as base/drived types, unit testing glyph, etc.</para>
              <para>Instances of <see cref="T:JetBrains.TextControl.DocumentMarkup.IGutterMarkType" /> are defined per kind of similar gutter marks, not per gutter mark instance.</para>
              <para>A specific gutter mark instance is made by creating a <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighter">highlighter</see> in the <see cref="T:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup">markup model</see>, and is represented by an <see cref="T:JetBrains.TextControl.DocumentMarkup.IGutterMarkInfo" /> description of a gutter mark obtained from <see cref="M:JetBrains.TextControl.DocumentMarkup.IGutterMarkType.GetGutterMarkInfo(JetBrains.TextControl.DocumentMarkup.IHighlighter)" /> for that specific highlighter.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IGutterMarkType.GetGutterMarkInfo(JetBrains.TextControl.DocumentMarkup.IHighlighter)">
            <summary>
            Default info that is used is no specific 'IGutterMarkInfo' is passed. Should be not-null for daemon marks.
            </summary>
            <param name="highlighter"></param>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsBackendServices">
            <summary>
            Runs on backend text control side, provides backend services for those highlighters that paint on adornment layers on the front and do classification tagging.
            These two are currently combined because they have similar behavior for processing.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport">
            <summary>
            NOTE: blittable, serializers not required.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport.CompareTo(JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport.Equals(JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.HighlighterTransport.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.Session">
            <summary>
            Keeps the connected ranges-highlighters sets independent, in case there're multiple players.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.Session.BwdRanges">
            <summary>
            Ranges for which highlighters are needed on front, filled by front based on the current viewport.
            Must be sorted. Must not overlap.
            NOTE: why set: we probably want to exclude massive collapsed regions. // TODO: really exclude
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterAdornmentsAndClassificationsTransport.Session.FwdHighlighters">
            <summary>
            The highlighters collected by back, for rendering on front.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterBackendServicesHelper.SetupTransportForHighlighters``2(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.PropertyId{``0},System.Collections.Generic.ISet{JetBrains.TextControl.DocumentMarkup.EffectType},JetBrains.TextControl.DocumentMarkup.HighlighterBackendServicesHelper.GetSessionsForTransportContainerDelegate{``0,``1},System.TimeSpan,JetBrains.TextControl.TextControlsManagement.RunningTextControls,JetBrains.TextControl.DocumentMarkup.IDocumentMarkupManager,JetBrains.Application.Components.ILazyComponent{JetBrains.DocumentModel.DocumentSyncMomentStatusManager},JetBrains.Application.Threading.IShellLocks,JetBrains.Util.ILogger)">
            <summary>
            For various highlighter-based transports, helps with pumping highlighters into the transport.
            </summary>
            <typeparam name="TTransportContainer">Transport model.</typeparam>
            <typeparam name="TTransportItem">A type which represents a highlighter in the transport model.</typeparam>
            <param name="lifetime"></param>
            <param name="propidContainer">ID in the prop bag of the text control to fetch the <typeparamref name="TTransportContainer.." /></param>
            <param name="effecttype">Filter by effect type.</param>
            <param name="FGetSessionsForTransportContainer">When got a transport container instance and it's time to bind operations.</param>
            <param name="timeRefresh">Grouping interval.</param>
            <param name="textcontrols">Component.</param>
            <param name="markupman">Component.</param>
            <param name="docsync">Component.</param>
            <param name="locks">Component.</param>
            <param name="logger">Component.</param>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKinds">
            <summary>
            Tells how many highlighters of each kind are currently in a text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKinds.ToString">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponent.myPerTextControlData">
            <summary>
            Live-tracking data for text controls, after it has been apprehended on the main thread.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponent.FromTextControl(JetBrains.TextControl.ITextControl)">
            <summary>
            Lifetiming: text control MUST be alive at the call moment, the property will remain live until its text control destroyed.
            Highlighters get dropped for a text control if it's inactive for some time, then the property resumes tracking them if resurrected.
            Threading: can only get under a guard, because accessing highlighters is now only possible on the main thread. You can then read counters on any thread.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponent.StartTracking(JetBrains.TextControl.ITextControl)">
            <summary>
            Runs guarded. No locking needed for accessing data.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponentEx.GetHighlighterCountsByKinds(JetBrains.TextControl.ITextControl,JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponent)">
            <inheritdoc cref="M:JetBrains.TextControl.DocumentMarkup.HighlighterCountsByKindsTrackerComponent.FromTextControl(JetBrains.TextControl.ITextControl)" />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot`1">
            <summary>
            A set of highlighters with a snapshot of their positions for a certain document revision.
            A typed wrapper which has structural (deep) equality.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot`1.#ctor(System.Collections.Immutable.ImmutableArray{`0},JetBrains.Application.Changes.ModificationStamp)">
            <summary>
            A set of highlighters with a snapshot of their positions for a certain document revision.
            A typed wrapper which has structural (deep) equality.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot`1.Equals(JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlightersSnapshot`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.AnonymousHighlighterTooltipProvider.JetBrains#TextControl#DocumentMarkup#IHighlighterTooltipProvider#TryGetTooltip(JetBrains.TextControl.DocumentMarkup.IHighlighter,JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.AnonymousHighlighterTooltipProvider.HighlighterTooltipProviderDelegate">
            <inheritdoc cref="M:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider.TryGetTooltip(JetBrains.TextControl.DocumentMarkup.IHighlighter,JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)" />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.CustomizedHighlighterAttributes">
            <summary>
            Very similar to <see cref="T:JetBrains.TextControl.DocumentMarkup.HighlighterAttributes"/> but with all the user customizations in the current IDE taken into account.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority">
            <summary>
            Used in Rider Settings to indicate in which order a settings tab or panel must be shown in the UI.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.GENERAL_SETTINGS">
            General settings (topmost)
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.COMMON_SETTINGS">
            Any generic settings normally used by multiple languages.
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.CODE_SETTINGS">
            Code arrangement settings like imports, etc.
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.KEY_LANGUAGE_SETTINGS">
            Key IDE language priority (depends on product), for example, Java for IntelliJ IDEA, PHP for PhpStorm etc.
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.LANGUAGE_SETTINGS">
            Language-specific settings.
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.OTHER_SETTINGS">
            Any other settings.
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.HIDDEN_SETTINGS">
            Highlighters not included into settings UI, but can appear in the editor
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.RIDER_UNSUPPORTED">
            Highlighters which irrelevant for Rider, and can't appear in the product under any circumstances
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IRiderHighlighterNamesProvider.GetHighlighterTag(System.String)">
            <summary>
            Shortened version of attribute id which is also a valid identifier
            </summary>
            <param name="attributeId">A unique identifier used for highlighter registration</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IRiderHighlighterNamesProvider.GetPresentableName(System.String)">
            <summary>
            String shown in Rider's color scheme settings page if <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.RiderPresentableName"/>
            is not specified.
            </summary>
            <param name="attributeId">A unique identifier used for highlighter registration</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IRiderHighlighterNamesProvider.GetExternalName(System.String)">
            <summary>
            String used to store highlighters in IDEA settings and as external name in IDEA TextAttributeKey
            </summary>
            <param name="attributeId"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute">
            <summary>
            [Rider specific]
            Attribute for registering a highlighter group.
            HighlighterGroup is located in a separate settings page which resides in Settings | Editor | Colors &amp; Fonts.
            Also attribute allows to define custom rules for generation tags and presentable names (used in color schemes, settings, and dumps)
            If the level of extensibility is not enough for your needs
            set Priority to <see cref="F:JetBrains.TextControl.DocumentMarkup.HighlighterGroupPriority.HIDDEN_SETTINGS"/>
            and use com.intellij.openapi.options.colors.ColorSettingsPage in the frontend part of the plugin
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.GroupId">
            <summary>
            Unique string identifier of the HighlighterGroup, a highlighter refers a group it belongs to by this id. see <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.GroupId"/> 
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.Language">
            <summary>
            Optional value with a type of the language the highlighter group is associated with
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.PresentableName">
            <summary>
            Returns the title of the settings page created for a group.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.Priority">
            <summary>
            Priority of the settings page defined by HighlighterGroup
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.DemoText">
            <summary>
            Returns the text shown in the preview pane.
            If the value is null then the default demo text generation is applied.
            Format:
            If some elements need to be highlighted in the preview text they need to be surrounded by XML-like tags. 
            <example>
            &lt;keyword&gt;string&lt;/keyword&gt;.&lt;method&gt;Format&lt;/method&gt;
            (&lt;string&gt;"arg1:&lt;FORMAT_STRING_ITEM&gt;{0}&lt;/FORMAT_STRING_ITEM&gt;"&lt;/string&gt;, x)</example>
            <br/> The mapping between the names of the tags and the text attribute keys used for highlighting
            is defined by the <see cref="M:JetBrains.TextControl.DocumentMarkup.IRiderHighlighterNamesProvider.GetHighlighterTag(System.String)" />.
            <returns> The text to show in the preview pane </returns>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.RiderNamesProviderType">
            <summary>
            Returns the type of the <see cref="T:JetBrains.TextControl.DocumentMarkup.IRiderHighlighterNamesProvider"/> used by a group to get all strings associated with highlighters from the group 
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterAttributeIdHash">
            <summary>
            Defines the identity hash function for attribute IDs which are passed thru transport.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterCustomization">
            <summary>
            Default implementation which returns the predefined values AS IS.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterCustomization.HighlightingAttributeRegistry">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterCustomization.ApplyIdeCustomizations(JetBrains.TextControl.DocumentMarkup.HighlighterAttributes,System.String)">
            <summary>
            Override this in implementations to apply customizations.
            </summary>
            <param name="sample">The predefined highlighter attributes (either retrieved from the live instance of a highlighter on a document, or from the registration attribute).</param>
            <param name="registeredHighlighterAttributeId">ID of the registration attribute. This is the identity by which you could query for the customizations in the current IDE.</param>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterFontsAndColorsCache.GetTextStyle(System.String)">
            <summary>
            Returns <see cref="T:JetBrains.UI.RichText.TextStyle"/> built from the font and colors set for specified highlighter attribute id. <see cref="P:JetBrains.UI.RichText.TextStyle.Default"/> is nothing set.
            If data is missing and the method is from the UI thread it will synchronously fetch the data from provider, in case of background thread it will schedule sync. 
            </summary>
            <param name="highlighterAttributeId">Highlighter attribute id</param>
            <returns>TextStyle by font and colors or <see cref="P:JetBrains.UI.RichText.TextStyle.Default"/></returns>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterLayer">
            <summary>
            Values for <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.Layer"/>, <see cref="P:JetBrains.TextControl.DocumentMarkup.HighlightingAttributeRegistry.HighlighterData.Layer"/>.
            Defines priorities for highlighters against other highlighters, but in a tricky fashion.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker">
            <summary>
            Default implementation which is backed by a range marker.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.RangeMarker">
            <summary>
            Tracks the range of this highlighter in the document.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#AreaType">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#AttributeId">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#Attributes">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#Data#IRangeable#Document">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#ErrorStripeAttributes">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#GutterMarkType">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#IntraTextAdornmentDataModel">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#Data#IRangeable#IsValid">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#Key">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#Layer">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#Data#IRangeable#Range">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#TryGetTooltip(JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.HighlighterOnRangeMarker.JetBrains#TextControl#DocumentMarkup#IHighlighter#UserData">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind.TextEditor">
            <summary>
            A tooltip on a highlighter over a text range in a text editor.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind.ErrorStripe">
            <summary>
            A tooltip on an error stripe mark representing a highlighter.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind.StatusBar">
            <summary>
            Text to be shown in the IDE status bar (if the highlighter is severe enough, and we decide to put its text to the Status Bar Messenger).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind.GutterMark">
            <summary>
            A tooltip over a glyph on a gutter margin of some sort, if a highlighter produces a gutter mark, and also might get into a bulb menu item when gutter marks are included with the bulb menu.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind.QuickDoc">
            <summary>
            A tooltip dumped directly into a quickdoc
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.HighlightInfo">
            <summary>
            Class for carrying information which can be used for passing needed data to <see cref="T:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup"/>
            when creating a new <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighter"/>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes">
            <summary>
            Gets the highlighter attributes, as defined by the highlighter registration.
            NO user customizations are reflected here. Use <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization"/> to take user customizations into account.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Layer">
            <seealso cref="T:JetBrains.TextControl.DocumentMarkup.HighlighterLayer"/>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlighter.TryGetTooltip(JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <summary>
            Gets a tooltip for the highlighter.
            <c>NULL</c> if a tooltip of this kind should not be shown.
            </summary>
            <param name="where">Where this tooltip is intended to be shown. Generally, a tooltip provider does not care and would just return a tooltip, ignoring this value.</param>
            <returns>The tooltip rich text, or <c>NULL</c> if the tooltip of this kind does not need to be shown.</returns>
            <seealso cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider"/>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization">
            <summary>
            Gets highlighter attributes, much like <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes" /> but with all the user customizations in the current IDE taken into account.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization.HighlightingAttributeRegistry">
            <summary>
            Exposes the registry for highlighting attributes which lists registered highlighter attribute IDs, as operated by <see cref="M:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization.GetCustomizedHighlighterAttributes(JetBrains.TextControl.DocumentMarkup.IHighlighter)" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization.GetCustomizedHighlighterAttributes(JetBrains.TextControl.DocumentMarkup.IHighlighter)">
            <summary>
              <para>Gets highlighter attributes, much like <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes" /> but with all the user customizations in the current IDE taken into account.</para>
              <para>Threading limitations may apply, as per the current IDE environment.</para>
              <para>This overload uses an instance of a highlighter over a document.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization.GetCustomizedRegisteredHighlighterAttributes(System.String)">
            <summary>
            Gets highlighter attributes, much like <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes" /> but with all the user customizations in the current IDE taken into account.
            Threading limitations may apply, as per the current IDE environment.
            <para>This overload uses the attribute id from a <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute" /> without an actual created highlighter instance.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlighterCustomizationEx.GetCustomizedRegisteredHighlighterAttributes(JetBrains.TextControl.DocumentMarkup.IHighlighterCustomization,JetBrains.Util.Maths.OWORD)">
            <summary>
            Gets highlighter attributes, much like <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes" /> but with all the user customizations in the current IDE taken into account.
            Threading limitations may apply, as per the current IDE environment.
            <para>This overload uses the attribute id from a <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute" /> without an actual created highlighter instance, as a string source hash.</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider">
            <summary>
            Backs the logic for <see cref="M:JetBrains.TextControl.DocumentMarkup.IHighlighter.TryGetTooltip(JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)" /> in a <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighter">highlighter</see>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider.TryGetTooltip(JetBrains.TextControl.DocumentMarkup.IHighlighter,JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <summary>
            Gets a tooltip for the highlighter.
            <c>NULL</c> if a tooltip of this kind should not be shown.
            </summary>
            <param name="highlighter">Show tooltip for this specific highlighter instance.</param>
            <param name="where">Where this tooltip is intended to be shown. Generally, a tooltip provider does not care and would just return a tooltip, ignoring this value.</param>
            <returns>The tooltip rich text, or <c>NULL</c> if the tooltip of this kind does not need to be shown.</returns>
            <seealso cref="M:JetBrains.TextControl.DocumentMarkup.IHighlighter.TryGetTooltip(JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)"/>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry.IsNotRecyclable(System.String)">
            <summary>
            If NotRecyclable is true, highlighter will be removed if its range is intersected by changes range,
            otherwise it will not be removed.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry.IsDefined(System.String)">
            <summary>
            Gets if this attr ID is known. Otherwise calling other methods would register an error.
            Ideally, this should not exist, but now the highlighter attr IDs are hard coded and they sometimes violate zoning and presence of other package considerations.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry.GetAttributeIdByHashCode(JetBrains.Util.Maths.OWORD)">
            <summary>
            Looks up the original attribute ID by its hash made with <see cref="T:JetBrains.TextControl.DocumentMarkup.HighlighterAttributeIdHash"/>.
            Throws if not found.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IHighlightingAttributeRegistry.TryGetVsBaseClassificationType(System.String)">
            <summary>
            Gets <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsBaseClassificationType" /> if available.
            </summary>
            <param name="id">An ID. Silently skips if invalid.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.Careting.IntraTextPosition">
            <summary>
            For an intra text adornment, adds its full position description (document offset before which the adorn is inserted + intra placement details between the chars).
            </summary>
            <param name="RealDocOffset"> Doc offset in some document version; the modification stamp of the document must be defined externally outside this object together with a set of adorns.</param>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.Careting.IntraTextPosition.#ctor(JetBrains.TextControl.DocOffset,JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement)">
            <summary>
            For an intra text adornment, adds its full position description (document offset before which the adorn is inserted + intra placement details between the chars).
            </summary>
            <param name="RealDocOffset"> Doc offset in some document version; the modification stamp of the document must be defined externally outside this object together with a set of adorns.</param>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.Careting.IntraTextPosition.RealDocOffset">
            <summary> Doc offset in some document version; the modification stamp of the document must be defined externally outside this object together with a set of adorns.</summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.Careting.IntraTextPosition.System#IComparable{JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#Careting#IntraTextPosition}#CompareTo(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.Careting.IntraTextPosition)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.HighlighterIntraTextAdornmentsBackendServices">
            <summary>
            Runs on backend text control side, provides backend services for those highlighters that insert intra text adornments.
            Separate from other adorns because these pass more data and they are more laggy because they rely on late daemon stages so are not as realtime as highlighters.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData">
            <summary>
            Transport model part for an intra text adornment.
            NOTE: non-blittable, contains text.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.IntraPlacement">
            <inheritdoc cref="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement" />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.CompareTo(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.Equals(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel">
            <summary>
            Default implementation with parameters and delegates. TODO: will be further reworked while protocolling.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel.JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#IIntraTextAdornmentDataModel#ContextMenuItems">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel.JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#IIntraTextAdornmentDataModel#ContextMenuTitle">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel.JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#IIntraTextAdornmentDataModel#Data">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel.JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#IIntraTextAdornmentDataModel#ExecuteNavigation(JetBrains.Application.UI.PopupLayout.PopupWindowContextSource)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentDataModel.JetBrains#TextControl#DocumentMarkup#IntraTextAdornments#IIntraTextAdornmentDataModel#SelectionRange">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentFlags">
            <summary>
            Joins together boolean props for <see cref="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentData" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentFlags.IsPreceding">
            <summary>
            TODO: to be removed from flags and fully expressed via <see cref="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement"/> (below zero / above zero).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentFlags.Transparent">
            <summary>
            Intra text adornments that should reserve space, but don't be drawn.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentFlags.Whitespace">
            <summary>
            Intra text adornments that should reserve space, and show real characters count under range.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.BwdGetTooltip">
            <summary>
            Requests tooltip for an adorn, offsets are adjusted to the current backend sync version.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.BwdOnMouseDown">
            <summary>
            Asks for a click reaction on the adornment, offsets are adjusted to the current backend sync version.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter">
            <summary>
            Transport for an individual adornment highlighter (data + range).
            NOTE: non-blittable, contains text in Data.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.AttributeIdHash">
            <summary>
            For all adorns: background color.
            For adorns with text: text foreground color.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.Position">
            <summary>
            Doc offset in some document version; the modification stamp of the document must be defined externally outside this object together with a set of adorns.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.CompareTo(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.Equals(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.AdornmentHighlighter.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.Session">
            <summary>
            Keeps the connected ranges-highlighters sets independent, in case there're multiple players.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.Session.BwdIsPushToHintActive">
            <summary>
            Front tells when to send push-to-hint-only adorns for rendering.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.Session.BwdRanges">
            <summary>
            Ranges for which highlighters are needed on front, filled by front based on the current viewport.
            Must be sorted. Must not overlap.
            NOTE: why set: we probably want to exclude massive collapsed regions. // TODO: really exclude
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextAdornmentsTransport.Session.FwdAdornments">
            <summary>
            The highlighters collected by back, for rendering on front.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement">
            <summary>
              <para>For an intra-text adornment, defines its placement in between the adjacent characters.</para>
              <para>If an intra-adorn is placed on a document offset <c>N</c>, then it's laid out in between characters at offsets <c>N-1</c> and <c>N</c>, ordered by <see cref="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.Priority" /> in ascending order.</para>
              <para>There are also special anchoring effects based on <paramref name="Priority" />:</para>
              <para>When <c>&lt;0</c> — adornment is “anchored” to the <c>N-1</c>th character and prefers to stay together with it when laying out text.</para>
              <para>When <c>&gt;=0</c> — adornment is “anchored” to the <c>N</c>th character and prefers to stay together with it when laying out text.</para>
              <para>Negative zero might be treated as if it were a positive zero. Avoid using zero values here for clarity.</para>
            </summary>
            <param name="Priority"></param>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.#ctor(System.Double)">
            <summary>
              <para>For an intra-text adornment, defines its placement in between the adjacent characters.</para>
              <para>If an intra-adorn is placed on a document offset <c>N</c>, then it's laid out in between characters at offsets <c>N-1</c> and <c>N</c>, ordered by <see cref="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.Priority" /> in ascending order.</para>
              <para>There are also special anchoring effects based on <paramref name="Priority" />:</para>
              <para>When <c>&lt;0</c> — adornment is “anchored” to the <c>N-1</c>th character and prefers to stay together with it when laying out text.</para>
              <para>When <c>&gt;=0</c> — adornment is “anchored” to the <c>N</c>th character and prefers to stay together with it when laying out text.</para>
              <para>Negative zero might be treated as if it were a positive zero. Avoid using zero values here for clarity.</para>
            </summary>
            <param name="Priority"></param>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.Priority">
            <summary></summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.CompareTo(JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IntraTextPlacement.CompareTo(System.Object)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IStructuredHighlighterData">
            <summary>
            States that an object passed to <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.UserData"/> is aware about its inner structure,
            and can decide whether it's different from another one so the <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupImpl.FireHighlighterModified(JetBrains.TextControl.DocumentMarkup.IHighlighter)"/> event can be skipped.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IStructuredHighlighterData.StructureEquals(JetBrains.TextControl.DocumentMarkup.IStructuredHighlighterData)">
            <summary>
            Checks the structured equality of two highlighter data 
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.NoHighlighterTooltip">
            <summary>
            <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider">Provides</see> static-text tooltips (which never change) for a highlighter.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.NoHighlighterTooltip.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.NoHighlighterTooltip.JetBrains#TextControl#DocumentMarkup#IHighlighterTooltipProvider#TryGetTooltip(JetBrains.TextControl.DocumentMarkup.IHighlighter,JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.StaticHighlighterTooltip">
            <summary>
            <see cref="T:JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider">Provides</see> static-text tooltips (which never change) for a highlighter.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.StaticHighlighterTooltip.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.StaticHighlighterTooltip.JetBrains#TextControl#DocumentMarkup#IHighlighterTooltipProvider#TryGetTooltip(JetBrains.TextControl.DocumentMarkup.IHighlighter,JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup">
            <summary>
            Provides access to document markup.
            Read operation can be done from any thread. Write operations require Main thread. In all cases content model read lock should be held.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.Document">
            <summary>
            Gets the document highlighted by this markup.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.AddHighlighterCustom(System.String,JetBrains.Util.TextRange,JetBrains.TextControl.DocumentMarkup.AreaType,System.Nullable{JetBrains.TextControl.DocumentMarkup.HighlighterLayer},JetBrains.TextControl.DocumentMarkup.HighlighterAttributes,JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes,JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider,JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IHighlighterIntraTextAdornmentProvider,JetBrains.Util.DataStructures.UserDataWrapper)">
            <summary>
            Adds a highlighter to markup.
            Unlike <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.AddHighlighterRegistered(System.String,JetBrains.Util.TextRange,JetBrains.TextControl.DocumentMarkup.AreaType,System.Nullable{JetBrains.TextControl.DocumentMarkup.HighlighterLayer},System.String,System.Nullable{JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes},JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider,JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IHighlighterIntraTextAdornmentProvider,JetBrains.Util.DataStructures.UserDataWrapper)"/>, there's no static registration with <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute"/> to derive basic highlighter properties from, everything should be defined inplace.
            The colors won't be themed by the IDE theme.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.AddHighlighterRegistered(System.String,JetBrains.Util.TextRange,JetBrains.TextControl.DocumentMarkup.AreaType,System.Nullable{JetBrains.TextControl.DocumentMarkup.HighlighterLayer},System.String,System.Nullable{JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes},JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider,JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IHighlighterIntraTextAdornmentProvider,JetBrains.Util.DataStructures.UserDataWrapper)">
            <summary>
            Adds highlighter with attributes from HighlighterAttributeRegistry (mostly, registered statically with <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute"/>).
            Basic highlighter properties are taken from the registered highlighter, with optional overrides allowed here. (NOTE: for some of the parameters registered actually take precedence, see impl).
            highlighter colors would be themed by the IDE settings.
            To have a fully custom highlighter, see <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.AddHighlighterCustom(System.String,JetBrains.Util.TextRange,JetBrains.TextControl.DocumentMarkup.AreaType,System.Nullable{JetBrains.TextControl.DocumentMarkup.HighlighterLayer},JetBrains.TextControl.DocumentMarkup.HighlighterAttributes,JetBrains.TextControl.DocumentMarkup.ErrorStripeAttributes,JetBrains.TextControl.DocumentMarkup.IHighlighterTooltipProvider,JetBrains.TextControl.DocumentMarkup.IntraTextAdornments.IHighlighterIntraTextAdornmentProvider,JetBrains.Util.DataStructures.UserDataWrapper)"/>. 
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.GetHighlightersEnumerable(JetBrains.Util.dataStructures.OnWriteLockRequestedBehavior,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})">
            <summary>
            Returns highlighters enumerable in random order
            </summary>
            <param name="behavior">What to do if write action happens while enumeration</param>
            <param name="highlighterFilter">Optional filter to apply to the highlighters</param>
            <returns>Highlighters enumerable in random order</returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.GetHighlightersEnumerable(System.String,JetBrains.Util.dataStructures.OnWriteLockRequestedBehavior,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})">
            <summary>
            Returns enumerable of highlighters with specified <see cref="!:key"/> in random order
            </summary>
            <param name="key">Highlighter key</param>
            <param name="behavior">What to do if write action happens while enumeration</param>
            <param name="highlighterFilter">Optional filter to apply to the highlighters</param>
            <returns>Enumerable of highlighters with specified key in random order</returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.GetHighlightersOver(JetBrains.Util.TextRange,JetBrains.Util.dataStructures.OnWriteLockRequestedBehavior,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})">
            <summary>
            Returns enumerable of highlighters that intersect? with specified <see cref="!:textRange"/> in random order
            Implementation details: there is a JetHashSet underneath
            </summary>
            <param name="textRange">Range to find highlighters over</param>
            <param name="behavior">What to do if write action happens while enumeration</param>
            <param name="highlighterFilter">Optional filter to apply to the highlighters</param>
            <returns>Enumerable of highlighters over specified range in random order</returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.BatchChangeCookie(System.String)">
            <summary>
            Indicates that inside this disposable massive markup model change is expected.
            Changed event will be fired upon cookie dispose
            </summary>
            <param name="name">Name of the batch action</param>
            <returns>Disposable to terminate when batch action is done</returns>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.DocumentMarkupEx.GetFilteredHighlighters(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})">
            <summary>
            Filters document highlighters and collects them to list in random order. 
            Allocates memory unlike <see cref="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.GetHighlightersEnumerable(JetBrains.Util.dataStructures.OnWriteLockRequestedBehavior,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})"/>
            May be called from any thread. Content model read lock required.
            </summary>
            <param name="markup">Document markup</param>
            <param name="highlighterFilter">Highlighter filter</param>
            <returns>List of filtered highlighters</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.TextControl.DocumentMarkup.DocumentMarkupEx.GetFilteredHighlighters(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup,System.String,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})" -->
        <member name="M:JetBrains.TextControl.DocumentMarkup.DocumentMarkupEx.GetFilteredHighlightersOver(JetBrains.TextControl.DocumentMarkup.IDocumentMarkup,JetBrains.Util.TextRange,System.Func{JetBrains.TextControl.DocumentMarkup.IHighlighter,System.Boolean})">
            <summary>
            Filters document highlighters over specified range and collects them to list in random order.
            May be called from any thread. Content model read lock required. 
            </summary>
            <param name="markup">Document markup</param>
            <param name="textRange">Range in document</param>
            <param name="highlighterFilter">Highlighter filter</param>
            <returns>List of filtered highlighters</returns>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.DocumentMarkupManager">
            <summary>
            Standalone, VS, and base impl for markup manager.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterBase.JetBrains#TextControl#DocumentMarkup#IHighlighter#TryGetTooltip(JetBrains.TextControl.DocumentMarkup.HighlighterTooltipKind)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterBase.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlighterBase.GetLayer(JetBrains.TextControl.DocumentMarkup.IHighlighter)">
            <summary>
            TODO: expecting to switch to ordering highlighters (incl adornments) by layers, so this should decide some sane default based on the effect type for adornments, done when rendering adornments at the moment. Probably, make layer non-nullable in the API. And maybe move into highlighter-attributes (?).
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlightingAttributeRegistry.JetBrains#TextControl#DocumentMarkup#IHighlightingAttributeRegistry#IsDefined(System.String)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.HighlightingAttributeRegistry.GetAttributeIdByHashCode(JetBrains.Util.Maths.OWORD)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DocumentMarkup.IDocumentMarkupImpl.RemoveInvalidHighlighters">
            <summary>
            Explicit cleanup of highlighters that were invalidated for any reason. See RSRP-487064
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.LineMarkers.LineMarkerPosition">
            <summary>
            In Rider corresponds to com.intellij.openapi.editor.markup.LineMarkerRendererEx.Position
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.LineMarkers.ILineMarkerInfo">
             <summary>
             !!!Currently works only in Rider!!!
            
             When set to a <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.UserData"/> of a highlighter
             with <see cref="P:JetBrains.TextControl.DocumentMarkup.IHighlighter.Attributes"/> == <see cref="F:JetBrains.TextControl.DocumentMarkup.EffectType.LINE_MARKER"/>
             used as a description of how to render such a line marker
             </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.LineMarkers.ILineMarkerInfo.RendererId">
            <summary>
            Unique identifier of a renderer to be used for this particular Line Marker (
            In case of null, the default is used. 
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.LineMarkers.IActiveLineMarkerInfo">
            LineMarker which supports actions and shows tooltip on hover
            <inheritdoc cref="T:JetBrains.TextControl.DocumentMarkup.LineMarkers.ILineMarkerInfo"/>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.PaletteColorIndex">
            <summary>
            Used in high contrast mode only.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.Layer">
            <seealso cref="T:JetBrains.TextControl.DocumentMarkup.HighlighterLayer"/>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ForegroundColor">
            <summary>
            List of colors, delimited by ':'
            In case of VS2003 first COLORINDEX color will be used
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.BackgroundColor">
            <summary>
            List of colors, delimited by ':'
            In case of VS2003 first COLORINDEX color will be used
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.EffectColor">
            <summary>
            Obsolete. Use ForegroundColor, DarkForegroundColor, BackgroundColor and DarkBackgroundColor to define effect colors.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeKind">
            <summary>
              <para>A kind of the Error Stripe Marker, if this highlighter is to be shown as a marker on the error stripe when applied to a document or a text control. This is defined by <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.EffectType" /> set to <see cref="!:"/> being non-<c>NULL</c>.</para>
              <para>You may omit setting this value explicitly if the default (<see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Info" />) fits you, which is commonly OK.</para>
              <para>For a non-error-stripe highlighter, this MUST not be set to any non-default value.</para>
              <para>This value is considered on the original highlighter in the document or text control which has <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeColorHighlighterAttributeId" /> non-<c>NULL</c> and NOT on the highlighter pointed to by <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeColorHighlighterAttributeId" />.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeColorHighlighterAttributeId">
            <summary>
              <para>If this highlighter, when applied to a document or a text control, is to be shown on the error stripe, defines the ID of another <see cref="T:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute" /> whose foreground color gives the error stripe marker color.</para>
              <para><see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeKind" /> is considered on the highlighter which has a <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.ErrorStripeColorHighlighterAttributeId" />, but not on the highlighter pointed to by this ID.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.RiderPresentableName">
            <summary>
            Optional string which will be shown in a corresponding Color Scheme Page.
            Two slashes is a default IJ convention for nesting. e.g Foo//Bar, Foo//Baz will create two children under Foo
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.NotRecyclable">
            <summary>
            Property for deciding whether to delete highlighter immediately if it intersects with modified range
            or push it through highlighter-reusing-machinery (thingy which eliminates blinking).
            If the highlighter is produced by a long-running stage consider setting this to false for better UX
            ALL CARET DEPENDENT HIGHLIGHTERS MUST BE NOT RECYCLABLE!!! Crucial for Rider
            </summary>
            <remarks>
            If NotRecyclable is true, highlighter will be removed if its range is intersected by changes range,
            otherwise it will not be removed.
            </remarks>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.TransmitUpdates">
            <summary>
            [Rider specific]
            Property for deciding whether to send updates of this highlighter to the frontend.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.FallbackAttributeId">
            <summary>
            [Rider specific]
            Name of the corresponding default attributeId in R# or TextAttributesKey in IDEA platform.
            Used for keeping default IDEA's attributes hierarchy in settings for highlighter representation.
            e.g. You can configure SOME_LANGUAGE_KEYWORD highlighter color for only one particular language,
            or configure the colors for keywords in all languages by changing DEFAULT_KEYWORD.
            e.g CPP_CLASS_FIELD_ATTRIBUTE falls back to FIELD_IDENTIFIER_ATTRIBUTE
            e.g AnalysisHighlightingAttributeIds.ERROR falls back to CodeInsightColors.ERRORS_ATTRIBUTES in IDEA
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.RiderReplaceWith">
            <summary>
            [Rider specific]
            Unique id which will be used in Rider instead of one specified in <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.Id" />
            Making impossible to distinguish these highlighters.
            It's necessary for keep default IDEA's behavior (e.g. IDEA has the same Ids for errors and warnings across all languages).
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsGenerateClassificationDefinition">
            <summary>
            [VS specific]
            Generate VS ClassificationTypeDefinition and ClassificationFormatDefinition for this highlighter.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsPresentableName">
            <summary>
            [VS specific]
            Used for ClassificationFormatDefinition generation.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsBaseClassificationType">
            <summary>
            [VS specific]
            A predefined VS classification type to be used as a base type for the classification definition of this highlighter.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsUseInheritedColors" -->
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsCustomOrderAfter">
            <summary>
            [VS specific]
            Allows to define custom Order(After="..") attribute for generated VS classification format definitions.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.VsCustomOrderBefore">
            <summary>
            [VS specific]
            Allows to define custom Order(Before="..") attribute for generated VS classification format definitions.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterAttribute.GroupId">
            <summary>
            [Rider specific]
            A unique identifier corresponding to a group the highlighter belongs to
            <see cref="P:JetBrains.TextControl.DocumentMarkup.RegisterHighlighterGroupAttribute.GroupId"/>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.VisualStudio.VsCodeAnalysisClassificationTypeNames">
            <summary>
            See: Microsoft.CodeAnalysis.Classification.ClassificationTypeNames
            Assembly: Microsoft.CodeAnalysis.Workspaces, Version=4.2.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35
            C:\Program Files\Microsoft Visual Studio\2022\Professional\Common7\IDE\CommonExtensions\Microsoft\VBCSharp\LanguageServices\Core\Microsoft.CodeAnalysis.Workspaces.dll
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.DocumentMarkup.VisualStudio.VsCodeAnalysisClassificationTypeNames.AdditiveTypeNames">
            <summary>
            Additive classifications types supply additional context to other classifications.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.VisualStudio.VsPredefinedClassificationType">
            <summary>
            Predefined VS classification types.
            Type: Microsoft.VisualStudio.Language.StandardClassification.PredefinedClassificationTypeNames
            Assembly: Microsoft.VisualStudio.Language.StandardClassification, Version=10.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.DocumentMarkup.VisualStudio.VsWellKnownHighlighterAttributeIds">
            <summary>
            VS built-in highlighting IDs, or to be precise names of well-known IClassificationTypes in Visual Studio.
            </summary>
            <remarks>
            Use DumpVsTextViewClassificationTagsAction internal action to know the other ones.
            </remarks> 
        </member>
        <member name="M:JetBrains.TextControl.DummyTextControlPopupWindowContextFactory.ForBeginningOfLineCore(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.DocOffsetAndVirtual)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DummyTextControlPopupWindowContextFactory.ForCaretCore(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.DummyTextControlPopupWindowContextFactory.ForRangeCore(JetBrains.Lifetimes.Lifetime,JetBrains.Util.TextRange)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeBackendServices.GetOffsetForMarkerSlot(JetBrains.TextControl.ErrorStripe.ErrorStripeBackendServices.HighlighterExtracted@,JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.SlotsAllocation,JetBrains.DocumentModel.IDocument)">
            <summary>
            Error stripe slotting allocation places highlighters either by their exact offset or by their line number, see <see cref="T:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.SlotsAllocation" />.
            Every time you consider a highlighter offset, use this.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.ErrorStripeBackendServices.HighlighterExtracted">
            <summary>
            Extract on main thread, process on back thread.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport">
            <summary>
            Error stripe might have one or more indicators above the marker bar. Or none.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.#ctor(System.Double)">
            <param name="priority"><inheritdoc cref="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.Priority" /></param>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.BwdOnMouseLeftButtonDownOrClick">
            <summary>
            Mouse down on front, asked backward to do something (like show drop down menu on mousedown), or tell it needs a click.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.BwdOnMouseRightButtonDownOrClick">
            <summary>
            Mouse down on front, asked backward to do something (like show drop down menu on mousedown), or tell it needs a click.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.FwdTmpTryGetPopupWindowContext">
            <summary>
            // TODO: when we think up a transport for popup window contexts, this could just originate on backend, and be attached to the context correctly on frontend
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.Priority">
            <summary>
            Defines ordering for indicators on the error stripe view, in ascending order.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.PropertyBag">
            <summary>
            Bag for custom properties.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.Read(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeReader)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.Write(JetBrains.Rd.SerializationCtx,JetBrains.Serialization.UnsafeWriter,JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport)">
            <summary>
            Used by rd reflection serializers.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport.OnBindNested(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransportEx.AdviseShowContextMenu(JetBrains.TextControl.ErrorStripe.ErrorStripeIndicatorTransport,JetBrains.Lifetimes.Lifetime,JetBrains.Application.UI.ActionsRevised.Loader.IActionGroupDef,JetBrains.Application.UI.Controls.JetPopupMenu.JetPopupMenus,JetBrains.Application.Threading.IShellLocks,JetBrains.Application.UI.Actions.ActionManager.IActionManager,JetBrains.TextControl.ITextControl,JetBrains.Util.ILogger,System.Collections.Generic.IEnumerable{JetBrains.Application.DataContext.IDataRule})">
            <summary>
            On back, advises the right-mouse-or-click to show a context menu for the action group.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport">
            <seealso cref="T:JetBrains.TextControl.Transport.TransportTextControl" />
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.HasSkippedHighlighters">
            <seealso cref="P:JetBrains.TextControl.DocumentMarkup.IDocumentMarkup.HasSkippedHighlightings" />
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.LayoutSetting">
            <summary>
            <see cref="F:JetBrains.TextControl.ErrorStripe.ErrorStripeSettings.ErrorStripeLayout" /> for this error stripe.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.WidthSettings">
            <summary>
            <see cref="F:JetBrains.TextControl.ErrorStripe.ErrorStripeSettings.ErrorStripeWidth" /> for this error stripe.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.ErrorStripeKind">
            <summary>
            Kind of this marker, might be <see cref="F:JetBrains.TextControl.DocumentMarkup.ErrorStripeMarkerKind.Info" /> if this is a highligh-usages highlighter (?).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.HighlighterAttributesPrimaryId">
            <summary>
            HighlighterAttribute ID for the source of the primary color.
            As we only list existing markers (not empty marker slots), this must never be NULL or empty.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.HighlighterAttributesSecondaryId">
            <summary>
            Secondary color, if we show two colors per marker (e.g. error and usages).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.OriginalSlotFraction">
            <summary>
            The slot for which this marker has been allocated, as a fraction in the set of all slots (slot index divided by total number of slots). Keeping the fraction allows to stretch the markers more or less realistically when marker bar changes its height and before new markers have been calculated.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.TextRange">
            <summary>
            The doc range which corresponds to the slot for which the marker were created, at the moment the marker were created.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.Equals(JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.ErrorStripeMarker.ToString">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.MarkerBarTransport.BwdGetTooltip">
            <summary>
            Asks for a tooltip on the marker which were created for a slot on this text range.
            NOTE that if the marker bar view is nontransparent, it's OK to fire this event for an empty slot (or for a specific document position even).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.MarkerBarTransport.BwdOnMouseDown">
            <summary>
            Asks for a click reaction on the marker which were created for a slot on this text range.
            NOTE that if the marker bar view is nontransparent, it's OK to fire this event for an empty slot (or for a specific document position even).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.MarkerBarTransport.BwdSlots">
            <summary>
            Error stripe marker slots layout. Gives a set of document offsets which split document into slices which contribute into corresponding markers. Even if VS operates on lines (when in non-word-wrap mode), this still holds document offsets, even though rounded to line boundaries.
            Each int is the end of the slot, non-inclusively. The first slot starts at <c>0</c> (inclusively), the next slot starts (inclusively) where the prev one ends (end non-inclusively).
            Populated by frontend based on the text view buffer layout against its scrollbar, and scrollbar height.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.MarkerBarTransport.FwdMarkers">
            <summary>
            Backend analyzes highlighters in the document markup and sends which markers should be displayed on the error stripe, based on <see cref="F:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.MarkerBarTransport.BwdSlots" /> layout of the document.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.ErrorStripeTransport.SlotsAllocation">
            <summary>
            Error stripe slots correspond either to the raw offset of the character (e.g. in VS Word Wrap mode), or to line numbers (in non-wrap mode, so all stuff from one line gets into the same slot).
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.IErrorStripeAvailableLayouts">
            <summary>
            Allows environments to override how they're able to show the error stripe.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ErrorStripe.NavigateErrorStripeAction">
            <summary>
            Base action for error stripe indicators by daemon and usages.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateErrorStripeAction.JetBrains#Application#UI#ActionsRevised#Menu#IExecutableAction#Execute(JetBrains.Application.DataContext.IDataContext,JetBrains.Application.UI.Actions.DelegateExecute)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateErrorStripeAction.JetBrains#Application#UI#ActionsRevised#Menu#IExecutableAction#Update(JetBrains.Application.DataContext.IDataContext,JetBrains.Application.UI.Actions.ActionPresentation,JetBrains.Application.UI.Actions.DelegateUpdate)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToNextCodeAnalysisErrorStripeMarkerAction.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToNextHighlightingAction.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToNextUsageAction.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToPrevCodeAnalysisErrorStripeMarkerAction.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToPrevHighlightingAction.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.ErrorStripe.NavigateToPrevUsageAction.#ctor">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.ITextControl">
            <summary>
            Represents the text control, which is a view for editing an <see cref="T:JetBrains.DocumentModel.IDocument"/>.
            Most calls that modify the text control state must be made from the UI thread.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Id">
            <summary>
            Id of the text control
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Caret">
            <summary>
            Caret access.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Coords">
            <summary>
            <para>Provides access to the text control coordinate conversion, which makes it possible to represent a point on the text control or in the document in a unified way.</para>
            <para>The rendered text gets from the <see cref="P:JetBrains.TextControl.ITextControl.Document">document</see>, however, it might be transformed or filtered (eg projections and collapsed regions).</para>
            <para>That's why document line-column positions (<see cref="T:JetBrains.DocumentModel.DocumentCoords"/>) do not always agree to the text control line-column positions (<see cref="T:JetBrains.TextControl.TextControlLineColumn"/>). Currently, these coordinates have different CLR types and are not so easily mixed together.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Lifetime">
            <summary>
            Gets the Disposables collection that controls the text control lifetime.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Document">
            <summary>
            <para>Gets the document that supplies this text control with content.</para>
            <para>The rendered text gets from the document, however, it might be transformed or filtered (eg projections and collapsed regions).</para>
            <para>That's why document line-column positions (<see cref="T:JetBrains.DocumentModel.DocumentCoords"/>) do not always agree to the text control line-column positions (<see cref="T:JetBrains.TextControl.TextControlLineColumn"/>). Currently, these coordinates have different CLR types and are not so easily mixed together.</para>
            Use <see cref="P:JetBrains.TextControl.ITextControl.Coords"/> to convert between various text control coordinates.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Scrolling">
            <summary>
            Gets the scrolling parameters of the text control, both for querying and manipulating.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Selection">
            <summary>
            Selection access.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Window">
            <summary>
            Provides various UI framework-related information about the <see cref="T:JetBrains.TextControl.ITextControl">text control</see>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.ErrorStripe">
            <summary>
            The Errors Stripe, aka Marker Bar — a margin to the right of the text control which shows the markers for errors and warnings alongside the scroll bar.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControl.Transport">
            <summary>
            The bindable data model of the text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControl.EmulateAction(System.String)">
            <summary>
            Emulates executing an action from <see cref="T:JetBrains.Application.UI.ActionSystem.Text.TextControlActions"/> in the text control, for example, pressing the Enter key in text control as if by the user. Will cause our and host handlers to be executed. The handler will be executed in a reentrancy-safe context.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControl.EmulateTyping(System.Char)">
            <summary>
            Emulates typing in text control. Will cause our and host handlers to be executed. The handler will be executed in a reentrancy-safe context.
            </summary>
            <param name="c">The character to emulate typing of.</param>
        </member>
        <member name="M:JetBrains.TextControl.ITextControl.IsPositionInTextView(JetBrains.TextControl.Coords.ITextControlPos)">
            <summary>
            Gets whether the given document position is present in the text view of the text control.
            </summary>
            <param name="position">The document position in the unified position format (<see cref="P:JetBrains.TextControl.ITextControl.Coords"/>.<see cref="M:JetBrains.TextControl.Coords.ITextControlCoords.FromDocOffset(JetBrains.TextControl.DocOffset)"/> or <see cref="P:JetBrains.TextControl.ITextControl.Coords"/>.<see cref="M:JetBrains.TextControl.Coords.ITextControlCoords.FromDocLineColumn(JetBrains.DocumentModel.DocumentCoords)"/>).</param>
            <remarks>Even though every position could be converted to a text view (and usually a reasonable value will be returned), sometimes that would be only an approximate position (that would not roundtrip). For example, a document position could be hidden from the text view by a collapsed region.</remarks>
        </member>
        <member name="T:JetBrains.TextControl.ITextControlCaret">
            <summary>
            Text control caret access.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlCaret.Position">
            <summary>
            Gets the caret position in all of the possible text control position representation.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlCaret.TextControl">
            <summary>
            Gets the owning text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlCaret.MoveTo(JetBrains.TextControl.Coords.ITextControlPos,JetBrains.TextControl.CaretVisualPlacement)">
            <summary>
            Attempts to move the caret to the requested position.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlCaret.EnsureVisible">
            <summary>
            Makes the caret visible by scrolling the view up or down and left or right until the caret is visible.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ITextControlManager">
            <summary>
            Manages the text controls throughout the application.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.CurrentFrameTextControlPerClient">
            <summary>
            <para>Gets the text control that most recently had the keyboard focus, unless that text control has been destroyed or we have left the window frame that holds the text control. May be <c>Null</c>. Changes are guarded.</para>
            <para>Note that, unlike <see cref="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControl"/>, this property resets to <c>Null</c> when the focus wanders off to some tool window or another frame of such a kind.</para>
            <para>Use <see cref="M:JetBrains.TextControl.CodeWithMe.TextControlClientIdExtensions.ForCurrentClient(JetBrains.DataFlow.IDictionaryEvents{JetBrains.Rd.ClientId,JetBrains.TextControl.ITextControl})"/> to get a value for current client</para>
            </summary>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.FocusedTextControl"/>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControl"/>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.CurrentFrameTextControl">
            <summary>
            <inheritdoc cref="P:JetBrains.TextControl.ITextControlManager.CurrentFrameTextControlPerClient"/>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.FocusedTextControlPerClient">
            <summary>
            Gets the text control that currently has the keyboard focus. May be <c>Null</c>. Changes are guarded.
            <para>Use <see cref="M:JetBrains.TextControl.CodeWithMe.TextControlClientIdExtensions.ForCurrentClient(JetBrains.DataFlow.IDictionaryEvents{JetBrains.Rd.ClientId,JetBrains.TextControl.ITextControl})"/> to get a value for current client</para>
            </summary>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControl"/>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.CurrentFrameTextControl"/>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.FocusedTextControl">
            <summary>
            <inheritdoc cref="P:JetBrains.TextControl.ITextControlManager.FocusedTextControlPerClient"/>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControlPerClient">
            <summary>
            <para>Gets the text control that most recently had the keyboard focus, unless that text control has been destroyed. May be <c>Null</c>. Changes are guarded.</para>
            <para>Note that this property does not lose its value if focus wanders off to some tool window or another frame of such a kind.</para>
            <para>Use <see cref="M:JetBrains.TextControl.CodeWithMe.TextControlClientIdExtensions.ForCurrentClient(JetBrains.DataFlow.IDictionaryEvents{JetBrains.Rd.ClientId,JetBrains.TextControl.ITextControl})"/> to get a value for current client</para>
            </summary>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.FocusedTextControl"/>
            <seealso cref="P:JetBrains.TextControl.ITextControlManager.CurrentFrameTextControl"/>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControl">
            <summary>
            <inheritdoc cref="P:JetBrains.TextControl.ITextControlManager.LastFocusedTextControlPerClient"/>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.Legacy">
            <summary>
            Legacy wrappers to expose the collections and property changes as raw CLR events.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.TextControls">
            <summary>
            <para>Gets the list of all the text controls that currently exist.</para>
            <para>Could be modified on the primary thread in the guarded context only.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.TransportTextControls">
            <inheritdoc cref="F:JetBrains.TextControl.TextControlsManagement.RunningTextControls.TransportTextControls" />
        </member>
        <member name="P:JetBrains.TextControl.ITextControlManager.VisibleTextControls">
            <summary>
            <para>Tracks the list of <see cref="P:JetBrains.TextControl.ITextControlManager.TextControls">text controls</see> currently visible on screen. There is no specific order on the text visible controls. This collection is live.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlManager.CreateTextControl(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)">
            <summary>
            Creates a new text control for some document (there might be multiple text controls for the same document).
            For backend-frontend setups, this only creates the backend part of the text control.
            To create a front part, e.g. a custom control for placing into a view, use <see cref="T:JetBrains.TextControl.TextControlAutomation" /> or its BeControls counterpart. To create a mock instance, use <see cref="!:UselessTextControl.Create(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId,JetBrains.Application.Components.IComponentContainer,JetBrains.Util.ILogger)" />.
            To open a regular editor tab in the IDE, use the Editor Manager which opens a path or a project file properly.
            </summary>
            <remarks>
            Technically, this spawns a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> instance, places onto the transport text controls list (from backend side), and assigns it an ID. The backend text control interface and services are then created for it automatically.
            Frontend-initiated text control creation, such that when a tab happens to open in the IDE, adds a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> to the protocol-synced list from the front side, and then backend entities are created as usual, so this method does not get called in this scenario.
            </remarks>
            <param name="lifetime">Defines when your text control will be removed from the running text controls list.</param>
            <param name="document">The document for which a text control is being created. The document is attached to a text control once and forever, and cannot be changed.</param>
            <returns>The newly-created text control. This method either throws an exception or returns a valid text control.</returns>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlManager.TryGetTextControlById(JetBrains.TextControl.RunningTextControlId)">
            <summary>
            Geta a running text control by its <see cref="P:JetBrains.TextControl.ITextControl.Id" />, if that text control is currently present in <see cref="P:JetBrains.TextControl.ITextControlManager.TextControls" /> list.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlOptions.ReadOnly">
            <summary>
            Get or set the readonly state of the text control. The implementation and side effects depend on text control kind (see remarks section).
            </summary>
            <remarks>
            Standalone SyntaxEditor text controls. Readonly is a property of a document. So if the document is open in several text contols or views, they will all be affected.
            Visual Studio. Readonly is a property of a text view, so if you have two views in the same tab (splitted views), one of them could be readonly while another one is editable.
            </remarks>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlOptions.TabSize">
            <summary>
            Get or set the tab size used by the text control.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlOptions.VerticalScrollbarMode">
            <summary>
            This option exists since VS12.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlOptions.FileHealthIndicator">
            <summary>
            This option exists since VS16.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlOptions.ShowErrorsOnVerticalScrollBar">
            <summary>
            (DK) A temporary property, duplicates VerticalScrollbarMode. TODO redesign in 192.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ITextControlScrolling">
            <summary>
            The scrolling parameters of the text control, both for quering and manipulating.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlScrolling.TextControl">
            <summary>
            Gets the owning text control.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlScrolling.ViewportRange">
            <summary>
              <para>Gets the area that the viewport covers over the extent (the whole imaginary field of the scrollable content whose part is visible in the viewport), in the form of a document or text control range.</para>
              <para>Note that the column number or virtual spaces delta is not applicable to this range because the visible columns set varies with lines. Only lines are taken into account.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlScrolling.CollapsedViewportRanges">
            <summary>
            Gets collapsed regions ranges in <see cref="P:JetBrains.TextControl.ITextControlScrolling.ViewportRange"/>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlScrolling.ScrollTo(JetBrains.TextControl.Coords.ITextControlPos,JetBrains.TextControl.TextControlScrollType)">
            <summary>
            Scrolls the view to make the <paramref name="position" /> visible in the viewport, placing it based on the <paramref name="scrollType" />.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlSelection.Ranges">
            <summary>
              <para>Gets or sets the selection ranges. There is guaranteed to be at least one selection range.</para>
              <para>If there is no selection, this is a single zero-length range at the caret position.</para>
              <para>If a single continuous range is selected ("stream selection" in VS), there is a single range whose <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.Start" /> is the anchor end of the selection and <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.End" /> is its active end.</para>
              <para>If the selection is not continuous (e.g. "box selection" in VS), there is a set of continuous selection ranges, without any particular order, but the first range in the array begins in the anchor point, and the last range in the array ends in the active point.</para>
              <para>In short, this is the non-empty array of continuous selection ranges where <c>First().Start</c> denotes the anchor end of the selection (the fixed point of shift+arrowkeys selection), and <c>Last().End</c> is the active end of the selection, ie the caret location.</para>
              <para>Note that neither ranges nor range ends are ordered against document offsets.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlSelection.TextControl">
            <summary>
            Gets the owning text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlSelectionEx.Collapse(JetBrains.TextControl.ITextControlSelection,JetBrains.TextControl.SelectionEnd)">
            <summary>
            Collapses the selection, making the selection range empty and located at the caret location.
            </summary>
            <param name="thіs"></param>
            <param name="collapseToWhichEnd">
              <para>If <c>True</c>, collapses to selection anchor point (<see cref="P:JetBrains.TextControl.ITextControlSelection.Ranges" />).</para>
              <para>If <c>False</c>, collapses to selection active point (<see cref="P:JetBrains.TextControl.ITextControlSelection.Ranges" />).</para>
            </param>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlSelectionEx.SetRanges(JetBrains.TextControl.ITextControlSelection,JetBrains.TextControl.Coords.TextControlPosRange[])">
            <summary>
              <para>Attempts to set the text control selection to the given range.</para>
              <para>The <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.Start" /> denotes the anchor end of the selection (the fixed point of shift+arrowkeys selection).</para>
              <para>The <see cref="F:JetBrains.TextControl.Coords.TextControlPosRange.End" /> is the active end of the selection, ie the caret location.</para>
              <para>For multi-range selection, see docs on <see cref="P:JetBrains.TextControl.ITextControlSelection.Ranges" /> for layout.</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ITextControlsZone">
            <summary>
            Text editors support.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ITextControlWindow">
            <summary>
            Provides various UI framework-related information about the <see cref="T:JetBrains.TextControl.ITextControl">text control</see>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.Frame">
            <summary>
            <para>Gets the class that represent the frame that sites the text control. This frame knows whether it's visible on screen, and sometimes it can cause the environment to switch so that the frame became visible.</para>
            <para>In Visual Studio, an example of such frames is an editor tab or a tool window, in which case this implementation is based on the VS Window Frame interface.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.IsFocused">
            <summary>
            <para>Gets whether the window is currently focused.</para>
            <para>This property is <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded</see>, which means that all of the property changes will only occur in the guarded context.</para>
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.IsVisibleOnScreen">
            <summary>
            <para>Gets whether the window is currently visible onscreen, which tries to take into account not only the visibility flag of the text control window, but also whether the window layout allows the text control contents to be visible onscreen.</para>
            <para>This property is <see cref="T:JetBrains.Threading.ReentrancyGuard">guarded</see>, which means that all of the property changes will only occur in the guarded context.</para>
            </summary>
            <remarks>Even though <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.IsVisibleOnScreen"/> is also available thru the <see cref="P:JetBrains.TextControl.ITextControlWindow.Frame"/>, its value is not synchronized with <see cref="P:JetBrains.TextControl.ITextControlWindow.IsFocused"/>. This particular property is guaranteed to be high when the text control has keyboard focus, while the frame only reflects what it knows about the environment. Sometimes they do not agree, because not all of the Visual Studio implementation is accurate in details.</remarks>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.Keyboard">
            <summary>
            Fires when any key (including non-character modifier keys, like Ctrl and Shift) is pressed or released in the text control.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.MouseDown">
            <summary>
            Fires when a mouse button is pressed in this text control.
            You can cancel event processing by default text control mouse handlers by raising <see cref="F:JetBrains.TextControl.TextControlMouseEventArgs.IsHandled"/>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.MouseMove">
            <summary>
            Fires when a mouse cursor is moved over text control (or outside, if mouse is captured).
            You can cancel event processing by default text control mouse handlers by raising <see cref="F:JetBrains.TextControl.TextControlMouseEventArgs.IsHandled"/>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.MouseUp">
            <summary>
            Fires when a mouse button is released in this text control.
            You can cancel event processing by default text control mouse handlers by raising <see cref="F:JetBrains.TextControl.TextControlMouseEventArgs.IsHandled"/>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.MouseAndModifierKeys">
            <summary>
            The unified event for mouse and keyboard text control events.
            Fires an event when mouse enters the viewport, leaves the viewport, moves, changes button state, or when the modifier keys state changes while either mouse or focus is within the text control viewport.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlWindow.TextControl">
            <summary>
            Gets the owning text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlWindow.CreateViewportAnchor(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an anchoring rectangle for the viewport of the text control.
            You must dispose of the value after use.
            Supposedly, creating a new anchor is cheap after you ask it for the first time on this text control. Calling this function for learning the viewport screen coordinates is OK.
            </summary>
            <param name="lifetime"></param>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlWindow.Focus(JetBrains.TextControl.TextControlOpenFileDescriptor)">
            <summary>
            Tries to make <see cref="P:JetBrains.TextControl.ITextControlWindow.IsFocused"/> <c>True</c>. Even if successful, might not apply immediately, as the changes to the <see cref="P:JetBrains.TextControl.ITextControlWindow.IsFocused"/> occur in the reentrancy-guarded context only.
            </summary>
            <param name="offset">Offset after focusing</param>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlWindow.Show">
            <summary>
            Tries to make <see cref="P:JetBrains.TextControl.ITextControlWindow.IsVisibleOnScreen"/> <c>True</c>. Even if successful, might not apply immediately, as the changes to the <see cref="P:JetBrains.TextControl.ITextControlWindow.IsVisibleOnScreen"/> occur in the reentrancy-guarded context only.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlWindowEx.ShowOrFocus(JetBrains.TextControl.ITextControlWindow,System.Boolean,JetBrains.TextControl.TextControlOpenFileDescriptor)">
            <summary>
            Switches between <see cref="M:JetBrains.TextControl.ITextControlWindow.Show"/> and <see cref="M:JetBrains.TextControl.ITextControlWindow.Focus(JetBrains.TextControl.TextControlOpenFileDescriptor)"/> with a boolean param.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior">
            <summary>
            Describes the Jet Action Bar Editor Margin, which is optionally shown next to the Gutter Margin on the left of the text editor.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior.IsApplicable">
            <summary>
            If this product enables the use of the Jet Action Margin. If not, it's always off.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior.IsEnabledLive(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Settings.ContextRange)">
            <summary>
            Create a live property which changes in the main thread. Can call free-threaded..
            Does not take into account manual suppression, see <see cref="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehaviorEx.IsGutterMarginEnabledAndNotSuppressed(JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior,JetBrains.TextControl.ITextControl)" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior.IsEnabledTransient(JetBrains.Application.Settings.ContextRange)">
            <summary>
            Cheap one-time check of the same as <see cref="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior.IsEnabledLive(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Settings.ContextRange)" />.
            Does not take into account manual suppression, see <see cref="M:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehaviorEx.IsGutterMarginEnabledAndNotSuppressed(JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehavior,JetBrains.TextControl.ITextControl)" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.JetActionMargin.IJetActionEditorMarginBehaviorEx.SuppressJetActionBarKey">
            <summary>
            A key for user data on either document or text control to disable gutter margin on it.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Layout.TextControlAnchoringRect">
            <summary>
            Represents an anchor in the text editor.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Layout.TextControlAnchoringRect.myRangeMarker">
            <summary>
            A marker for the <see cref="F:JetBrains.TextControl.Layout.TextControlAnchoringRect.Range"/> range.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.#ctor(JetBrains.Lifetimes.OuterLifetime,JetBrains.TextControl.ITextControl,JetBrains.TextControl.DocOffset,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Anchors to the given range on the given text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.#ctor(JetBrains.Lifetimes.OuterLifetime,JetBrains.TextControl.ITextControl,JetBrains.Util.TextRange,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Anchors to the given range on the given text control.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Layout.TextControlAnchoringRect.Range">
            <summary>
            Gets or sets the range whose rectangle is tracked.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Layout.TextControlAnchoringRect.TextControl">
            <summary>
            Gets the text control to which the range belongs.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.CreateBeginningOfLine(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.ITextControl,JetBrains.TextControl.DocOffset,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Creates an anchoring rectangle on the character at the beginning of the line.
            </summary>
            <param name="lifetime"></param>
            <param name="textcontrol">The text control.</param>
            <param name="offset">An offset in the text control. The beginning of the line containing this offset at the moment of the call will be tracked.</param>
            <param name="locks"></param>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.CreateFromCaretStatic(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.ITextControl,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Creates an anchoring rectangle that anchors to the place where the caret was at the instant of the call.
            “Static” means the anchor would update to accomodate for changes in the document, but won't track caret movement.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.CreateFromSelectionStatic(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.ITextControl,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Creates an anchoring rectangle that anchors to the place where the selection margin was at the instant of the call.
            “Static” means the anchor would update to accomodate for changes in the document, but won't track selection changes.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlAnchoringRect.UpdateAnchorGuarded(JetBrains.Application.UI.PopupLayout.IAnchoringRect,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Needs a read lock for manipulating the document, called from UpdateAnchor in a guarded context.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Layout.TextControlPopupWindowContext">
            <summary>
            Implementaion of <see cref="T:JetBrains.Application.UI.PopupLayout.IPopupWindowContext"/> for <see cref="T:JetBrains.TextControl.ITextControl"/>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlPopupWindowContextFactory.ForBeginningOfLineCore(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.DocOffsetAndVirtual)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlPopupWindowContextFactory.ForCaretCore(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.Layout.TextControlPopupWindowContextFactory.ForRangeCore(JetBrains.Lifetimes.Lifetime,JetBrains.Util.TextRange)">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.SelectionEnd.Active">
            <summary>
              <para>The active end of the selection (the one which moves when you do Shift+Arrow; where the caret is).</para>
              <para>When selection is represented by a range with a “start” and an “end”, this is the “end”.</para>
              <para>If asked and in doubt, use this one (that's why it's the default value for the type).</para>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.SelectionEnd.Anchor">
            <summary>
              <para>The anchor end of the selection (the one which remains in place when you do Shift+Arrow; the selection is drawn from the anchor to the current location of the caret).</para>
              <para>When selection is represented by a range with a “start” and an “end”, this is the “start”.</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlAutomation">
            <summary>
              <para>A view model which allows placing a <see cref="T:JetBrains.TextControl.ITextControl">text control</see> that you have created in the backend into UI.</para>
              <para>How to use:</para>
              <para>(1) Basic scenario is when you need to just define text and coloring, which can be fully provided thru an <see cref="T:JetBrains.DocumentModel.IDocument" /> that you get by calling <see cref="M:JetBrains.DocumentModel.IIdeInMemoryDocumentFactory.CreateIdeDocumentFromText(JetBrains.Lifetimes.Lifetime,System.String,System.String,System.Func{JetBrains.DocumentModel.IDocument,JetBrains.Util.ModificationCookie})" />. Then create a <see cref="T:JetBrains.TextControl.TextControlAutomation" /> with <see cref="M:JetBrains.TextControl.TextControlAutomationBackendHelpers.FromDocument(JetBrains.TextControl.TextControlAutomation.Factory,JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument,JetBrains.TextControl.TextControlHostedIn,JetBrains.TextControl.TextControlPreferences,JetBrains.Application.UI.WindowManagement.WindowFrame,JetBrains.TextControl.TextControlAutomationFlags,JetBrains.DocumentModel.IRunningDocuments,JetBrains.Application.Threading.IShellLocks)" /> and use as any other view model to have a view created for it.</para>
              <para>(2) If you need <see cref="T:JetBrains.TextControl.ITextControl" />-specific features with your editor, such as caret operations, do the same and then use text controls in the <see cref="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls" /> live collection. They will appear as soon as there's one or more views running.</para>
              <para>(3) If you definitely need a single <see cref="T:JetBrains.TextControl.ITextControl" /> instance, or must be able to use it even before the views are created, then create an <see cref="T:JetBrains.TextControl.ITextControl" /> with <see cref="M:JetBrains.TextControl.ITextControlManager.CreateTextControl(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)" />, fill in the <see cref="T:JetBrains.TextControl.TextControlAutomation" /> object with its <see cref="P:JetBrains.TextControl.ITextControl.Id" />, and use in the view model. A proper text control view will be created automatically when this viewmodel is presented.</para>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls">
            <summary>
              <para>When a text control view is created on front end and a text control gets connected to it, either an existing or a new one, it gets registered in this collection for the lifetime of the view. See docs on <see cref="F:JetBrains.TextControl.TextControlAutomation.UserCreatedTextControl" /> for details.</para>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomation.DocumentId">
            <summary>
            The document for which an editor view (one ore more text controls) will be created.
            You should lock an <see cref="T:JetBrains.DocumentModel.IDocument" /> to have this stable ID for at least the lifetime of the view model.
            If you supply a <see cref="F:JetBrains.TextControl.TextControlAutomation.UserCreatedTextControl">user-created text control</see>, this must be its <see cref="P:JetBrains.TextControl.RunningTextControlId.DocumentId">document ID</see>.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomation.HostedIn">
            <summary>
            The type of the window where the text control is hosted.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlAutomation.New">
            <summary>
            Accessor for creator factory methods.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomation.Preferences">
            <summary>
            Overrides for text control preferences.
            Baseline values (those left NULL) are taken either from <see cref="M:JetBrains.TextControl.ITextControlSchemeManager.GetDefaultPreferences" /> or from the underlying IDE defaults.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomation.UserCreatedTextControl">
            <summary>
            <para>Optional. If you already have created a backend text control, pass it here, and the first text control view created on front end will be connected to it. Secondary views creation will be disabled in this case (so no splitter functionality). <see cref="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls" /> will have this as the single entry for the lifetime when the view is actually created and connected.</para>
            <para>If NULL, then front end will create text controls for every text view (there might be more than one since user is allowed to split the original text view, and each split part is a text view which needs a text control), and advertise in <see cref="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls" /> collection.</para>
            <para>How to choose whether to supply:</para>
            <para>• If your feature does not care about <see cref="T:JetBrains.TextControl.ITextControl" /> API at all (supplies text and coloring via <see cref="T:JetBrains.DocumentModel.IDocument" />), then create this object with just a <see cref="F:JetBrains.TextControl.TextControlAutomation.DocumentId" /> (e.g. with <see cref="M:JetBrains.TextControl.TextControlAutomationBackendHelpers.FromDocument(JetBrains.TextControl.TextControlAutomation.Factory,JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument,JetBrains.TextControl.TextControlHostedIn,JetBrains.TextControl.TextControlPreferences,JetBrains.Application.UI.WindowManagement.WindowFrame,JetBrains.TextControl.TextControlAutomationFlags,JetBrains.DocumentModel.IRunningDocuments,JetBrains.Application.Threading.IShellLocks)" />).</para>
            <para>• If your feature wants to interact with the resulting <see cref="T:JetBrains.TextControl.ITextControl">text controls</see>, use the <see cref="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls" /> collection to bind to each text control.</para>
            // TODO: example
            <para>• If your feature needs strictly one single text control, or needs it available before spawning the view, create it beforehand with <see cref="M:JetBrains.TextControl.ITextControlManager.CreateTextControl(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)" /> overloads and supply</para>
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlAutomationBackendHelpers">
            <summary>
            Stuff around <see cref="T:JetBrains.TextControl.TextControlAutomation" /> that you can only do on backend.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlAutomationBackendHelpers.GetConnectedTextControlsLive(JetBrains.TextControl.TextControlAutomation,JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.ITextControlManager)">
            <summary>
            On backend, gets the live list of text control objects currently serving the views.
            </summary>
            <param name="automation"></param>
            <param name="lifetime"></param>
            <param name="textman"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomationFlags.WantsTabNavigation">
            <summary>
            Do not translate Tab and Shift+Tab so that parent form could use them to navigate between controls.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlAutomationFlags.AllowMultipleViewsWithUserDefinedTextControl">
            <summary>
            Allows creation of secondary views, such as by splitting the main view into parts.
            All of the views will be in <see cref="F:JetBrains.TextControl.TextControlAutomation.ConnectedTextControls" />.
            Normally, the behavior is as follows: if <see cref="F:JetBrains.TextControl.TextControlAutomation.UserCreatedTextControl" /> is NULL, secondary views can be created; if it's defined, then it's supposed to be connected to the only view. This flag overrides the behavior in the latter case. This isn't supposed to be needed in normal features.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlColumn">
            <summary>
            Type disambig for <see cref="T:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1"/>.
            Represents zero-based column indices in the text control view.
            This does not correspond directly to the document lines and columns because of the collapsed regions and other view transformations.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlCreator">
            <summary>
            Creates text control instances on backend.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlCreator.CreateTextControl(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)">
            <summary>
            Creates a new text control for some document (there might be multiple text controls for the same document).
            For backend-frontend setups, this only creates the backend part of the text control.
            To create a front part, e.g. a custom control for placing into a view, use <see cref="T:JetBrains.TextControl.TextControlAutomation" /> or its BeControls counterpart. To create a mock instance, use <see cref="M:JetBrains.TextControl.BaseImpl.UselessTextControl.Create(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId,JetBrains.Application.Components.IComponentContainer,JetBrains.Util.ILogger)" />.
            To open a regular editor tab in the IDE, use the Editor Manager which opens a path or a project file properly.
            </summary>
            <remarks>
            Technically, this spawns a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> instance, places onto the transport text controls list (from backend side), and assigns it an ID. The backend text control interface and services are then created for it automatically.
            Frontend-initiated text control creation, such that when a tab happens to open in the IDE, adds a <see cref="T:JetBrains.TextControl.Transport.TransportTextControl" /> to the protocol-synced list from the front side, and then backend entities are created as usual, so this method does not get called in this scenario.
            </remarks>
            <param name="lifetime">Defines when your text control will be removed from the running text controls list.</param>
            <param name="document">The document for which a text control is being created. The document is attached to a text control once and forever, and cannot be changed.</param>
            <returns>The newly-created text control. This method either throws an exception or returns a valid text control.</returns>
        </member>
        <member name="M:JetBrains.TextControl.TextControlExtensions.EmulateEnter(JetBrains.TextControl.ITextControl)">
            <summary>
            Does <see cref="M:JetBrains.TextControl.ITextControl.EmulateAction(System.String)" /> for <see cref="F:JetBrains.Application.UI.ActionSystem.Text.TextControlActions.ActionIds.Enter" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlExtensions.ShowAtCaret(JetBrains.Application.UI.Tooltips.ITooltipManager,JetBrains.Lifetimes.Lifetime,System.String,JetBrains.TextControl.ITextControl,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Shows a tooltip at the text control caret location.
            </summary>
            <param name="thіs"></param>
            <param name="lifetime"></param>
            <param name="text"></param>
            <param name="textcontrol"></param>
            <param name="locks"></param>
        </member>
        <member name="M:JetBrains.TextControl.TextControlExtensions.GetTransportPropertyBag(JetBrains.TextControl.ITextControl)">
            <summary>
            For a text control built over the transport model, gives access to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.PropertyBag" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlExtensions.TryGetTransportPropertyBag(JetBrains.TextControl.ITextControl)">
            <summary>
            For a text control built over the transport model, gives access to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.PropertyBag" />.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlHostedIn">
            <summary>
            If the text control is hosted in a window, it requires special processing for Alt+F4, Esc, etc.
            Message filtering method depends on the window type.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlLine">
            <summary>
            Type disambig for <see cref="T:JetBrains.Util.dataStructures.TypedIntrinsics.Int32`1"/>.
            Represents zero-based line indices in the text control view.
            This does not correspond directly to the document lines and columns because of the collapsed regions and other view transformations.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlLineColumn">
            <summary>
            Represents the document position in terms of Line and Column indices.
            Note that this has nothing to do with screen pixels, which cannot be operated on backend interfaces like <see cref="T:JetBrains.TextControl.ITextControl"/>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumn.GetStartOfRow">
            <summary>
            Gets a new visual position located at the same row as the original one, but in the first column.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumn.OffsetHorizontally(JetBrains.Util.dataStructures.TypedIntrinsics.Int32{JetBrains.TextControl.TextControlColumn})">
            <summary>
            Returns a new position with the same row and an offset column.
            Does not change the current object.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlLineColumnRange">
            <summary>
            A range between two <see cref="T:JetBrains.TextControl.TextControlLineColumn"/>s.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumnRange.ToNormalized">
            <summary>
            Normalizes the range so that its start position went before the end position.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumnRange.Equals(System.Object)">
            <summary>
            Indicates whether this instance and a specified object are equal.
            </summary>
            <returns>
            true if <paramref name="obj"/> and this instance are the same type and represent the same value; otherwise, false.
            </returns>
            <param name="obj">Another object to compare to. </param><filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumnRange.GetHashCode">
            <summary>
            Returns the hash code for this instance.
            </summary>
            <returns>
            A 32-bit signed integer that is the hash code for this instance.
            </returns>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.TextControl.TextControlLineColumnRange.Equals(JetBrains.TextControl.TextControlLineColumnRange)">
            <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
            <returns>
            true if the current object is equal to the <paramref name="other"/> parameter; otherwise, false.
            </returns>
            <param name="other">An object to compare with this object.</param>
        </member>
        <member name="T:JetBrains.TextControl.TextControlMouseEventArgs">
            <summary>
            Arguments for text control events.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.#ctor(JetBrains.TextControl.ITextControl,System.Nullable{JetBrains.Util.Media.JetPhysicalPoint},System.Nullable{JetBrains.TextControl.DocOffsetAndVirtual},System.UInt32)">
            <summary>
            Create. Point is known, keys/button states are queried from system.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.#ctor(JetBrains.TextControl.ITextControl,System.Nullable{JetBrains.Interop.WinApi.KeyStateMasks},System.Nullable{JetBrains.TextControl.DocOffsetAndVirtual},System.Nullable{JetBrains.Util.Media.JetPhysicalPoint},System.UInt32)">
            <summary>
            Create.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.IsHandled">
            <summary>
            Set to <c>True</c> if you'd like to prevent default handlers from processing the message.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons">
            <summary>
            Which keyboard modifier keys and mouse buttons were pressed when the event was fired.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.ViewportPosition">
            <summary>
            Mouse cursor position when within the text control viewport, in viewport-relative (logical? device? it's currently undefined) pixel coordinates.
            A NULL value means that the mouse pointer is outside the text control viewport.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.DocumentPosition">
            <summary>
            Mouse cursor position, in text control coordinates. Might be NULL if outside text control.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.ClickCount">
            <summary>
            Gets the number of times the button was clicked (if applicable).
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlMouseEventArgs.TextControl">
            <summary>
            The originating text control.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlMouseEventArgs.IsMouseDown">
            <summary>Gets if the <see cref="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons"/> has any mouse button down.</summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlMouseEventArgs.ModifierKeysOnly">
            <summary><see cref="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons"/> bits from <see cref="F:JetBrains.Interop.WinApi.KeyStateMasks.MaskKeyboard"/>.</summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.FromCurrentPositionAndState(JetBrains.TextControl.ITextControl,System.UInt32)">
            <summary>
            Gets the arguments corresponding to the current mouse position onscreen and keyboard state.
            Might be outside the text control.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.Equals(JetBrains.TextControl.TextControlMouseEventArgs)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlMouseEventArgs.GetHashCode">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.TextControlOptionsBinding">
            <summary>
            Sourcing options values from creation-time stuff.
            Should basically be done by all text controls upon creation.
            Apart from that, should be bound to the actual view. And called from user code to change either options.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.#ctor(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.Equals(JetBrains.TextControl.TextControlOverridableValue{`0})">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.op_Explicit(JetBrains.TextControl.TextControlOverridableValue{`0})~`0">
            <summary>
            An explicit cast extracts the effective value.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.op_Explicit(`0)~JetBrains.TextControl.TextControlOverridableValue{`0}">
            <summary>
            An explicit cast wraps with an overridable value for which the original value is set from the value given.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.WithOverride(`0)">
            <summary>
            Makes a new instance with the value overridden to the specified value.
            </summary>
            <param name="override"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValue`1.WithOverride(System.Nullable{`0})">
            <summary>
            Makes a new instance with the value overridden to the specified value, or with the override lifted if NULL.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValueEx.GetEffectiveValue``1(JetBrains.DataFlow.IProperty{JetBrains.TextControl.TextControlOverridableValue{``0}})">
            <summary>
            Gets the effective value (i.e. either the original or the user-override if non-NULL) out of the property in a single call.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValueEx.SetOverrideValue``1(JetBrains.DataFlow.IProperty{JetBrains.TextControl.TextControlOverridableValue{``0}},``0)">
            <summary>
            Has the property value overridden to the specified value.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.TextControl.TextControlOverridableValueEx.SetOverrideValue``1(JetBrains.DataFlow.IProperty{JetBrains.TextControl.TextControlOverridableValue{``0}},System.Nullable{``0})">
            <summary>
            Has the property value overridden to the specified value, or with the override lifted if NULL.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase">
            <summary>
            Base impl implements half the API thru the other half. Probably will be removed, because duplicated API is a temporary measure.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#CreatePopupWindowContext(JetBrains.Lifetimes.Lifetime)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#CreatePopupWindowContext(JetBrains.Lifetimes.Lifetime,JetBrains.Util.TextRange)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#ForBeginningOfLine(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.Coords.ITextControlPos)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#ForBeginningOfLine(JetBrains.TextControl.DocOffsetAndVirtual)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#ForCaret">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPopupWindowContextFactoryBase.JetBrains#TextControl#ITextControlPopupWindowContextFactory#ForRange(JetBrains.Util.TextRange)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlPreferences.OverridePreferencesLive(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.TextControlPreferences,JetBrains.TextControl.TextControlPreferences)">
            <summary>
            Takes two sets of nullable preferences, lower-priority and higher-priority. Higher-priority takes precedence if non-NULL for a certain option, otherwise, lower-priority.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlScrollType">
            <summary>
            Applies when the text control is scrolled to reveal a certain <see cref="T:JetBrains.TextControl.Coords.ITextControlPos">position</see>.
            Defines how the desired position will be accomodared inside the viewport area.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.DontCare">
            <summary>
            Scrolls so that the position is visible anywhere in the viewport.
            There're no other guarantees or heuristics applied.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.CenterInView">
            <summary>
            Scrolls so that the position were at about the center of the viewport.
            The view is scrolled even if the position is already visible.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.TopOfView">
            <summary>
            Scrolls so that the position were at about the top of the viewport.
            The view is scrolled even if the position is already visible.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.UpperHalf">
            <summary>
            Scrolls so that the position were in the upper half of the viewport.
            The view is scrolled even if the position is already visible.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.LowerHalf">
            <summary>
            Scrolls so that the position were in the lower half of the viewport.
            The view is scrolled even if the position is already visible.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.Smart">
            <summary>
            <para>Smart scrolling mode. Should be used in most cases.</para>
            <para>Does minimal scrolling (or none at all) required to place the position into the viewport not too close to its edges.</para>
            </summary>
            <remarks>
            <para>If the position is already visible in the view and is not too close to the edges, no scrolling is performed. This fits for navigating adjacent occurrences without the view jumping.</para>
            <para>Otherwise, places the position above the viewport center if it were above the viewport, and vice versa.</para>
            </remarks>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.SmartDirectionalUp">
            <summary>
            A flavor of <see cref="F:JetBrains.TextControl.TextControlScrollType.Smart"/> for special cases. Relaxes the “not too close to the edge” constraint: would not scroll against the direction if the target is at least visible.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlScrollType.SmartDirectionalDown">
            <summary>
            A flavor of <see cref="F:JetBrains.TextControl.TextControlScrollType.Smart"/> for special cases. Relaxes the “not too close to the edge” constraint: would not scroll against the direction if the target is at least visible.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlSelectionBase">
            <summary>
            Base common impl.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionBase.GetAnchorToActiveSpanForContinuousSelection(System.Collections.Generic.IList{JetBrains.TextControl.Coords.TextControlPosRange})">
            <summary>
            In case the text control does not support applying continuous selection, calculates the minimum spanning range and arranges its ends so that the first point is the anchor and the second is the active one. The anchor and active are determined from the given ranges in the same way as on <see cref="P:JetBrains.TextControl.ITextControlSelection.Ranges" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionBase.GetAnchorToActiveSpanForContinuousSelection(System.Collections.Generic.IList{JetBrains.TextControl.Transport.DocOffsetAndVirtualRange})">
            <summary>
            In case the text control does not support applying continuous selection, calculates the minimum spanning range and arranges its ends so that the first point is the anchor and the second is the active one. The anchor and active are determined from the given ranges in the same way as on <see cref="P:JetBrains.TextControl.ITextControlSelection.Ranges" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.HasSelection(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            Tells whether the selection is non-empty.
            Otherwise, the selection range will be placed at the <see cref="P:JetBrains.TextControl.ITextControl.Caret"/> position.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.SetRange(JetBrains.TextControl.ITextControlSelection,JetBrains.Util.TextRange)">
            <summary>
            Sets selection to a range given in the document coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.SetRange(JetBrains.TextControl.ITextControlSelection,JetBrains.DocumentModel.DocumentRange)">
            <summary>
            Sets selection to a range given in the document coordinates.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.RandomRange(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            With stream selection, returns the selected range. With box selection, the result is undefined.
            Do not use. Replace with other methods when seen (IsDisjoint, UnionOfDocRanges, OneDocRangeWithCaret).
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.IsDisjoint(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            Gets whether selection cannot be represented as a single continuous range, but is instead a set of disjoint ranges.
            This is a case with box ("vertical") selection in VS.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.UnionOfDocRanges(JetBrains.TextControl.ITextControlSelection)">
            <summary>
              <para>Gets a document range spanning all of the selected characters.</para>
              <para>The range is normalized (start offset is smaller than end offset).</para>
              <para>If there is no selection, returns a zero-length range positioned at caret.</para>
              <para>If there is single selected character range, returns it normalized (caret might be at either end).</para>
              <para>If there are multiple disjoint selected ranges, returns the minimum spanning range. Caret might be at either end or inside the range.</para>
            </summary>
            <remarks>Use in features such as Comment Line where only the lines participating in the selection are important.</remarks>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.UnionOfDocumentRanges(JetBrains.TextControl.ITextControlSelection)">
            <summary>
              <para>Gets a document range spanning all of the selected characters.</para>
              <para>The range is normalized (start offset is smaller than end offset).</para>
              <para>If there is no selection, returns a zero-length range positioned at caret.</para>
              <para>If there is single selected character range, returns it normalized (caret might be at either end).</para>
              <para>If there are multiple disjoint selected ranges, returns the minimum spanning range. Caret might be at either end or inside the range.</para>
            </summary>
            <remarks>Use in features such as Comment Line where only the lines participating in the selection are important.</remarks>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.OneDocRangeWithCaret(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            <para>For a possibly-disjoint selection, gets one of its ranges that contains the caret.</para>
            <para>The range is normalized (start offset is smaller than end offset).</para>
            <para>If there is no selection, returns a zero-length range positioned at caret.</para>
            <para>If there is single selected character range, returns it normalized (caret might be at either end).</para>
            <para>If there are multiple disjoint selected ranges, one of them such as that the caret is inside that
            range (at one of the ends, I guess, but won't bet on that).</para>
            </summary>
            <remarks>Box selection should be supported directly in most features. While this isn't the case yet,
            some features interested in just the selected range around caret could use this range.</remarks>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.OneDocumentRangeWithCaret(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            <para>For a possibly-disjoint selection, gets one of its ranges that contains the caret.</para>
            <para>The range is normalized (start offset is smaller than end offset).</para>
            <para>If there is no selection, returns a zero-length range positioned at caret.</para>
            <para>If there is single selected character range, returns it normalized (caret might be at either end).</para>
            <para>If there are multiple disjoint selected ranges, one of them such as that the caret is inside that
            range (at one of the ends, I guess, but won't bet on that).</para>
            </summary>
            <remarks>Box selection should be supported directly in most features. While this isn't the case yet,
            some features interested in just the selected range around caret could use this range.</remarks>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.GetActivePoint(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            Selection has an active and an anchor end. Active end is where you have the caret.
            Anchor end is the end that does not move when you do shift-selection.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.GetAnchorPoint(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            Selection has an active and an anchor end. Active end is where you have the caret.
            Anchor end is the end that does not move when you do shift-selection.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlSelectionExtensions.GetSelectedText(JetBrains.TextControl.ITextControlSelection)">
            <summary>
            Returns the selected text. The list is always non-null, but might be empty if there's no selection.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.LockDocumentsWhenOpenedInTextControls">
            <summary>
            Text controls keep hard reference to IDocument so they have to notify it's locked by them.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.RunningTextControls">
            <summary>
            Maintains the list of currently opened text controls.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.RunningTextControls.TextControls">
            <summary>
            Gets the list of all the text controls that currently exist.
            Could be modified on the primary thread in the guarded context only.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.RunningTextControls.TransportTextControls">
            <summary>
            Gets the list of transport text controls.
            These entities come from either side of the protocol.
            For all of them, backend services are created, including putting an <see cref="T:JetBrains.TextControl.ITextControl" /> instance into <see cref="F:JetBrains.TextControl.TextControlsManagement.RunningTextControls.TextControls" /> automatically.
            On front end, it depends:
            * If frontend-originated, then some visual representation must already exist (e.g. IDE opened a tab).
            * If backend-originated, then it's intended either for:
            * * A user control inserted into UI — make an automation object then of the Text Control ID and place it into your view model, either a transport view model (like BeControls) from the back side, or a regular view model <see cref="T:JetBrains.TextControl.TextControlAutomation" /> on the front side. A corresponding text control view would be spawned.
            * * A mock text control (<see cref="T:JetBrains.TextControl.BaseImpl.UselessTextControl" />) — call <see cref="M:JetBrains.TextControl.BaseImpl.UselessTextControl.Create(JetBrains.Lifetimes.Lifetime,JetBrains.TextControl.RunningTextControlId,JetBrains.Application.Components.IComponentContainer,JetBrains.Util.ILogger)" /> to mock up a front part manually.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.TextControlManager">
            <summary>
            Base implementation for <see cref="T:JetBrains.TextControl.ITextControlManager" />.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlManager.TextControlInWindowFrame">
            <summary>
            In the <see cref="T:JetBrains.Application.UI.WindowManagement.WindowFrame">window frame</see> <see cref="F:JetBrains.Application.UI.WindowManagement.WindowFrame.Bag">bag</see>, identifies the text control attached to the window frame.
            Guarded set/clear.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlManager.myTypingHandlers">
            <summary>
            Aggregate. Manages adding/removing typing handlers and executing typing on them.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlsManagement.TextControlManager.#ctor(JetBrains.TextControl.TextControlCreator,JetBrains.TextControl.TextControlTypingHandlers,JetBrains.TextControl.TextControlsManagement.TextControlProperties,JetBrains.TextControl.TextControlsManagement.RunningTextControls,JetBrains.TextControl.TextControlsManagement.TextControlManagerDerivativesLegacy,JetBrains.Application.Threading.IShellLocks)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Object" /> class.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlsManagement.TextControlManager.Legacy">
            <summary>
            Legacy wrappers to expose the collections and property changes as raw CLR events.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlsManagement.TextControlManager.TextControls">
            <summary>
            Gets the list of all the text controls that currently exist.
            Could be modified on the primary thread in the guarded context only.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlsManagement.TextControlManager.VisibleTextControls">
            <summary>
              <para>Tracks the list of <see cref="P:JetBrains.TextControl.TextControlsManagement.TextControlManager.TextControls">text controls</see> currently visible on screen. There is no specific order on the text visible controls. This collection is live.</para>
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlsManagement.TextControlManager.CreateTextControl(JetBrains.Lifetimes.Lifetime,JetBrains.DocumentModel.IDocument)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.TextControlsManagement.TextControlManager.TryGetTextControlById(JetBrains.TextControl.RunningTextControlId)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.TextControlProperties">
            <summary>
            Aggregates properties on the <see cref="T:JetBrains.TextControl.TextControlsManagement.RunningTextControls"/>, such as the list of text controls currently visible, the text control to currently have focus, etc.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.CurrentFrameTextControlPerClient">
            <summary>
            Gets the text control that most recently had the keyboard focus, unless that text control has been destroyed or we have left the window frame that holds the text control. May be <c>Null</c>. Changes are guarded.
            Note that, unlike <see cref="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.LastFocusedTextControl"/>, this property resets to <c>Null</c> when the focus wanders off to some tool window or another frame of such a kind.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.FocusedTextControlPerClient">
            <summary>
            Gets the text control that currently has the keyboard focus. May be <c>Null</c>. Changes are guarded.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.LastFocusedTextControlPerClient">
            <summary>
            Gets the text control that most recently had the keyboard focus, unless that text control has been destroyed. May be <c>Null</c>. Changes are guarded.
            Note that this property does not lose its value if focus wanders off to some tool window or another frame of such a kind.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.CurrentFrameTextControl">
            <summary>
            <inheritdoc cref="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.CurrentFrameTextControlPerClient"/>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.FocusedTextControl">
            <summary>
            <inheritdoc cref="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.FocusedTextControlPerClient"/>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.LastFocusedTextControl">
            <summary>
            <inheritdoc cref="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.LastFocusedTextControlPerClient"/>
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.VisibleTextControls">
            <summary>
            Tracks the list of <see cref="F:JetBrains.TextControl.TextControlsManagement.RunningTextControls.TextControls">text controls</see> currently visible on screen.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.TextControlsManagement.TextControlProperties.myListFocusedTextControls">
            <summary>
            As the text control focus events are delayed for guarding, it may so happen that at some moment more than one text control reports having focus. Keep track of the last text control claiming to have focus for all client IDs.
            Note: Sometimes VS fails to fire an event (or we to catch it) and we erronousely consider some text control to still have focus. In this case we'd take the most-recently-focused text control.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.TextControlManagerDerivativesLegacy">
            <summary>
            Like <see cref="T:JetBrains.TextControl.TextControlsManagement.TextControlProperties"/>, but hosts legacy stuff like plain event and property wrappers for the retained-state data points.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlsManagement.TextControlManagerDerivativesLegacy.FocusedTextControl">
            <summary>
            Gets the text control that currently has the keyboard focus. May be <c>Null</c>. Changes are guarded.
            </summary>
        </member>
        <member name="E:JetBrains.TextControl.TextControlsManagement.TextControlManagerDerivativesLegacy.CaretMoved">
            <summary>
            Fires when the caret moves in the focused text control.
            Note: there're no caret move arguments because the event is also fired when the active text control changes.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlsManagement.WrapsTransportTextControlsWithBackendITextControl">
            <summary>
            When a new transport text control is added (either from backend or frontend side), it gets wrapped with an <see cref="T:JetBrains.TextControl.ITextControl" /> interface on the backend side, with all the <see cref="T:JetBrains.TextControl.BackendTextControlServices" /> attached as appropriate.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Transport.DocOffsetAndVirtualRange.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.Transport.DocOffsetAndVirtualRangeEx.ToNonVirtualRange(JetBrains.TextControl.Transport.DocOffsetAndVirtualRange)">
            <summary>Ignores any virtual space on the range ends.</summary>
        </member>
        <member name="M:JetBrains.TextControl.Transport.DocOffsetAndVirtualRangeEx.ToNonVirtualRangeNormalized(JetBrains.TextControl.Transport.DocOffsetAndVirtualRange)">
            <summary>Ignores any virtual space on the range ends.</summary>
        </member>
        <member name="T:JetBrains.TextControl.Transport.RunningTransportTextControls">
            <summary>
            TMP cross-process root for text controls.
            Probably to be joined with the <see cref="T:JetBrains.TextControl.TextControlsManagement.RunningTextControls" />.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.Transport.ScrollingRequest.Equals(JetBrains.TextControl.Transport.ScrollingRequest)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.Transport.ScrollingRequest.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.TextControl.Transport.ScrollingRequest.GetHashCode">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TextControlOptions.DefaultTabIndentSize">
            <summary>
            Provide some sane default value for stuff which is not valid to be left zero.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#FileHealthIndicator">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#HighlightCurrentLine">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#HorizontalScrollbar">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#IndentSize">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#IsVirtualSpaceEnabled">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#LineNumbers">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#ReadOnly">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#ShowErrorsOnVerticalScrollBar">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#TabSize">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#UseTabs">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#VerticalScrollbar">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#VerticalScrollbarMode">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#WhiteSpaces">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#WordWrap">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.TextControl.Transport.TextControlOptions.JetBrains#TextControl#ITextControlOptions#ZoomControl">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteActionHandlers">
            <summary>
            Sends backwards a request to execute the action handlers chain for the action identified by its ActionID.
            This is initiated either by user triggering a command in the text editor, or by emulating it with an <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdEmulateAction" /> call.
            If neither handler cancels execution, the last-chance handler would send forwards the <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalActionHandler" /> signal so that the text control did the actual action execution in its implementation.
            </summary>
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalActionHandler" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteTypingHandlers" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdEmulateAction" />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteTypingHandlers">
            <summary>
            Sends backwards a request to execute the typing handlers chain for the given char.
            This is initiated either by user typing in the text editor, or by emulating it with an <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdEmulateTyping" /> call.
            If neither handler cancels execution, the last-chance handler would send forwards the <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalTypingHandler" /> signal so that the text control did the actual typing.
            </summary>
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalTypingHandler" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteActionHandlers" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdEmulateTyping" />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdBatchUpdateRequests">
            <summary>
            Records batch update requests, the key is just unique, and the value is the batch update request description.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalActionHandler">
            <summary>
            After running the action handlers chain in response to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteActionHandlers" /> and reaching the end, sends forward this signal for the editor implementation to do its own implementation execution. The frontend is supposed to know the active action execution session, so there's no data.
            This only could be sent in response to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteActionHandlers" />.
            </summary>
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteActionHandlers" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalTypingHandler" />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalTypingHandler">
            <summary>
            After running the typing handlers chain in response to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteTypingHandlers" /> and reaching the end, sends forward this signal for the editor implementation to do the actual typing. The frontend is supposed to know the active typing session, so there's no data.
            This only could be sent in response to <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteTypingHandlers" />.
            </summary>
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdExecuteTypingHandlers" />
            <seealso cref="F:JetBrains.TextControl.Transport.TransportTextControl.FwdExecuteFinalActionHandler" />
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdScrollTo">
            <summary>
            In case a view is late to connect, make it a persistent prop rather than signal. A nonce allows for repeated calls.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdTmpGetWindowFrame">
            <summary>
            PLAN: window frames should become protocolable objects.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.FwdTmpIsPositionInTextView">
            <summary>
            TODO: would use <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdLargerCollapsedRegions" />
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.Transport.TransportTextControl.PropertyBag">
            <summary>
            Bag for custom properties. This is the way to extend basic text control transport with transport classes for additional services around the text control.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys">
            <summary>
            For <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdMouseAndModifierKeys" />.
            </summary>
            <param name="KeysAndButtons"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons" /></param>
            <param name="ViewportPosition"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ViewportPosition" /></param>
            <param name="DocumentPosition"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.DocumentPosition" /></param>
            <param name="ClickCount"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ClickCount" /></param>
        </member>
        <member name="M:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys.#ctor(JetBrains.Interop.WinApi.KeyStateMasks,System.Nullable{JetBrains.Util.Media.JetPhysicalPoint},System.Nullable{JetBrains.TextControl.DocOffsetAndVirtual},System.UInt32)">
            <summary>
            For <see cref="F:JetBrains.TextControl.Transport.TransportTextControl.BwdMouseAndModifierKeys" />.
            </summary>
            <param name="KeysAndButtons"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons" /></param>
            <param name="ViewportPosition"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ViewportPosition" /></param>
            <param name="DocumentPosition"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.DocumentPosition" /></param>
            <param name="ClickCount"><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ClickCount" /></param>
        </member>
        <member name="P:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys.KeysAndButtons">
            <summary><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.KeysAndButtons" /></summary>
        </member>
        <member name="P:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys.ViewportPosition">
            <summary><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ViewportPosition" /></summary>
        </member>
        <member name="P:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys.DocumentPosition">
            <summary><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.DocumentPosition" /></summary>
        </member>
        <member name="P:JetBrains.TextControl.Transport.TransportTextControlMouseAndModifierKeys.ClickCount">
            <summary><inheritdoc cref="F:JetBrains.TextControl.TextControlMouseEventArgs.ClickCount" /></summary>
        </member>
        <member name="P:JetBrains.TextControl.ITextControlHandlerContext.TextControl">
            <summary>
            Gets the text control we're typing in.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlHandlerContext.CallNext">
            <summary>
            Allows other handlers to operate.
            Handlers operate in a chain. You might do your handling before remaining handlers, after them, or instead of them, based on whether and when you <see cref="M:JetBrains.TextControl.ITextControlHandlerContext.CallNext"/>.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.ITextControlHandlerContext.EnsureWritable">
            <summary>
            Requests write access for the document of the <see cref="P:JetBrains.TextControl.ITextControlHandlerContext.TextControl"/>.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.ITypingContext">
            <summary>
            Context information for <see cref="M:JetBrains.TextControl.TextControlTypingHandlers.AddTypingHandler(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.TextControl.ITypingContext},JetBrains.TextControl.TypingHandlerModificationKind,System.Int32)"/>.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.ITypingContext.Char">
            <summary>
            Gets the character that were typed.
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.TextControlFinalTypingHandler">
            <summary>
            When typing happens in a text control, at first all registered typing handlers are called (features' special processing for the typing).
            Finally (unless prevented), it falls back to the text control, which sends it to the text control frontend to do the real thing (say, add a character to the document and advance the caret).
            This class manages around this final handler in backend text control user data, specific to each backend text control instance. The creator of a text control should put this handler. This class registers itself as the final handler and dispatches to the user data given object.
            </summary>
            <seealso cref="T:JetBrains.TextControl.Actions.TextControlActionsFinalHandler" />
        </member>
        <member name="F:JetBrains.TextControl.TextControlFinalTypingHandler.TextControlFinalTypingHandlerUserDataKey">
            <summary>
            Storage key on the text control instance.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlFinalTypingHandler.#ctor(JetBrains.TextControl.TextControlFinalTypingHandler.FinalTypingHandlerDelegate)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.TextControl.TextControlTypingHandlers">
            <summary>
            Manages typing handlers over text controls.
            </summary>
        </member>
        <member name="P:JetBrains.TextControl.TextControlTypingHandlers.TypingHandlers">
            <summary>
            Copy-on-write list of handlers. Sorted backwards, because we call handlers starting from tail.
            </summary>
        </member>
        <member name="M:JetBrains.TextControl.TextControlTypingHandlers.AddTypingHandler(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.TextControl.ITypingContext},JetBrains.TextControl.TypingHandlerModificationKind,System.Int32)">
            <summary>
            Priority:
            int.MinValue + x - for skipping assists
            -10 000 + x - for read-only before/after handlers, such as automatic code completion
            -1 000 + x - for modifying before/after handlers, such as synchronized changes trackers (ChangedTagNameTracker)
            0 - for usual assists
            int.MaxValue - for final handlers (VS or text control)
            </summary>
        </member>
        <member name="T:JetBrains.TextControl.VerticalScrollbarMode">
            <summary>
            Controls the behavior and layout of the text editor vertical scroll bar.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.Simple">
            <summary>
            Standard vertical scroll bar without any annotations and enhancements.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowAnnotations">
            <summary>
            Show annotations over vertical scroll bar. Annotations are: changes, marks, errors and caret position.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowChanges">
            <summary>
            Show changes on vertical scroll bar. Requires Show Annotations to be enabled.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowMarks">
            <summary>
            Show marks (breakpoints and bookmarks) on vertical scroll bar. Requires Show Annotations to be enabled.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowErrors">
            <summary>
            Show errors on vertical scroll bar. Requires Show Annotations to be enabled.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowCaretPosition">
            <summary>
            Show caret position on vertical scroll bar. Requires Show Annotations to be enabled.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.UseMapMode">
            <summary>
            Use map mode for vertical scroll bar.
            </summary>
            <remarks>
            In map mode, when you click a location on the scroll bar, the cursor jumps to that location in the file instead of just scrolling up or down a page.
            </remarks>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowSourceImage">
            <summary>
            Lines of code are shown, in miniature, on the scroll bar. Requires Map Mode to be enabled.
            </summary>
        </member>
        <member name="F:JetBrains.TextControl.VerticalScrollbarMode.ShowPreviewTooltip">
            <summary>
            Show a tooltip with a preview of the code. Requires Map Mode to be enabled.
            </summary>
        </member>
    </members>
</doc>
