<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.BuildInterfaces</name>
    </assembly>
    <members>
        <member name="T:JetBrains.Build.Helpers.General.BooleanArtifactConverter`1">
            <summary>
            Use to enable a <see cref="T:System.ComponentModel.TypeConverter" /> for your <see cref="T:JetBrains.Build.Helpers.General.IBooleanArtifact" />-implementing class.
            Your class must also have a <c>.ctor</c> which takes a single <see cref="T:System.Boolean" /> for the value.
            Pass this type to <see cref="T:System.ComponentModel.TypeConverterAttribute" /> on your artifact, specialized to that same artifact class.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.General.BooleanArtifactHelpers">
            <summary>
            Helpers for <see cref="T:JetBrains.Build.Helpers.General.IBooleanArtifact" /> implementees.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.General.BooleanArtifactSerializer`1">
            <summary>
            Use to enable a <see cref="T:System.Windows.Markup.ValueSerializer" /> for your <see cref="T:JetBrains.Build.Helpers.General.IBooleanArtifact" />-implementing class.
            Your class must also have a <c>.ctor</c> which takes a single <see cref="T:System.Boolean" /> for the value.
            Pass this type to <see cref="T:System.Windows.Markup.ValueSerializerAttribute" /> on your artifact, specialized to that same artifact class.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildInterfacesDistributedCacheEx.DoStructuredStorageAndLoggerAsync(JetBrains.Build.Platform.DistributedCache.DistributedCache,System.String,JetBrains.Build.Platform.DistributedCache.IHasher,JetBrains.Util.ILogger,System.Func{JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Util.ILogger,System.Threading.Tasks.Task})">
            <summary>
            Gives the <see cref="T:JetBrains.Util.Storage.StructuredStorage.IStructuredStorage" /> interface for cached entities to the generator callback.
            Also gives a logger. The logged messages would be written to the cache and replayed when retrieving.
            Logging any error to the logger would return the result, but prevent it from being written to the cache.
            </summary>
            <param name="distrocache"></param>
            <param name="taskname">Identifies the task which is being wrapped with caching.</param>
            <param name="hasher"></param>
            <param name="logger">The outside logger to which all messages from the internal logger are pumped directly or from the cache. Another logger is passed to your task.</param>
            <param name="emit">Emitter gets a new logger, which writes its messages to the cache and replays when loading from cache. Loggin any error prevents caching.</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.General.BuildLogRecordLogger">
            <summary>
            Makes a logger which turns logger messages into <see cref="T:JetBrains.Build.Running.BuildLogRecord" /> for recording or processing.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildLogRecordLogger.#ctor(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildLogRecordLogger.JetBrains#Util#Storage#StructuredStorage#IStructuredStorageSerializable#GetObjectData(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.General.BuildTaskHostWrapper">
            <summary>
            A default implementation for <see cref="T:JetBrains.Build.Running.IBuildTaskHost" /> which just wraps an existing <see cref="T:JetBrains.Application.Threading.Tasks.ITaskHost" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildTaskHostWrapper.#ctor(JetBrains.Build.Running.IRunningIsolatedBuildContext)">
            <summary>A ctor for factoring as a build helper. Use <see cref="M:JetBrains.Build.Helpers.General.BuildTaskHostWrapper.FromTaskHost(JetBrains.Application.Threading.Tasks.ITaskHost)" /> when creating in code.</summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildTaskHostWrapper.FromTaskHost(JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Wraps the common interface.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildTaskHostWrapper.JetBrains#Application#Threading#Tasks#ITaskHost#QueueAt(JetBrains.Lifetimes.Lifetime,System.Action,System.DateTimeOffset)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildTaskHostWrapper.JetBrains#Application#Threading#Tasks#ITaskHost#QueueRecurring(JetBrains.Lifetimes.Lifetime,System.Action,System.DateTimeOffset,System.TimeSpan)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.General.BuildWorkingDirectory.Create(JetBrains.Lifetimes.Lifetime,System.String)">
            <summary>
            Creates a working directory for realizing artifacts into files for the duration of the current build step.
            The main idea is that this location is temporary and random, so files cannot be leaked unintendedly between steps and parties if each one uses workdirs for their operations. This avoids undeclared dependencies between resources.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.General.IBooleanArtifact">
            <summary>
            A class which wraps a boolean as a typed value.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.General.IBooleanArtifact.Value">
            <summary>
            Gets the boolean value. An artifact cannot be modified.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.ImmutableFileOnDisk.OpenFromDisk(JetBrains.Util.FileSystemPath,System.Nullable{System.UInt64})">
            <summary>
            For small files, uses the classic behavior with making a memory snapshot.
            For larger files, locks the file on disk to prevent modifications, and uses a file stream or a memory mapped view to it.
            </summary>
            <param name="path">Path to the file to open. It is an error if the file does not exist, or if there is a directory at that path.</param>
            <param name="sizeEstimateIfKnown">Often you already have some info on the file, like its expected size (e.g. because you looked for those files with <see cref="M:JetBrains.Util.FileSystemPathBase`3.GetDirectoryEntries(System.String,System.Boolean,JetBrains.Util.FileSystemPathInternStrategy)" />, or have assumptions on that). This would save querying filesystem info on the file to determine the way for opening it, which is a relatively slow operation (it's visible in the profiler).
            It isn't fatal if you do not give the exact file size, it's only used for decision.
            If you do not know, pass NULL. To make this an explicit decision, this isn't an optional parameter.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.ImmutableFileOnDisk.OpenDirectlyFromDisk(JetBrains.Util.FileSystemPath)">
            <summary>
            The impl which always opens from disk.
            TODO: impl mmap?
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.General.PreviewBuildParametersFromRequestHelpers">
            <summary>
            Tries to preview the build environment (formerly, BuildRunnerEnvironment) for the needs of the Engine from artifact values in the current request.
            This is needed to compile the script sources and build the part catalog, so the full reader of the request artifacts (with type matching) is not available yet.
            For Nuget Config, also tries to guess it from the Product Root.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.PreviewBuildParametersFromRequestHelpers.TryPreviewNugetConfigFromRequest``1(JetBrains.Build.Running.EitherBuildRunnerRequest,System.Func{``0,JetBrains.Util.FileSystemPath},JetBrains.Util.ILogger)">
            <summary>
            Build system mostly uses the list of Nuget sources out of this info, for retrieving the packages required for running the build.
            The packages taking part in the build itself are managed elsewhere, in build tasks, and might be using another config file.
            </summary>
            <param name="request">The request, in either form. Looks up input artifacts in there. “For real” they'd be used in the build, so this is only a “preview”.</param>
            <param name="FPathReader">See <typeparamref name="TBaseDirArt" />.</param>
            <param name="logger"></param>
            <typeparam name="TBaseDirArt">If we want to look up nuget config automatically under some “base” folder (eg Product Home Dir in our sln), pass the type of its artifact here, and the path extractor in <paramref name="FPathReader" />. Pass <see cref="T:System.Reflection.Missing" /> to skip.</typeparam>
            <returns>The config file body, if successful.</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Build.Helpers.General.PreviewBuildParametersFromRequestHelpers.TryPreviewNugetConfigPathOnlyFromRequest``1(JetBrains.Build.Running.EitherBuildRunnerRequest,System.Func{``0,JetBrains.Util.FileSystemPath},JetBrains.Util.ILogger)">
            <summary>
            Call <see cref="M:JetBrains.Build.Helpers.General.PreviewBuildParametersFromRequestHelpers.TryPreviewNugetConfigFromRequest``1(JetBrains.Build.Running.EitherBuildRunnerRequest,System.Func{``0,JetBrains.Util.FileSystemPath},JetBrains.Util.ILogger)" /> where possible, this one does just the path-related part of the job. See doc there.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.ITrackableFileItemDescriptions">
            <summary>
              <para>Base iface if we want to enumerate some files or directories to track on disk whether they have changed.</para>
              <para>Checking just a file list is simple, but we want to support the case when we're including a whole directory by mask, and if the set of files changes, we want to see that change too. We need to track the original mask and re-query the set of files (in addition to checking the files themselves).</para>
              <para>The hierarchy of this interface is as follows:</para>
              <para>• Descriptions for individual files.</para>
              <para>• Descriptions for folders (with mask, recursive or not, etc).</para>
              <para>• Current file bodies in addition to descriptions (when we want to return to caller the set of specific file bodies together with their tracking info) — that's a sub-hierarchy under <see cref="T:JetBrains.Build.Helpers.Inputs.ITrackableFileItems" />.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.ITrackableFileItems">
            <summary>
            <para>To <see cref="T:JetBrains.Build.Helpers.Inputs.ITrackableFileItemDescriptions" />, adds the file bodies at this moment of time.</para>
            <para>That's when we want to return to caller the set of specific file bodies together with their tracking info.</para>
            Base iface for those files whose bodies have been collected as file items.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Inputs.ITrackableFileItems.Files">
            <summary>
              <para>Gets the list of file bodies currently matched by this trackable description.</para>
              <para>The <see cref="P:JetBrains.Util.Storage.ImmutableFileItem.RelativePath" /> is relative to the base dir from which tracking info is constructed.</para>
              <para>To get the tracking info for these files, downcast to the specific inheritor, because there is no common info for them.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.NontrackedFileItem">
            <summary>
              <para>We need to have the file item body, but it should not be tracked for changes.</para>
              <para>An example scenario is when we return a set of file items to the caller as a set of <see cref="T:JetBrains.Build.Helpers.Inputs.ITrackableFileItems" />, and need to include generated files among them.</para>
              <para>A non-body version (…Description) does not exist.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.NontrackedFileItem.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackableFileItemsHelpers.LoadTrackingInfoFileXml(System.Xml.Linq.XDocument)">
            <summary>
            Loads serialized tracking infos (with full file lists for directories, and file entries both top-level and under directory must have all content hashes and lengths defined).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackableFileItemsHelpers.LoadTrackingListFileXml(System.Xml.Linq.XDocument)">
            <summary>
            Loads serialized tracking list (which just lists names of files and names/masks for folders, but does not list specific files in folders, and does not specify file content hashes and lengths for top-level file entries).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackableFileItemsHelpers.GetDirectoryEntriesCached(JetBrains.Util.FileSystemPath,System.Collections.Concurrent.ConcurrentDictionary{System.ValueTuple{JetBrains.Util.FileSystemPath,System.Boolean},System.Collections.Generic.IReadOnlyCollection{JetBrains.Util.DirectoryEntryData}}@)">
            <summary>
            It is expensive to enum filesystem, so allow caching results for the short time (when we assume it unchanged).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackableFileItemsHelpers.GetDirectoryEntriesRecursiveCached(JetBrains.Util.FileSystemPath,System.Collections.Concurrent.ConcurrentDictionary{System.ValueTuple{JetBrains.Util.FileSystemPath,System.Boolean},System.Collections.Generic.IReadOnlyCollection{JetBrains.Util.DirectoryEntryData}}@)">
            <summary>
            It is expensive to enum filesystem, so allow caching results for the short time (when we assume it unchanged).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.TrackedDirectoryItems">
            <summary>
              <para>Info for tracking if a set of files under a directory changes (as a set or their bodies), by a specific mask, recursively or not; plus the file bodies collected from the current set.</para>
              <para>All paths are relative to the tracking base dir.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Inputs.TrackedDirectoryItems.JetBrains#Build#Helpers#Inputs#ITrackableFileItems#Files">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.TrackedDirectoryItemsDescription">
            <summary>
              <para>Info for tracking if a set of files under a directory changes (as a set or their bodies), by a specific mask, recursively or not.</para>
              <para>All paths are relative to the tracking base dir.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedDirectoryItemsDescription.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.TrackedFileInfo">
            <summary>
            Describes one trackable file, either loaded from serialization, or with a body.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileInfo.CreateFromSearch(JetBrains.Util.DirectoryEntryData)">
            <summary>
            Gets info from a FS search entry, this DED MUST be based on the tracking base dir already.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileInfo.Equals(JetBrains.Build.Helpers.Inputs.TrackedFileInfo)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileInfo.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileInfo.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileInfo.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.TrackedFileItem">
            <summary>
            A single file body plus the info for tracking it for changes on disc.
            Path is rel to tracking base dir.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Inputs.TrackedFileItem.FileItem">
            <summary>
            The file content. Its path must be relative to the known base dir (say, home dir).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileItem.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Inputs.TrackedFileItemDescription">
            <summary>
            Info for checking a single file for changes.
            Path is rel to tracking base dir.
            </summary>
            <seealso cref="T:JetBrains.Build.Helpers.Inputs.TrackedDirectoryItemsDescription" />
        </member>
        <member name="M:JetBrains.Build.Helpers.Inputs.TrackedFileItemDescription.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Installation.ReferenceClosure">
            <summary>
            Helper class which provides facility to build reference closure of .NET assembly(ies).
            </summary>
            <remarks>
            Used in console tool installers to determine files necessary for particular tool.
            </remarks>
            <example>
            <code>
            ReferenceClosure
              .Of(ConsoleRunner.AssemblyName, files)
              .IncludeAssembly("JetBrains.Common.ElevationAgent")
              .IncludeExtra(ourIncludeExtra)
              .Exclude(ourExclude)
              .Build();
            </code>
            </example>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.IncludeExtra(System.Collections.Generic.IEnumerable{JetBrains.Util.PathWildcard})">
            <summary>
            Includes in result set given extra files (by mask).
            </summary>
            <param name="wildcards"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.IncludeAssembly(System.String)">
            <summary>
            Includes in result set given assembly.
            </summary>
            <param name="assemblyName">assembly name (w/o extension)</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Exclude(System.Collections.Generic.IEnumerable{JetBrains.Util.PathWildcard})">
            <summary>
            Excludes from result set given files (by mask).
            </summary>
            <param name="wildcards"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Build">
            <summary>
            Builds reference closure against specified assemblies and includes given extra files.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Installation.ReferenceClosure.Of(System.String,System.Collections.Generic.IEnumerable{JetBrains.Util.Storage.ImmutableFileItem},JetBrains.Util.FileSystemPath)">
            <summary>
            Initiates <c>ReferenceClosure</c>.
            </summary>
            <param name="entryAssemblyName">entry-point assembly name (w/o extension)</param>
            <param name="files">all files which build step has produced</param>
            <param name="basePath">the base path to locate assembly's metadata</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.Metadata.IBuildTimeRealizedAssemblyItemUnification">
            <summary>
            Designates the <see cref="T:JetBrains.Application.Bindings.AssemblyUnification.IRealizedAssemblyItemUnification" /> instance which is used during build for realizing assemblies of the build engine and build entities.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog">
            <summary>
            When a subplatform nuget package is produced, a pre-calculated part catalog for its assemblies can be placed in the nuget package jet metadata.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.Assemblies">
            <summary>
            Lists the assemblies for which catalog has been calculated.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.AssembliesAndFiles">
            <summary>
            Lists the assemblies for which catalog has been calculated, as well as names of the files from which such assemblies should be loaded when needed.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Metadata.PrecalculatedPartCatalog.PartCatalogTablesMemoryDump">
            <summary>
            A memory dump of the <see cref="T:JetBrains.Application.Table.CatalogTables" />.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargets">
            <summary>
            How to place this injection in relation with the standard language imports for this project (e.g. <c>Microsoft.CSharp.Targets</c>).
            The “<c>Before</c>” stuff can predefine scalar property values to be used for paths in the standard imports.
            The “<c>After</c>” stuff can inject into list property values at first/last position because the standard targets have already had their say.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild">
            <summary>
            Import this interface as a build helper for running MSBuild with recommended settings.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.IInvokeMsbuild.CreateSessionAsync(JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity)">
            <summary>
            Creates a new session for running MSBuild, with all parameters set up accordingly with the currently preferred values, like toolset, degree of parallelism, and so on.
            </summary>
            <param name="toolset"></param>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.OptionNeverUseTeamcityLogger">
            <summary>
            Prevents attempting to use the TC logger for MSBuild when running on TC. If not used, the MSBuild messages would be pumped thru as Logger messages and formatted for TC output.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildTimeout">
            <summary>
            Gets or sets the timeout for running the child MSBuild process.
            The wait will be aborted when the timeout elapses, and child processes will be killed.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.EnvironmentVariables">
            <summary>
            Passes name-value pairs as environment variables of the child process.
            These are available as regular MSBuild property names in the script, first-level or nested, unless an MSBuild proprety with such a name has another value.
            Also available in any executables run from within MSBuild.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildToolset">
            <summary>
              <para>MSBuild toolset, which defines the MSBuild version and the compilers it would use.</para>
              <para>There is no default, you must supply the toolset to the ctor.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects">
            <summary>
            One or more projects to build.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrder">
            <summary>
            Tells how the projects in the <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" /> list should be ordered when being supplied to MSBuild.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Properties">
            <summary>
            Passes name-value pairs as MSBuild properties.
            These can't be overridden within the first-level MSBuild script, but calling a nested MSBuild task might override any values.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Verbosity">
            <summary>
              <para>Defines verbosity for MSBuild output.</para>
              <para>This property is favored over PS standard "-Verbose" so that it could be easier parameterized on TC and so that it were uniform between MSBuild loggers and out output. All output always goes to the standard output pipeline.</para>
            </summary>
            <seealso cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.InfoMessagesLoggingLevel"/>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.InfoMessagesLoggingLevel">
            <summary>
            Defines the logging level for informational messages from MSBuild.
            These include greeting (with MSBuild toolset), progress messages upon completion of every project, and the final success message.
            This does NOT affect any output from the build itself in the form of warnings and errors (regular build messages go as <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE" /> anyway), and the final non-success message for warnings or errors. To handle these fully, make a proxy logger (e.g. <see cref="T:JetBrains.Util.Logging.AnonymousLogger" />) and filter / re-level messages as you'd wish.
            The default level for these informational messages is <see cref="F:JetBrains.Diagnostics.LoggingLevel.INFO" />.
            </summary>
            <seealso cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Verbosity" />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.AddTarget(JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownTargets)">
            <summary>
            A shortcut for setting certain well-known targets.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.AddTarget(System.String,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownTargets)">
            <summary>
            A shortcut for setting certain well-known targets for project.
            https://docs.microsoft.com/en-us/visualstudio/msbuild/how-to-build-specific-targets-in-solutions-by-using-msbuild-exe?view=vs-2017
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildAsync">
            <summary>
            Starts the build session with an output into the default logger.
            The logger has an unique random suffix to differentiate output from this specific run from other sessions running in parallel.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.BuildAsync(JetBrains.Lifetimes.OuterLifetime,JetBrains.Util.ILogger)">
            <summary>
            Starts the build session, allows to abort the run and to output build progress into a custom logger.
            It is recommended for the custom logger to have an unique random suffix on the category if it gets output to the global common logger, for telling the sessions running in parallel apart.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.SetProperties(JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties)">
            <summary>
            A shortcut for setting certain well-known properties for the MSBuild with their typed values.
            </summary>
            <param name="props"></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.EmitTmpBuildFileIfNeeded(JetBrains.Lifetimes.Lifetime,JetBrains.Util.ILogger)">
            <summary>
              Problem: MSBuild.exe won't take multiple projects to build. But we still want to be able to do it (running them just in sequence is suboptimal and also fails to utilize the multi-node build).
              If this is the case, we'd emit a temporary build file which spawns the build of our projects via the MSBuild task.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MakeStartInfoCommandLineAsync(JetBrains.MSBuild.Logger.Api.IJetMsbuildLoggerApiSession,JetBrains.Util.FileSystemPath,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode,JetBrains.Util.ILogger)">
            <summary>
              Prepares the cmdline for spawning MSBuild.exe (path to exe + args string).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture">
            <summary>
            Used to specify the targeted bitness of the .NET Framework for some methods of ToolLocationHelper
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.ContinuousIntegrationLoggerCmdlineArg">
            <summary>
            Cmdline modification if <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.IsLoggingToContinuousIntegration" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.LoggerMode.IsLoggingToContinuousIntegration">
            <summary>
            Whether we're not reporting build errors and warnings to the regular build <see cref="T:JetBrains.Util.ILogger" />, but rather pumping them directly into the Continuous Integration server, to let it track wrn/err/nesting/progress/whatever with its APIs.
            Our own MSBuild in-process log listener is only used for counting errors and warnings in such a case.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildLoggerVerbosity">
            <summary>
            Borrowed from MSBuild.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildSummaryException">
            <summary>
            The finaly summary after an MSBuild run, about the warnings and the errors count, is posted to the logger as this exception object.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.MsbuildSummaryException.#ctor(System.String,System.Exception)">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Single">
            <summary>
            Runs on the single node.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Multiple">
            <summary>
            Runs on multiple nodes, as many as there're CPUs on this machine.
            </summary>
            <remarks>
            <b>ATTENTION:</b> Don't use <i>/m</i> option for msbuild is case more than one separate msbuilds were run simultaneously!!!
            <i>/nodeReuse:false</i> option doesn't grant that process tree will be the same as msbuild connection tree!!!
            The windows job object can kill msbuilds which were used for another parallel build runs!!!
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Nodes.Overbooking2x">
            <summary>
            Runs on multiple nodes, twice as many as there're CPUs on this machine.
            </summary>
            <remarks>
            <b>ATTENTION:</b> Don't use <i>/m</i> option for msbuild is case more than one separate msbuilds were run simultaneously!!!
            <i>/nodeReuse:false</i> option doesn't grant that process tree will be the same as msbuild connection tree!!!
            The windows job object can kill msbuilds which were used for another parallel build runs!!!
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering">
            <summary>
            Tells how the projects in the <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" /> list should be ordered when being supplied to MSBuild.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.AsInList">
            <summary>
            No sorting applied, the projects are dumped into MSBuild in the same order as they're in <see cref="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.Projects" />, and MSBuild deals with their build order on itself.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.Lexicographical">
            <summary>
            The projects are sorted lexicographically, to impose some stable ordering. MSBuild still rules out how to make the build correct against all of the dependencies.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.ByProjectReferencesFlat">
            <summary>
            The invoker attempts to predict the correct build order of the projects and supply a partially-toposorted list to MSBuild. MSBuild still rules out how to make the build correct against all of the dependencies, so this sorting is not needed/guaranteed to be correct, but there's a supposition that it might improve build perf.
            All projects are fed into MSBuild in one batch.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.ProjectsOrdering.ByProjectReferencesLayered">
            <summary>
            The invoker attempts to predict the correct build order of the projects and supply a partially-toposorted list to MSBuild. MSBuild still rules out how to make the build correct against all of the dependencies, so this sorting is not needed/guaranteed to be correct, but there's a supposition that it might improve build perf.
            Projects are fed into MSBuild with smaller batches so that all projects in a batch were not referencing each other. Cons: on a build error, further batches are not executed, unlike the flat mode.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.IgnoreWarnIntDirInTempDetected">
            <summary>
              <para>A property which allows to suppress the VC warning “Warning MSB8029. The Intermediate directory or Output directory cannot reside under the Temporary directory as it could lead to issues with incremental build.”, as defined in “C:\Program Files (x86)\MSBuild\Microsoft.Cpp\v4.0\V120\Microsoft.CppBuild.targets” etc.</para>
              <para>Server build would use temp folders for int/out dirs to ensure clean rebuild, so this property might be worth using to avoid unwanted warnings.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.IntermediateOutputPath">
            <summary>
            OBJ directory.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.OutDir">
            <summary>
            Directory for all output files.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.TargetPath">
            <summary>
            Path of the main output file (e.g. DLL).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownProperties.VisualStudioVersion">
            <summary>
              <para>Sets the <c>VisualStudioVersion</c> MSBuild global property.</para>
              <para>Has no specific meaning, but without it somehow a C++ build might fail with messages like “<c>Error MSB8008. Specified platform toolset (v110_xp) is not installed or invalid. Please make sure that a supported PlatformToolset value is selected.</c>”.</para>
              <para>If it does, set to the current VS version.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.WellKnownTargets">
            <summary>
            Names for well-known MSBuild targets, for lookup in intellisense when adding a target.
            Gets added by its ToString.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildHelper">
            <summary>
            The default MSBuild setup for build tasks.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.DisplayName">
            <summary>
            Toolset name.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.FromIdentity(JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost)">
            <summary>
            Creates a toolset for the given identity.
            </summary>
            <param name="identity">The identity (either a package id or a synthetic identity for the local machine, see class for details).</param>
            <param name="nugetter">Optionally, the nuget package manager is required to fetch the toolset's nuget package when the <paramref name="identity" /> specifies a package-based toolset.</param>
            <param name="tasker">The task host is required to drive async operations.</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.FromMachineInstalled(JetBrains.Util.Version2,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture,JetBrains.Util.Storage.Packages.IJetNugetPackageManager)">
            <summary>
            Gets a toolset of the specific version installed on the current machine.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.FromNetCoreSdk(JetBrains.Lifetimes.OuterLifetime,JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <summary>
            A toolset which runs the MSBuild from the given .NET Core SDK with that same SDK runtime.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetEngineVersionAsync">
            <summary>
            Gets the toolset' MSBuild version.
            For packaged toolsets, this might mean retrieving and inspecting packages, so the async operation might not be immediate.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetPathToLoggerAssemblyAsync">
            <summary>
            When running msbuild, the client side might want to receive its logged events, such as errors, warnings, output, and progress messages.
            This gives the path to the <see cref="T:JetBrains.MSBuild.Logger.Api.IJetMsbuildLoggerApi" />-implementing assembly compatible with the current toolset.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetPathToMsbuildExeAsync">
            <summary>
            Gets the path to the MSBuild executable in the toolset.
            For packaged toolsets, this would mean retrieving ALL of the packages so that the toolset were ready for actually executing builds when the task completes, so the task might be slow when first called.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.GetRuntimeEntryPointIfApplicableAsync">
            <summary>
            When a specific runtime is needed for running msbuild, and the runtime does not derive from the current runtime automatically (example: NetFX and Mono, where you can just run the child managed assembly and the runtime applies automatically), — gives path to the entry executable for that runtime.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.InvokeMsbuildToolset.ToString">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.FallbackLoggerBodyPackage">
            <summary>
            Used if the logger assembly cannot be found alongside the current runtime files. Loads the default logger implementation supposedly compatible with the machine-installed MSBuild.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerInterfaceType">
            <summary>
            Type of the Logger API Entry-Point interface.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerClientAssemblyName">
            <summary>
            Assembly name of the assembly with the logger client implementation of the <see cref="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerInterfaceType" /> to be loaded into the client process.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset">
            <summary>
            Allows to use a custom MSBuild version from a Nuget package rather than
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.AllToolsetsExpandRoot">
            <summary>
            All toolsets' directory hierarchies are under this folder.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.Generation">
            <summary>
            Change whenever algorithm changes.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.#ctor(JetBrains.Util.Storage.Packages.JetPackageIdentity,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.FileSystemPath)">
            <summary>
            Creates the runnable MSBuild toolset.
            </summary>
            <param name="identityPackageWithToolset">A package which defines the toolset: contains MSBuild itself, plus references all of the SDK packages which need to be retrieved for it.</param>
            <param name="nugetter">Knows how to retrieve packages.</param>
            <param name="tasker">Knows how to run async operations, such as when local-restoring toolset files.</param>
            <param name="dirForToolsetOverride">Optional. The directory into which the toolset would be installed, if given. Otherwise, a uniquely-named folder under <see cref="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.AllToolsetsExpandRoot" />.</param>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.DisplayName">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.GetRuntimeEntryPointIfApplicableAsync">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.Ctor_ToolsetIdentity">
            <summary>
            Calculates the hash identity for the current toolset.
            Uses the original package names; patched msbuild package name is formed from this identity.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandConfigFileMacrosAsync(JetBrains.Util.Storage.ImmutableFileItem,JetBrains.Util.FileSystemPath,System.Collections.Generic.Dictionary{System.String,JetBrains.Util.AsyncLazy{JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.RestoredPackage}},JetBrains.Util.ILogger)">
            <summary>
            Takes the MSBuild config file, applies our macros which should reference the requested package expand locations on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.FilterByRuntime(System.Collections.Immutable.ImmutableArray{JetBrains.Util.Storage.Packages.JetNugetEntry},JetBrains.Util.ILogger)">
            <summary>
            Filters entries in the MSBuild package by the current runtime, if applicable.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.LoggerAssemblyPath">
            <summary>
            Path to the MSBuild Toolset Logger, see <see cref="F:JetBrains.Build.Helpers.Msbuild.JetMsbuildToolsetLoggerLoader.LoggerClientAssemblyName" />, if found in this toolset.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.MsbuildExePath">
            <summary>
            Path to the expanded MSBuild.exe (which is invoked to start the build).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.ExpandedToolsetInfo.ThisToolsetExpandRoot">
            <summary>
            Our toolset (specific to the set of packages and version) is expanded under this folder.
            Other toolset versions / sets of packages occupy other folders.
            Either autogenerated based on a hash of toolset props, or user-provided.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.MentionedPackage.CollectFromMsbuildConfig(System.Xml.Linq.XDocument,JetBrains.Util.RelativePath,JetBrains.Util.ILogger)">
            <summary>
            Reads the config, finds what looks like references to other packages.
            </summary>
            <param name="xdConfig">The msbuild config file XML.</param>
            <param name="relPathToMsbuildDirFromPackagesFolder">Path from the Packages folder to the dir which has msbuild.exe and this config file, supposing that msbuild is also expanded as a package. Needed to detect which of the paths are paths to the sibling packages.</param>
            <param name="logger"></param>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.JetPackagedMsbuildToolset.MsbuildNugetPatched.ProspectedExpandDir">
            <summary>
            Checks that we've encoded the correct directory into the package.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.LogReceiveHandler">
            <summary>
            Tracks receiving log messages.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset">
            <summary>
            Uses an MSBuild installed on the local machine for running the build.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset.DisplayName">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset.GetRuntimeEntryPointIfApplicableAsync">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MachineInstalledMsbuildToolset.IsInstalled(JetBrains.Util.Version2,JetBrains.Build.Helpers.Msbuild.InvokeMsbuild.DotNetFrameworkArchitecture)">
            <summary>
            Quick-checks if the given toolset version is installed locally on this machine, and if you might create a locally-installed msbuild toolset object of the said version.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildCompositeProjectEmitter">
            <summary>
              Writes an MSBuild project file which invokes a set of other project files.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildCompositeProjectEmitter.GetDelegatedTargetsFromAllTargets(System.Collections.Generic.IList{System.String})">
            <summary>
            From the targets which we need to execute, gets the list to be passed to the list of projects being executed..
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildCompositeProjectEmitter.GetDependsOnTargetsFromAllTargets(System.Collections.Generic.IList{System.String})">
            <summary>
            From the targets which we need to execute, gets the list to be executed in the top-level project rather than passed inside.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities">
            <summary>
            This class implements static methods to assist with unescaping of %XX codes
            in the MSBuild file format.
            </summary>
            <remarks>
            PERF: since we escape and unescape relatively frequently, it may be worth caching
            the last N strings that were (un)escaped
            Copyright (c) Microsoft. All rights reserved.
            Licensed under the MIT license. See LICENSE file in the MSBuild project root for full license information.
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.s_charsToEscape">
            <summary>
            Special characters that need escaping.
            It's VERY important that the percent character is the FIRST on the list - since it's both a character
            we escape and use in escape sequences, we can unintentionally escape other escape sequences if we
            don't process it first. Of course we'll have a similar problem if we ever decide to escape hex digits
            (that would require rewriting the algorithm) but since it seems unlikely that we ever do, this should
            be good enough to avoid complicating the algorithm at this point.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.s_unescapedToEscapedStrings">
            <summary>
            Optional cache of escaped strings for use when needing to escape in performance-critical scenarios with significant
            expected string reuse.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.AppendEscapedChar(System.Text.StringBuilder,System.Char)">
            <summary>
            Append the escaped version of the given character to a <see cref="T:System.Text.StringBuilder" />.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder" /> to which to append.</param>
            <param name="ch">The character to escape.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.AppendEscapedString(System.Text.StringBuilder,System.String)">
            <summary>
            Append the escaped version of the given string to a <see cref="T:System.Text.StringBuilder" />.
            </summary>
            <param name="sb">The <see cref="T:System.Text.StringBuilder" /> to which to append.</param>
            <param name="unescapedString">The unescaped string.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.ContainsEscapedWildcards(System.String)">
            <summary>
            Determines whether the string contains the escaped form of '*' or '?'.
            </summary>
            <param name="escapedString"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.ContainsReservedCharacters(System.String)">
            <summary>
            Before trying to actually escape the string, it can be useful to call this method to determine
            if escaping is necessary at all.  This can save lots of calls to copy around item metadata
            that is really the same whether escaped or not.
            </summary>
            <param name="unescapedString"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.Escape(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <returns>escaped string</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.EscapeWithCaching(System.String)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Interns and caches the result.
            </summary>
            <comment>
            NOTE:  Only recommended for use in scenarios where there's expected to be significant
            repetition of the escaped string.  Cache currently grows unbounded.
            </comment>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.EscapeWithOptionalCaching(System.String,System.Boolean)">
            <summary>
            Adds instances of %XX in the input string where the char to be escaped appears
            XX is the hex value of the ASCII code for the char.  Caches if requested.
            </summary>
            <param name="unescapedString">The string to escape.</param>
            <param name="cache">
            True if the cache should be checked, and if the resultant string
            should be cached.
            </param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.HexDigitChar(System.Int32)">
            <summary>
            Convert the given integer into its hexadecimal representation.
            </summary>
            <param name="x">The number to convert, which must be non-negative and less than 16</param>
            <returns>The character which is the hexadecimal representation of <paramref name="x" />.</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.UnescapeAll(System.String)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildEscapingUtilities.UnescapeAll(System.String,System.Boolean@)">
            <summary>
            Replaces all instances of %XX in the input string with the character represented
            by the hexadecimal number XX.
            </summary>
            <param name="escapedString">The string to unescape.</param>
            <param name="escapingWasNecessary">Whether any replacements were made.</param>
            <returns>unescaped string</returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Attributes">
            <remarks>
            NOTE: no XName version of this class because MSBuild uses attributes in the default namespace.
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Attributes.Version">
            <summary>
            A version, like with an <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.XMisc.Sdk" /> version.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.None">
            <summary>
            Results in an inclusion of a file with Build Action = None.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.AccessedTime">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.CreatedTime">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.Directory">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.Extension">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.Filename">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.LogicalName">
            <summary>
            On an <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.EmbeddedResource" /> item, the desired logical name of the resource when it gets compiled to the assembly (otherwise it's derived from project root NS and path of the file under project dir).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ModifiedTime">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.NuGetPackageId">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.NuGetPackageVersion">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.NuGetSourceType">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.OriginalProject">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Targets.GetTargetPath" /> return items.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.Package">
            <summary>
            One of the values for <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.NuGetSourceType" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PackageName">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PackageVersion">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PathInPackage">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.RecursiveDir">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.RelativeDir">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ResolvedFrom">
            <summary>
            Metadata on <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.Reference" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.RootDir">
            <summary>Well-known MSBuild metadata, produced automatically for file-based task items.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Misc.Project">
            <summary>
            The root project element name.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.DebugType">
            <summary>
            Defines the level of debug information that you want generated. Valid values are "full," "pdbonly," "portable", "embedded", and "none."
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Features">
            <summary>
            A semicolon-separated list of feature names (custom format) passed to the Roslyn compiler to convey values for which there are no individual task parameters yet.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Framework20Dir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Framework30Dir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Framework35Dir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Framework40Dir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.FrameworkDir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.FrameworkSDKDir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.JetNetStandart">
            <summary>
            Special property for avoid override some important parts in new csproj project.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.MSBuildRuntimeType">
            <summary>
            The type of the runtime that is currently executing. Introduced in MSBuild 15. Value may be undefined (prior to MSBuild 15), Full indicating that MSBuild is running on the desktop .NET Framework, Core indicating that MSBuild is running on .NET Core (for example in dotnet build), or Mono indicating that MSBuild is running on Mono.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.NETFXSDKDir">
            <summary>This were borrowed from the standard MSBuild and set in our isolated toolset template for MSBuild, but they appear to be unused in Common Targets, so let's prevent their use.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.PlatformTarget">
            <summary>
            Standard prop, CPU choice.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.SDK35ToolsPath">
            <summary>This were borrowed from the standard MSBuild and set in our isolated toolset template for MSBuild, but they appear to be unused in Common Targets, so let's prevent their use.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.SDK40ToolsPath">
            <summary>This were borrowed from the standard MSBuild and set in our isolated toolset template for MSBuild, but they appear to be unused in Common Targets, so let's prevent their use.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.TargetedFrameworkDir">
            <summary>These paths are not used directly by this .targets file but are available for pre and post build steps.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.UseSharedCompilation">
            <summary>
            Option for Roslyn which defines whether it's allowed to compile everything within the single process rather than run each compilation separately.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath10">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath11">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath12">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath14">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath15">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.VCTargetsPath16">
            <summary>This is how MS CPP props files are mounted into MSBuild.</summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values">
            <summary>
            Values for properties etc.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.all">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. All of the above (except none)</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.analyzers">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. .NET analyzers</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.build">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. .props and .targets in the build folder</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.buildMultitargeting">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. (4.0) .props and .targets in the buildMultitargeting folder, for cross-framework targeting</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.buildTransitive">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. (5.0+) .props and .targets in the buildTransitive folder, for assets that flow transitively to any consuming project. See the feature page.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.compile">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. Contents of the lib folder and controls whether your project can compile against the assemblies within the folder</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.contentFiles">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. Contents of the contentfiles folder</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Core">
            <summary>
            <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.MSBuildRuntimeType" /> variant.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Current">
            <summary>
            Value for <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Attributes.ToolsVersion" /> attribute on the <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Misc.Project" />, by default newer MSBuild versions expect this rather than a real version.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.DynamicLibrary">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.OutputType" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Embedded">
            <summary>
              <para><see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.DebugType" /></para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Exe">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.OutputType" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Full">
            <summary>
              <para><see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.DebugType" /></para>
              <para>OR</para>
              <para><see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.MSBuildRuntimeType" /> variant.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Latest">
            <summary>
            <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.LangVersion" /> for Roslyn value for the latest supported language version.
            <code>
            /// &lt;summary&gt;
            /// The latest version of the language supported.
            /// &lt;/summary&gt;
            Latest = int.MaxValue,
            </code>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Library">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.OutputType" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Mono">
            <summary>
            <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.MSBuildRuntimeType" /> variant.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.native">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. Contents of the native folder</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.none">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. None of the above are used.</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.None">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.PackageReference">
            <summary>
            A <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.RestoreProjectStyle" /> possible value.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.pdb_path_determinism">
            <summary>
            A member in <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.Features" /> for deterministic builds in Roslyn.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.ProjectJson">
            <summary>
            A <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.RestoreProjectStyle" /> possible value.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.queue">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.ErrorReport" />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.runtime">
            <summary>Value for assets metadata (<see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.PrivateAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.IncludeAssets" />, <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Metadatas.ExcludeAssets" />) on a <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.ItemGroups.PackageReference" />. Contents of the lib and runtimes folder and controls whether these assemblies will be copied out to the build output directory</summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Unknown">
            <summary>
            A <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.RestoreProjectStyle" /> possible value.
            This project is either a packages.config project or one that does not use NuGet at all.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.WinExe">
            <seealso cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.OutputType" />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Escape(System.String)">
            <summary>
            Properly escapes a string so that it could be written as element text or attribute value by the means of an XML writer and then interpreted as the <paramref name="raw" /> string by MSBuild. For example, having <c>$(Stuff)</c> in a value would cause it be evaluated to the value of the <c>Stuff</c> property / envvar. Need to get escaped to be read literally by MSBuild.
            MSBuild escaping looks much like URI escaping.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Values.Unescape(System.String)">
            <summary>
            Takes a value as written in MSBuild XML element text or attribute value (after reading with an XML reader) and unescapes to the raw value which would be read by MSBuild.
            MSBuild escaping looks much like URI escaping.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.XItemGroups.None">
            <summary>
            Results in an inclusion of a file with Build Action = None.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity">
            <summary>
              A typed wrapper for the package identity (or a fake identity for a local toolset) to be used as a toolset spec, for
              locating all such places in the solutuion.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity.LocalMachineToolsetSyntheticId">
            <summary>
              To specify a toolset installed locally on the machine, give a <see cref="T:JetBrains.Build.Helpers.Msbuild.MsbuildToolsetPackageIdentity" /> with this ID for the
              package id, and the toolset version for the version.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.#ctor(JetBrains.Lifetimes.OuterLifetime,JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.DisplayName">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.GetEngineVersionAsync">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.GetPathToLoggerAssemblyAsync">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.GetPathToMsbuildExeAsync">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.NetCoreSdkMsbuildToolset.GetRuntimeEntryPointIfApplicableAsync">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers">
            <summary>
            Helps with installing the toolset for loading/building projects.
            Previously, we were making custom MSBuild packages with all the deps including C#, C++ etc support, sufficient for building on a clean machine.
            Now we prefer not to ship the whole toolset alongside the MSBuild, but instead plug in the relevant parts into each of the projects.
            So this has two parts, some recommended MSBuild, and a set of packages to add on per-project basis.
            This class manages knowledge on how we stuff individual projects to make them buildable with an empty (or any installed) MSBuild package.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.GetFullPathWithMacros">
            <summary>
            Like <see cref="!:FileSystemPath.FullPath" />, but might use macros to make stuff moveable on disk if together with the solution.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.PackageExpandedForTargetEntity.#ctor(JetBrains.Util.Storage.Packages.LocalRestoreNugetPackagesSession.RestoredPackage)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.PackageExpandedForTargetEntity.ToString">
            <inheritdoc />
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.MsbuildVoid">
            <summary>
            Now this is a "void" msbuild package which only has the msbuild and none additional stuff like Roslyn or assemblies or PSDK, those should be added per-project.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.ReferenceAssembliesDirMarkerFile">
            <summary>
            Common Targets expect this file to be right under the <see cref="F:JetBrains.Build.Helpers.Msbuild.MsbuildFile.Properties.FrameworkPathOverride" /> dir.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.ReferenceAssembliesRoster">
            <summary>
            RefAsm packages, their origin is either NugetOrg AS IS (if MSFT) or DotNetLibs (if ours).
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RoslynCompilerOfficial">
            <summary>
            Roslyn for compiling projects which do take part in the bootstrap. Can be updated freely.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.PlatformSdk10A">
            <summary>
            Origin in DotNetLibs, taken from a VS installation.
            7.1A and below are a VS-updated version of a full SDK, while 8A and above only have managed tools. For NetFX compilation needs, we take 10A.
            Windows compilations can do without it (take the tools from NetFX dir), while on other OSes we need some of it.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo">
            <summary>
            A set of reference assemblies for use by compiler when building for a certain target framework.
            </summary>
            <param name="Framework"></param>
            <param name="PackageId"></param>
            <param name="ShortId">A short designation, right now mostly used for display and not as a real id.</param>
            <param name="Layout"><inheritdoc cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout"/></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo.#ctor(System.Runtime.Versioning.FrameworkName,JetBrains.Util.Storage.Packages.JetPackageIdentity,System.String,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout)">
            <summary>
            A set of reference assemblies for use by compiler when building for a certain target framework.
            </summary>
            <param name="Framework"></param>
            <param name="PackageId"></param>
            <param name="ShortId">A short designation, right now mostly used for display and not as a real id.</param>
            <param name="Layout"><inheritdoc cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout"/></param>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo.Framework">
            <summary></summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo.PackageId">
            <summary></summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo.ShortId">
            <summary>A short designation, right now mostly used for display and not as a real id.</summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmInfo.Layout">
            <summary><inheritdoc cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout"/></summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout">
            <summary>
            How to scan the refasm package for assemblies to be available as references.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout.ArbitraryAssemblySet">
            <summary>
            The package is not formed as a Package Reference, assemblies are scattered under unrelated folders (often <c>build</c>) nested deeper under folders.
            The recommended approach is to take all assemblies from the package, i.e. <see cref="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.LookInSubfolders"/> + <see cref="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.LookOutsideJetContentItemFolders"/> for assembly set flags, and <see cref="F:JetBrains.Util.Storage.Packages.JetNugetTargetFramework.DontFilter"/> for filtering.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.RefAsmPackageLayout.ValidPackageReference">
            <summary>
            The package looks as if it's a valid Package Reference from one side, and has extra DLLs in it which should not go as assembly references, on another side.
            So you should take it as any reference, <see cref="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.TopLevelJetContentItemsOnly"/> + <see cref="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.PreferReferencesFolder"/> for assembly set flags, and filtering could be done by the target framework for which the reference assemblies are retrieved (or, possibly, unfiltered, since it's a set of refasm for just one fx).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.WindowsPlatformSdkInfo">
            <summary>
            Windows Platform SDKs. These are mostly headers and libs for building for the specific target system.
            Their origins are in DotNet Test Data repo, because they are shared with tests, and because they are HUGE in size.
            See <c>Microsoft SDKs\Windows</c> and <c>Windows Kits</c> dirs.
            </summary>
            <param name="Version">Two-digit version, for 71, 71A is assumed.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.WindowsPlatformSdkInfo.#ctor(JetBrains.Util.Storage.Packages.JetPackageIdentity,System.Int32,System.Int32,System.Nullable{JetBrains.Interop.WinApi.ProcessorArchitecture})">
            <summary>
            Windows Platform SDKs. These are mostly headers and libs for building for the specific target system.
            Their origins are in DotNet Test Data repo, because they are shared with tests, and because they are HUGE in size.
            See <c>Microsoft SDKs\Windows</c> and <c>Windows Kits</c> dirs.
            </summary>
            <param name="Version">Two-digit version, for 71, 71A is assumed.</param>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.WindowsPlatformSdkInfo.Version">
            <summary>Two-digit version, for 71, 71A is assumed.</summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.VcInfo">
            <summary>
            Packages with Visual C++ Compilers (no PSDK). Their origins are in DotNet Test Data repo, mainly because they're HUGE in size, and parts of them were reused in tests.
            </summary>
            <param name="Version">A 3-digit version of the tools, e.g. 120 for VS 12 and 141 for VS 15, 142 for VS 16 %-/.</param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.VcInfo.#ctor(JetBrains.Util.Storage.Packages.JetPackageIdentity,System.Int32,System.Nullable{JetBrains.Interop.WinApi.ProcessorArchitecture})">
            <summary>
            Packages with Visual C++ Compilers (no PSDK). Their origins are in DotNet Test Data repo, mainly because they're HUGE in size, and parts of them were reused in tests.
            </summary>
            <param name="Version">A 3-digit version of the tools, e.g. 120 for VS 12 and 141 for VS 15, 142 for VS 16 %-/.</param>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.VcInfo.Version">
            <summary>A 3-digit version of the tools, e.g. 120 for VS 12 and 141 for VS 15, 142 for VS 16 %-/.</summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.PlatformSdk10A(System.Runtime.Versioning.FrameworkName)">
            <summary>
            7.1A and below are a VS-updated version of a full SDK, while 8A and above only have managed tools. For NetFX compilation needs, we take 10A.
            Windows compilations can do without it (take the tools from NetFX dir), while on other OSes we need some of it.
            </summary>
            <param name="targetfx"></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.FullManagedProjectRoslyn(System.Runtime.Versioning.FrameworkName)">
            <summary>
            The full toolset stuff for a typical managed project compilation.
            Projects which do not need bootstrapping, and might use the latest Roslyn version.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.FullManagedProjectFsharp(System.Runtime.Versioning.FrameworkName,JetBrains.Util.FileSystemPath)">
            <summary>
            The full toolset stuff for a typical managed project compilation.
            Projects which do not need bootstrapping, and might use the FSharp Compiler.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.HackResGenInprocess">
            <summary>
            By default, ResGen is called as an external EXE tool. But on NetCore this is not supported because it's not compatible. Force using the built-in version available in recent MSBuild versions.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.PlatformSpecificNativeCppProject(JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.VcInfo,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Packages.WindowsPlatformSdkInfo)">
            <summary>
            Adds packages for building into native C++.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets.RoslynToolsetLanguageVersions">
            <summary>
            Language versions, as to be given in MSBuild, as supported by the current Roslyn toolset.
            NOTE: might still be having more than one Roslyn in settings here, but actually all bootstrappable projects have switched to SDK and all the other use toolset-version of the roslyn.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Condition">
            <summary>
            Optional. An MSBuild conditional expression.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.DispositionAgainstCommonTargets">
            <summary>
            Whether the entity shoud be applied before or after the common targets.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Name">
            <summary>
            For a prop, goes to the real prop name. Otherwise, just identifies the entity.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Reason">
            <summary>
            Explains why we added this. Helps with tracking the origin. Should get into the final rendering.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.ReferencedPackage">
            <summary>
            Optional. If this entity needs to mention a package, references that package, it will be downloaded and restored and <see cref="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Renderer" /> given its path.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageBuildFile(JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargets,JetBrains.Util.Storage.Packages.JetPackageIdentity,System.String)">
            <summary>
            An import from a package, the build file (single) is looked up in the package's <c>build</c> folder.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageBuildFileFullAndCore(JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargets,System.ValueTuple{JetBrains.Util.Storage.Packages.JetPackageIdentity,JetBrains.Util.Storage.Packages.JetPackageIdentity},System.String)">
            <summary>
            An import from a package, the build file (single) is looked up in the package's <c>build</c> folder.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageDir(System.String,JetBrains.Util.Storage.Packages.JetPackageIdentity,System.String,System.String)">
            <summary>
            A prop ref to a package, path has a forced backslash at the end, as required by MSBuild.
            Takes the root dir of the package.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageDirWhichHasFile(System.String,JetBrains.Util.Storage.Packages.JetPackageIdentity,System.String,System.String)">
            <summary>
            A prop ref to a package, path has a forced backslash at the end, as required by MSBuild.
            Looks for the dir inside the package which has the given file in it.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageSubdir(System.String,JetBrains.Util.Storage.Packages.JetPackageIdentity,JetBrains.Util.RelativePath,System.String)">
            <summary>
            A prop ref to a package, path has a forced backslash at the end, as required by MSBuild.
            Takes just the hardcoded dir out of the package. You can use <see cref="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.NugetPackageDirWhichHasFile(System.String,JetBrains.Util.Storage.Packages.JetPackageIdentity,System.String,System.String)" /> for more flexible connection.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.ExpandEntityValue(JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.PackageLocationResolver,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.GetFullPathWithMacros,JetBrains.Util.ILogger)">
            <summary>
            Prop value for use in proj.
            </summary>
            <param name="entity">Prop parts (strings and nugets).</param>
            <param name="FResolveNupkg">When a nuget is needed, finds the path it's been installed into.</param>
            <param name="FUseBaseDirMacrosForFullPaths">Package gives a full path, shorten this down to well-known base dirs (like home dir) to make the whole setup movable to another location. Or just return the full path.</param>
            <param name="logger"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.FillPropertiesAndInstallPackagesAsync(JetBrains.Lifetimes.Lifetime,System.Collections.Generic.IReadOnlyCollection{JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.Request},System.String,System.String,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger,JetBrains.Util.FileSystemPath,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.GetFullPathWithMacros)">
            <summary>
            Consider calling the non-static version, its main profit is asserting names are unique.
            The main entry to the process. Expands properties from some of the <see cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Sets" />, downloads and expands Nuget packages required for them.
            </summary>
            <param name="lifetime"></param>
            <param name="requests">Which props to expand — and fetch nugets for them.</param>
            <param name="sToolsetFolderId">ID of the folder with toolsets. MUST be unique among calls to this method.</param>
            <param name="sTaskDisplayName">Title for progress messages if dloading toolsets takes a long time.</param>
            <param name="packman">Component.</param>
            <param name="tasker">Component.</param>
            <param name="logger">Logger for messages and errors.</param>
            <param name="dirWithToolset"></param>
            <param name="FUseBaseDirMacrosForFullPaths"></param>
        </member>
        <member name="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.EntityExpanded">
            <summary>
            <see cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity" />, after its value has been expanded for all packages downloaded etc.
            </summary>
            <param name="Condition"><inheritdoc cref="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Condition" /></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.EntityExpanded.#ctor(System.String,JetBrains.Build.Helpers.Msbuild.DispositionAgainstCommonTargets,JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.EntityKind,System.String,System.String,System.String)">
            <summary>
            <see cref="T:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity" />, after its value has been expanded for all packages downloaded etc.
            </summary>
            <param name="Condition"><inheritdoc cref="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Condition" /></param>
        </member>
        <member name="P:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.EntityExpanded.Condition">
            <summary><inheritdoc cref="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.TargetsEntity.Condition" /></summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Msbuild.ToolsetHelpers.Tasks.Request.Expanded">
            <summary>
            This property is filled when the request is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.AssemblyItemInPackage">
            <summary>
            Denotes an assembly item which has been retrieved from a Nuget package.
            Defers loading the actual assembly file content bytes until they're requested.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Nuget.AssemblyItemInPackage.JetBrains#Build#Helpers#Nuget#IAssemblyItemInPackage#PartPaths">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage">
            <summary>
            A special case of an assembly item which has been extracted from a Nuget package, it fast-knows its assembly name, but lazily decompresses the assembly body.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.Package">
            <summary>
            The original package from which the assembly item has been extracted.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Helpers.Nuget.IAssemblyItemInPackage.PartPaths">
            <summary>
            Raw part path in the Nuget, and the effective path (which originally applies to the bin dir).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions">
            <summary>Fast reading of assembly items from nugets. Can fetch names from jet metadata quickly, can read precalculated catalogs if avail, can pre-read assembly names with lazy-loading of the bodies if no jet metadata.</summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.TryReadAssemblyName(JetBrains.Util.Storage.Packages.JetNugetEntry,JetBrains.Metadata.Utils.AssemblyNameReader.AssemblyInfo@)">
            <summary>
             Tries to peek for the assembly name without decompressing the whole item, but just pre-reaing the relevant header bytes.
            </summary>
            <returns><c>True</c> if all OK, <c>False</c> is not fully OK (might be having non-NULL out, but missing partial info).</returns>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.TopLevelJetContentItemsOnly">
            <summary>
            Only files in Jet Content folders (for which <see cref="M:JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants.TryGetJetEffectivePath(JetBrains.Util.RelativePath)" /> is defined, see also <see cref="F:JetBrains.Util.Storage.Packages.JetNugetFilterFlags.JetContentItemsOnly" />), and only either on top-level, or in a folder named against an assembly (so that Fusion resolver can find such DLLs), filtered by known module extensions.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.LookOutsideJetContentItemFolders">
            <summary>
            Takes files outside Jet Content folders (for which <see cref="M:JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants.TryGetJetEffectivePath(JetBrains.Util.RelativePath)" /> is defined, see also <see cref="F:JetBrains.Util.Storage.Packages.JetNugetFilterFlags.JetContentItemsOnly" />).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.LookInSubfolders">
            <summary>
            Takes files from any folders, not only default-Fusion-visible.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.AddFilesWithAnyExtensions">
            <summary>
            Does not limit to module extensions. Tries for assembly names in any files.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.PreferReferencesFolder">
            <summary>
            Historically, we've been taking the <see cref="F:JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants.NugetLibFolder" /> (<c>lib</c>) folder from non-ours packages.
            With newer nugets and multiple supported target frameworks, it is sometimes needed to take the specifically tailored references from the <see cref="F:JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants.NugetRefFolder" /> (<c>ref</c>) folder.
            Still falls back to lib folder if no refs.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.AssemblyFilesSetFlags.PreferRuntimesFolder">
            <summary>
            Historically, we've been taking the <see cref="F:JetBrains.Util.Storage.Packages.SubplatformPackageLayoutConstants.NugetLibFolder" /> (<c>lib</c>) folder from non-ours packages.
            With newer nugets and multiple supported target frameworks, it is sometimes needed to take the specifically tailored assemblies from the <see cref="!:SubplatformPackageLayoutConstants.NugetRuntimeFolder" /> (<c>runtime</c>) folder when running on a specific target system.
            Still falls back to lib folder if no refs.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.PackageAssemblyItems.AssemblyItems">
            <summary>
            The assembly items of the package.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetAssemblyItemsExtensions.PackageAssemblyItems.PartCatalog">
            <summary>
            Optional. The package might have a pre-calculated part catalog for its assemblies.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFile">
            <summary>
              <para>Configuration file for Nuget which tells where to download packages from.</para>
              <para>If not given explicitly, gets autodetected by <see cref="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator" /> from either local path or app-specific locations.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetConfigFileHelpers.LoadNugetSettingsGen4FromFile(JetBrains.Util.Storage.ImmutableFileItem)">
            <summary>
            Loads given Nuget settings in gen2 format.
            </summary>
            <remarks>TODO: not in Util because it does not reference the gen2 nuget yet</remarks>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetConfigFileHelpers.OptionalNugetConfigFile(JetBrains.Util.Storage.Packages.IJetNugetPackageManager)">
            <summary>
            Nuget config file as an optional typed artifact, extracted from the package manager.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetConfigFileHelpers.ReadEnabledPackageSourcesFromNugetConfig(JetBrains.Util.Storage.ImmutableFileItem)">
            <summary>
            Loads the Nuget Config settings file, reads the package sources, gives them in a stable order.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocalPath">
            <summary>
            Input artifact for defining <see cref="T:JetBrains.Build.Helpers.Nuget.NugetConfigFile" /> with outer-world parameters for a build runner, as a path to the disk file.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator">
            <summary>
            Accumulates sources from which Nuget config files might be retrieved. Polymorphic.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator.GetConfigFile(JetBrains.Build.Helpers.Nuget.NugetConfigFileLocator)">
            <summary>
            Uses the polymorphic locator (which might be overridden in Shell etc) to retrieve the config files.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild">
            <summary>
            In-build entities use these pre-configured Nuget package managers to retrieve or locally-install packages during build.
            This version is bound to build-specific Nuget servers.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild.myMemCache">
            <summary>
            Caches the nuget in-mem while it's still in use somewhere. Access must be protected by locking on this instance.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Nuget.NugetPackageManagerForBuild.CleanupExpiredFoldersInCentralCacheAsync(JetBrains.Lifetimes.OuterLifetime)">
            <summary>
            Checks if it's time to clean up expired folders in CC, does so if yes.
            </summary>
            <param name="lifetimeLimit"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged">
            <summary>
            Gives access to .NET Core SDK packaged as a Nuget package.
            Manages retrieval, expansion to the given directory, and locating entry points and tools inside.
            All objects and methods are as lazy as possible, so that no downloading or expanding would happen until required to.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.AsLocalExpandableInto(JetBrains.Util.FileSystemPath)">
            <summary>
            Binds to a specific local expand directory. Does not do any retrieval or expansion immediately.
            NOTE the <paramref name="dirLocalExpandBase" /> is the base dir under which the expansion happens, not necessarily the nuget root.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.DownloadAndExploreAsync">
            <summary>
            Retrieves the package body. Looks for tools. No local expanding yet, bind to a folder with <see cref="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.AsLocalExpandableInto(JetBrains.Util.FileSystemPath)" /> for that.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.DownloadAndExploreCoreAsync(JetBrains.Lifetimes.OuterLifetime,JetBrains.Util.Storage.Packages.JetPackageIdentity,JetBrains.Util.Storage.Packages.IJetNugetPackageManager,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <summary>
            The static implementation method.
            Does the download part, and looks for tools.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.ExploredPackage.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable">
            <summary>
            A lazy wrapper which binds to a specific (lazy) local install dir and can tell about local paths.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.LocalExpandBaseDir">
            <summary>
            The base dir for locally expanding packages, child directories might be created as needed. Do not assume paths, use methods to get specific locations.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.Owner">
            <summary>
            The owning object (not bound to a dir).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.GetDotnetHostPathAsync">
            <summary>
            Local-expands the SDK package into a subfolder under <see cref="F:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.LocalExpandBaseDir" /> and locates the <c>dotnet.exe</c> host under it.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.GetMsbuildDllPathAsync">
            <summary>
            Local-expands the SDK package into a subfolder under <see cref="F:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.LocalExpandBaseDir" /> and locates the <c>msbuild.dll</c> entry point under it.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.ToString">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.WithLocalExpandBaseDir(JetBrains.Util.FileSystemPath)">
            <summary>
            Creates a wrapper fitted for another <see cref="F:JetBrains.Build.Helpers.Runtime.DotNetCoreSdkPackaged.LocallyExpandable.LocalExpandBaseDir" />.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties">
            <summary>
            Emulates TC properties.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesFile(JetBrains.Util.FileSystemPath)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesFile(System.IO.Stream)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesXmlFile(JetBrains.Util.FileSystemPath)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.MockTeamCityProperties.LoadHybridPropertiesXmlFile(System.IO.Stream)">
            <summary>
            Loads a properties file in Java Properties Xml format which has all the kinds of properties in it (config &amp; system), told apart by the prefix.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.PublishArtifact(JetBrains.Util.Storage.ImmutableFileItem,JetBrains.Util.ILogger)">
            <summary>
            Assumes that we are running under a TeamCity Agent.
            Issues a Service Message to StdOut which is registers a file as a build output artifact.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.BuildArtifactInfo.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromBuild">
            <summary>
            Allows to fake running on TC in context of another TC build.
            This artifact specifies the Build ID of some real TC build whose properties would then be downloaded and used as <see cref="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.TeamCityPropertiesMockable" /> artifact.
            Format 1: just the build id string. In this case this is not enough info to make queries, you also need the server URI and credentials, so you must also provide them in a form of a local TC props file <see cref="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromFile" />, which bootstraps the download of your props from build ID <see cref="F:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromBuild.AnotherBuildIdOrUri" /> on that server.
            Format 2: an URI to some build on the server, with credentials also specified on the URI. In this case the server URI and the build ID would be guessed from the URI with some heuristics (works for build view pages), and credentionals are given explicitly in the URI.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromBuild.AnotherBuildIdOrUri">
            <summary>
            The string value of the artifact, see format description for details.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromFile">
            <summary>
            Allows to fake running on TC locally by using a downloaded TeamCity properties file for <see cref="T:JetBrains.Build.Helpers.TeamCity.ITeamCityProperties" />.
            This artifact defines the source for then creating the artifact with the props, <see cref="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.TeamCityPropertiesMockable" />, which should be then used by the build.
            The props lack credentials for accessing TC (wiped out when downloading from TC UI, or outdated when fetching directly from agent because it uses one-time per-build creds). If you want to make queries, those must be given separately.
            Format:
            <c>username:password@fullpath</c>
            <c>fullpath</c>
            Nonprintable characters and <c>:</c>, <c>@</c> MUST be XML-escaped.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromFile.HybridPropsFile">
            <summary>
            Required. Full path to the disk file with hybrid TC properties.
            File format: either XML or Java <c>properties</c> file.
            Hybrid means that it holds all of the system, config and environment properties together in the same file (with approproate property name prefixing). This is important because prefixes must be stripped off correctly.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromFile.Password">
            <summary>
            Optional. Override credentials to give out in the mocked props file for querying into TC.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.MockTeamCityPropsFromFile.UserId">
            <summary>
            Optional. Override credentials to give out in the mocked props file for querying into TC.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.TeamCityPropertiesMockable">
            <summary>
            TeamCity properties, either from the currently running build, or from a local file, or from another TC real-life build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityBuildHelpers.TeamCityPropertiesMockable.#ctor(JetBrains.Build.Helpers.TeamCity.ITeamCityProperties)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.Escape(System.String)">
            <summary>
            Performs TeamCity-format escaping of a string.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.EscapeEx(System.String)">
            <summary>
            Performs TeamCity-format escaping of a string.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.SendMessageCore(System.String,JetBrains.Util.dataStructures.FrugalLocalList{JetBrains.Util.Pair{System.String,System.String}},System.IO.TextWriter)">
            <summary>
            Writes the message.
            Writing MUST occur in one write operation to ensure thread-safety.
            </summary>
            <param name="sMessageName"></param>
            <param name="parameters"></param>
            <param name="writer"></param>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.MessageContext.NamelessValue(System.String)">
            <summary>
            Sends a nameless value.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityMessages.MessageContext.Send">
            <summary>
            Writes the message.
            Writing MUST occur in one write operation to ensure thread-safety.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityNetfxTools.TryGetTeamCityMsbuildLoggerParam(System.Version,JetBrains.Build.Helpers.TeamCity.TeamCityProperties)">
            <summary>
              Gets the parameter value for MSBuild's "/logger:" parameter which connects it to the TeamCity logger, if currently running in a TeamCity build agent.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityNetfxTools.TryGetTeamCityNunitLauncherExe(JetBrains.Build.Helpers.TeamCity.TeamCityProperties)">
            <summary>
              Gets the parameter value for MSBuild's "/logger:" parameter which connects it to the TeamCity logger, if currently running in a TeamCity build agent.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Helpers.TeamCity.TeamCityProperties">
            <summary>
              While running within a TeamCity build, we have three sets of properties available:
              (1) Environment. These are available thru the process environment block.
              (2) System. There's a pointer to the properties file in one of the environment variables.
              (3) Configuration.There's a pointer to the properties file in one of the system properties (see the chain?).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.#ctor">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.CreateFromRunningTeamCity">
            <summary>
            Creates from the currently-running TeamCity instance.
            Throws an exception if there is none. See <see cref="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.AssertIsRunningInTeamCity" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.GetIsRunningInTeamCity">
            <summary>
            Gets whether we're running inside a TeamCity agent process.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.GetIsRunningInTeamCityEx(System.String@)">
            <summary>
            Gets whether we're running inside a TeamCity agent process.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaProperties(JetBrains.Util.FileSystemPath)">
            <summary>
            Reads the native version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaProperties(System.IO.Stream)">
            <summary>
            Reads the native version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaPropertiesXml(JetBrains.Util.FileSystemPath)">
            <summary>
            Reads the XML version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.ReadJavaPropertiesXml(System.IO.Stream)">
            <summary>
            Reads the XML version of the JAVA properties file.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Helpers.TeamCity.TeamCityProperties.TryGetSystemPropertiesFilePath(JetBrains.Util.FileSystemPath@,System.String@)">
            <summary>
            Returns success, a non-empty path in <paramref name="pathIfValid" /> if OK, and the log text in <paramref name="reason" /> in any case.
            </summary>
        </member>
        <member name="T:JetBrains.Build.BuildArtifactAttribute">
            <summary>
            Marks a class which is a build artifact type.
            </summary>
            <remarks>
              <para>Artifact is what you request of the build as its result. There're also intermediate artifacts which are required to produce the final result.</para>
              <para>All of the information required for build steps must be conveyed in the form of artifacts (on which the build step explicitly depends), rather than files on disk, environment variables, or other means of implicit dependencies.</para>
              <para><see cref="T:JetBrains.Build.BuildStepAttribute">Build steps</see> and artifacts together would make the build chain.</para>
            </remarks>
        </member>
        <member name="T:JetBrains.Build.BuildErrorException">
            <summary>
            Formats a build message in a way which is compatible with MSBuild output, which makes it parseable by standard build output parsers (for detecting build errors from text etc).
            </summary>
        </member>
        <member name="M:JetBrains.Build.BuildErrorException.#ctor(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Exception)">
            <param name="kind">Message kind, like "error", "warning", etc. The exception uses "error" by default.</param>
        </member>
        <member name="M:JetBrains.Build.BuildErrorException.FormatBuildMessage(System.String,System.String,System.String,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Formats a build message in a way which is compatible with MSBuild output, which makes it parseable by standard build output parsers (for detecting build errors from text etc).
            </summary>
            <param name="kind">Message kind, like "error", "warning", etc.</param>
        </member>
        <member name="T:JetBrains.Build.BuildPartAttribute">
            <summary>
            Base for all build-related attributes which should be pulled into the part catalog.
            </summary>
        </member>
        <member name="T:JetBrains.Build.BuildStepAttribute">
            <summary>
              <para>Defines a build step by marking either a class or a method.</para>
              <para>A method is the simplest build step: its parameters are inputs it requires, and its return value is the artifacts it produces. To produce more than one artifact, use <see cref="T:System.Tuple" /> family types.</para>
            </summary>
            <remarks>
            While artifacts hold the build data, build steps define the actions which produce artifacts.
            There're no explicit dependencies between build steps. By inputing and outputing artifacts, the steps get dependent on each other via the information they deal with.
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Cardinality">
            <summary>
            Whether the artifact is allowed to have more than one value.
            </summary>
            <remarks>
            Each build artifact is either having only one value, or holding a set of values.
            This property is defined when declaring the artifact, and all of the usages must match the choice.
            You cannot mismatch cardinality when importing an artifact into your build step (even though you might output a single value for supplying a plural artifact).
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction">
            <summary>
            The basic implementation which operates on scattered DLLs, and can be used to locate the engine DLLs for a simple non-shelled build runner. Might use the part catalog as a hint.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.BuildEngineAssemblyWellKnownSimpleName">
            <summary>
            Assume well-known assembly name (once again this is for manual bootstrapping, so will be updated if seen failing).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.CollectBuiltInEngineDlls(JetBrains.Application.Components.Optional{JetBrains.Application.Catalogs.PartCatalog})">
            <summary>
            We're running the Build Runner Core on a set of scattered DLLs, all in one folder.
            This implementation loads the Build Engine DLL by its well-known name and traces all of the DLL refs from it.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.GetEngineAssemblyToStartWith">
            <summary>
            Gets the engine assembly either from the part catalog by the well-known attribute, or by loading the disk assembly by well-known name in the ad-hoc scenario.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.AdHocBuiltInBuildEngineExtraction.GetEngineAssemblyToStartWith(JetBrains.Application.Components.Optional{JetBrains.Application.Catalogs.PartCatalog})">
            <summary>
            Gets the engine assembly either from the part catalog by the well-known attribute, or by loading the disk assembly by well-known name in the ad-hoc scenario.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildEngineImplementationAttribute">
            <summary>
            Marks the class which creates the entry point to the build engine implementation. Helps with locating it in the catalog (and its assembly as well).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildLogRecord.Metadata">
            <summary>
            Record metadata which allows to transfer machine-readable notifications alongside with regular text logging.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildOutputFileArtifact">
            <summary>
            Base class for build artifacts which are designated as build stage output files, and which should be available as individual files on disk after the build runs.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildOutputFileArtifact.TryReadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Checks if the storage has been written with a serialized form of some <see cref="T:JetBrains.Build.Running.BuildOutputFileArtifact" />, and reads the file contents if so.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildOutputPackageFileArtifact">
            <summary>
            Base class for build artifacts which are designated as build stage output files, and which should be available as individual files on disk after the build runs.
            Specifically stores a package.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildOutputPackageFileArtifact.JetBrains#Util#Storage#Packages#IHaveJetNugetPackage#Package">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.RunCommand(JetBrains.Build.Running.BuildRunnerCommandString,JetBrains.Build.Running.BuildRunner.BeforeSessionStartHandler,JetBrains.Build.Running.BuildRunner.SessionStartedHandler)">
            <summary>
            Core impl for the external simple shell-less build runners, like cmdline and TeamCity.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.UploadToBuildLogMessageChannel(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.BuildRunnerSession,System.String)">
            <summary>
            If a message channel is specified in the command string, uploads log records from the session. Returns if the channel has been set up OK. Should not throw out.
            </summary>
            <param name="lifetime"></param>
            <param name="session"></param>
            <param name="sMessageChannelText"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.BeforeSessionStartHandler">
            <summary>
            Called before the session is started (and created).
            </summary>
            <param name="request">The build request to create the session off, partly filled with <see cref="T:JetBrains.Build.Running.BuildRunnerCommandString" />, fill with any additional stuff.</param>
            <returns>Optional. The engine environment, if available.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.SessionStartedHandler">
            <summary>
            Called after the session starts.
            </summary>
            <param name="lifetime">LT of the sessinsession, synced.</param>
            <param name="session">The session object, along with the session's log entries and results.</param>
            <param name="isLogRecordChannelRunning">Whether the build runner command string specified a <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildLogRecordChannel" />, and the channel were set up successfully. Having this OK means we should not log to stdout, and vice versa, if there's no running channel for build log, then it should be rendered to stdout.</param>
            <returns>A task, in case the callee has to complete certain async tasks before shutting down the build completely. This would be waited before the runner returns.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunner.Stub">
            <summary>
            A stub for calling cross-domain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.Stub.#ctor(System.String,System.IntPtr)">
            <summary>
            Runs the core version of the build, without spawning the full shell, with direct stdout (no TC formatting).
            </summary>
            <param name="sBuildRunnerCommandString">Build runner command string in the standard format.</param>
            <param name="pdwRetval">The return value of the run: a pointer to a DWORD where it should be written.</param>
            <returns>Result code, negative for a failure, S_OK if clean, S_FALSE if nearly ok but there were warnings.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.Stub.LoadIntoAppdomainAndRun(System.Collections.Generic.IReadOnlyCollection{JetBrains.Util.Storage.ImmutableFileItem},JetBrains.Build.Running.BuildRunnerCommandString,JetBrains.Util.ILogger)">
            <summary>
            Called in the original appdomain (where the <see cref="T:JetBrains.Build.Running.BuildRunner.Stub" /> type is from the old currently running version). Takes the set of DLLs with the new <see cref="T:JetBrains.Build.Running.BuildRunner.Stub" />, loads into another appdomain, and runs there.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunner.Stub.NoChannelFallbackLogRecordsToStdout(JetBrains.Lifetimes.Lifetime,JetBrains.Diagnostics.LoggingLevel,JetBrains.Build.Running.BuildRunnerSession)">
            <summary>
            When no build log record channel were set up, renders into stdout.
            </summary>
            <param name="lifetime"></param>
            <param name="loglevelMax"></param>
            <param name="session"></param>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerCommandString">
            <summary>
              <para><c>v1</c></para>
              <para>Defines the format of a JSON-formatted string to be passed as the build runner input in a lossless form (while cmdline args on Windows are not lossless for arbitrary text values because of the vage formatting/parsing rules).</para>
              <para>This format MUST NOT be changed as it is used by different-version build engine to talk to each other. Any newer reader MUST correctly read any previous format.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.vCurrent">
            <summary>
            The current version.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings">
            <summary>
            Artifact values in string-serialized form, keyed by artifact names.
            Extends <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> by allowing to specify values for multiple instances of a plural artifact.
            </summary>
            <remarks>
            Implementations should populate artifacts with values from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />; plural artifacts all the values from both sets, specifying values for a singular artifact in more than one set is an error.
            </remarks>
            <since>v2</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings">
            <summary>
            Artifact values in string-serialized form, keyed by artifact names.
            This is the original dictionary which only allows for one value per each name, thus prohibiting assignment of plural artifacts this way. See <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />.
            </summary>
            <remarks>
            Implementations should populate artifacts with values from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />; plural artifacts all the values from both sets, specifying values for a singular artifact in more than one set is an error.
            </remarks>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactsValueSerializer">
            <summary>
            Raw artifact values in a <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> container in a structured storage.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildEngineFiles">
            <summary>
            File paths to build engine files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildLogRecordChannel">
            <summary>
            Optional. Type and name of the message channel (<see cref="T:JetBrains.Util.NamedPipes.IPipeMessageChannel" />) to be used by the running build for sending out build messages as typed data. If missing, would be logged as text to stdout.
            </summary>
            <since>v4</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildScriptBinaryFiles">
            <summary>
            File paths to build script binary files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildScriptSourceFilesOrDirectories">
            <summary>
            Paths to directories with build script source files under them, or to individual build script source files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.BuildStageDisplayName">
            <summary>
            Optional. A custom display name for the build state which would run from this command. If omitted, would present the list of objectives.
            Might be specified to either name the stage in a custom manner, or include stage names of the parent builds if this is not a top-level build.
            </summary>
            <since>v4</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.Objectives">
            <summary>
            Build objective artifact names.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.OutputsDir">
            <summary>
            Optional. If build outputs are file-based, they would be written to this directory as disk files.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.OutputsFile">
            <summary>
            Optional. Build outputs would be written to this file, as a structured storage.
            </summary>
            <since>v1</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.SerializedBuildRequestFile">
            <summary>
            Optional. Full path to the file which has the full build request in the structured storage serialized form. Note that this request is not format-invariant and MUST match exactly the version of the build engine you will be running it with. It must be produced and executed by the same version of the runner.
            </summary>
            <since>v3</since>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerCommandString.v">
            <summary>
            Version marker, for side-by-side formats.
            </summary>
            <since>v1</since>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerCommandString.EnumAllArtifactStrings">
            <summary>
            Enumerates artifact string name-value pairs from both <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactStrings" /> and <see cref="F:JetBrains.Build.Running.BuildRunnerCommandString.ArtifactMultiStrings" />. Names might thus repeat in these pairs.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerEngineType">
            <summary>
            Values for <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.BuildRunnerRequest">
            <summary>
            Default implementation for <see cref="T:JetBrains.Build.Running.IBuildRunnerRequest" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.BuildScriptBinaries">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.BuildScriptBinariesInInputArtifacts">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.BuildScriptSources">
            <summary>
            The source code of the build script which is compiled by the build engine.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.CustomEngineBinaries">
            <summary>
            Custom engine files for the <see cref="F:JetBrains.Build.Running.BuildRunnerEngineType.CustomCompiled" /> choice in <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.EngineChoice">
            <summary>
            If custom engine is selected, <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.CustomEngineBinaries" /> must contain the custom engine assemblies and their satellite files.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifacts">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In serialized form.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifactStrings">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In string form, to be turned into a real artifact with <see cref="T:System.ComponentModel.TypeConverter" /> or <see cref="T:System.Windows.Markup.ValueSerializer" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.Objectives">
            <summary>
            The artifacts to be calculated by the build.
            Build steps will be run so that to trace value from known <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.InputArtifacts" /> and to the <see cref="P:JetBrains.Build.Running.BuildRunnerRequest.Objectives" />.
            Output values in <see cref="T:JetBrains.Build.Running.BuildRunnerResult" /> would contain these objectives, as well as any other artifacts which support serialization.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.BuildRunnerRequest.StageDisplayName">
            <summary>
            Display name for the stage which will be run from this request.
            If omitted, the stage would use the objectives for the name.
            If starting a nested build stage, the runner might also prepend the parent stage name and the index of the child build to the given name.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerRequestEx.CreateStageDisplayName(System.Collections.Generic.IList{JetBrains.Build.Serialization.AssemblyQualifiedTypeName})">
            <summary>
            Gets a non-empty stage name by making from <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" /> if available, or a stub.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerRequestEx.GetOrCreateStageDisplayName(JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Gets a non-empty stage name, <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.StageDisplayName" /> if defined, or makes from <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" /> if available, or a stub.
            </summary>
            <param name="thіs"></param>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerRequestEx.ReadInputArtifactInstancesAsFilesAsync(JetBrains.Lifetimes.Lifetime,System.Collections.Generic.IReadOnlyCollection{JetBrains.Build.Serialization.AssemblyQualifiedTypeName},JetBrains.Build.Serialization.SerializedValuesResolver,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <summary>
            Given artifact names, reads them (in the form of files) from the input artifact instances (not strings).
            This is used for resolving <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinariesInInputArtifacts" /> into actual files as if they were written to <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerRequestEx.WithSourcesFromDisk(JetBrains.Build.Running.IBuildRunnerRequest,JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Adds build script sources from the given list.
            </summary>
            <param name="thіs">The request to be filled.</param>
            <param name="dirRelativeRoot">Base dir for relative paths.</param>
            <param name="dirsOrFilesWithSources">The list of source directories in absolute or relative form, relative are based on the <paramref name="dirRelativeRoot" /> which must be specificed in this case.</param>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerRequestEx.WithSourcesFromDisk(JetBrains.Build.Running.EitherBuildRunnerRequest,JetBrains.Util.FileSystemPath,System.Collections.Generic.ICollection{System.String})">
            <summary>
            Adds build script sources from the given list.
            </summary>
            <param name="thіs">The request to be filled.</param>
            <param name="dirRelativeRoot">Base dir for relative paths.</param>
            <param name="dirsOrFilesWithSources">The list of source directories in absolute or relative form, relative are based on the <paramref name="dirRelativeRoot" /> which must be specificed in this case.</param>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResult.WithAnotherTypeBinder(JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            Uses a more specific type binder, e.g. resolves artifact types in the context of the outer build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResultEx.ExtractAnythingWhichLooksLikeAFile(JetBrains.Build.Running.BuildRunnerResult)">
            <summary>
            Extracts any embedded files from the build runner results.
            </summary>
            <remarks>
            Actually, looks for any serialized records which look like files, and rips them out.
            </remarks>
        </member>
        <member name="M:JetBrains.Build.Running.BuildRunnerResultEx.ExtractBuildOutputFiles(JetBrains.Build.Running.BuildRunnerResult)">
            <summary>
            Extracts any embedded files from the build runner results.
            </summary>
            <remarks>
            Actually, looks for any serialized records which look like files, and rips them out.
            </remarks>
        </member>
        <member name="F:JetBrains.Build.Running.BuildRunnerSession.AsyncBuildResult">
            <summary>
            Gets the build result when it's ready.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepInputInfo">
            <summary>
            Describes a build step input parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepIoInfo">
            <summary>
            Base type for a descriptor for build step's input and output items.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Data.BuildStepIoInfo.Cardinality">
            <summary>
            Whether this item has one or multple values.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.Flags">
            <summary>
            Parameter kinds.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.ItemType">
            <summary>
            For a singular item, same as <see cref="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType" />, unless wrapped in a task or an optional. This would be the most unwrapped item type.
            For a plural item, the <see cref="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType" /> might be the generic specialization of the container type, and this is the actual type of the plural item (container type parameter). Dependencies linking goes over this type.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepIoInfo.RawType">
            <summary>
            The raw type of the parameter — type of the method parameter, or method return value.
            If the method returns a tuple, it gets split before declaring individual output parameters for each member, so this field will be one of the tuple item types.
            For plurals, it is the container type. For wrappings (for tasks and optionals), it's the fully wrapped type.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepOutputInfo">
            <summary>
            Describes a build step output parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepParameterFlags">
            <summary>
            Modifier flags on build step params.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepParameterFlags.IsOptional">
            <summary>
            The parameter is optional.
            It is OK to import NULL or an empty collection if the artifact value is not defined, or a helper is not available.
            Currently, valid on input parameters only.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Data.BuildStepParameterFlags.IsAsync">
            <summary>
            The parameter is a <see cref="T:System.Threading.Tasks.Task`1" /> async parameter.
            Initially implemented for output parameters to support <c>async</c> build steps. Possibly, might make sense to allow async input parameters for higher parallellism.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableClass">
            <summary>
            Build steps implemented as classes.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod">
            <summary>
            Build steps implemented as methods.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Data.BuildStepRunnableMethod.RunAsync_SplitCompoundOutputs(System.Object)">
            <remarks>
            NOTE: must match the logic in <see cref="M:JetBrains.Build.Running.Data.BuildStepRunnableMethod.Ctor_ParseOutputTypes(JetBrains.Application.Catalogs.PartCatalogTypeMember,JetBrains.Build.Running.Data.BuildStepOutputInfo[]@,JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignOutputDelegate[]@,JetBrains.Build.Running.Data.BuildStepParameterFlags@,System.Boolean@)" />.
            </remarks>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignInputDelegate">
            <summary>
            Before reflection-invoking the method, fills its parameters list with the step input values.
            </summary>
            <param name="stepinputs">The input values for the step.</param>
            <param name="index">Current input index.</param>
            <param name="reflectionparams">The parameter array which will be used for the call.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Data.BuildStepRunnableMethod.AssignOutputDelegate">
            <summary>
            After reflection-invoking the method, maps its outputs into the step outputs list.
            </summary>
            <param name="returns">The return values of the method, after splitting any possible tuples.</param>
            <param name="reflectionparams">The parameter array used for the call, might hold the out parameters.</param>
            <param name="index">Current output index.</param>
            <param name="stepoutputs">Assign step output here.</param>
        </member>
        <member name="T:JetBrains.Build.Running.DisableParallelBuild">
            <summary>
            An intrinsic artifact of the build engine. Allows to suppress running build steps/helpers/etc in parallel. Logging from each build entity execution would come out without mixing with other entities.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.DisableParallelBuild.JetBrains#Build#Helpers#General#IBooleanArtifact#Value">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Running.EitherBuildRunnerRequest">
            <summary>
            Adapter for methods which can prepare for either build request interface: <see cref="T:JetBrains.Build.Running.BuildRunnerRequest" /> for early-bound same-version calls, and <see cref="T:JetBrains.Build.Running.BuildRunnerCommandString" /> for loosely-coupled version-independent interfacing.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.EitherBuildRunnerRequest.#ctor(JetBrains.Build.Running.EitherBuildRunnerRequest.GuestRequestInfo@)">
            <summary>Given as the raw resolver (e.g. from a runtime guest-side request). DO NOT use this overload when you have <see cref="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Request" />.</summary>
        </member>
        <member name="M:JetBrains.Build.Running.EitherBuildRunnerRequest.#ctor(JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>Given as a runtime host-side request object.</summary>
        </member>
        <member name="M:JetBrains.Build.Running.EitherBuildRunnerRequest.#ctor(JetBrains.Build.Running.BuildRunnerCommandString)">
            <summary>Given as a serializable request string.</summary>
        </member>
        <member name="F:JetBrains.Build.Running.EitherBuildRunnerRequest.CommandString">
            <summary>
            Given as a serializable request string.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.EitherBuildRunnerRequest.EitherFullArtifactResolver">
            <summary>
            Either taken from <see cref="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Request" /> or <see cref="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Guest" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.EitherBuildRunnerRequest.EitherStringArtifacts">
            <summary>
            Either taken from <see cref="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Request" /> or <see cref="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Guest" />.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.EitherBuildRunnerRequest.Request">
            <summary>
            Given as a runtime host-side request object.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.EitherBuildRunnerRequest.GuestRequestInfo">
            <summary>
            Info that we have on the request when we're just starting up the build guest (and still need to run some operations with it before we load it into the build storage for real).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.FillNestedRequestDelegate">
            <summary>
            You implement this callback to fill the request with your data for the nested build. The request is pre-filled with input artifacts, in object and string form, as taken from the currently running build, so that you could run the nested build on the same inputs (or filter them down).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.IBuildRunnerRequest">
            <summary>
            This is the Build Runner Request object. Describes the inputs, objectives, and engine choice for the run.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries">
            <summary>
              <para>The already-compiled build script in the binary form. Build script is the set of Build Artifacts, Steps and Helpers which are available for execution to obtain the <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" />.</para>
              <para>Supports managed assemblies and Nuget package files as file items.</para>
              <para>This is the part of the build script which is already available in the compiled form and not present in any of the input artifacts in the same time. The build script in source code form should be set to <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptSources" />. If the build script is in the binary form and is also supplied to the build in the form of build input artifacts, you can either put here a copy, or specify the artifact type in <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinariesInInputArtifacts" />.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinariesInInputArtifacts">
            <summary>
              <para>See <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries" />: if build script binaries are also supplied as build input artifacts in <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifacts" />, you can optionally reuse them from input artifacts to avoid passing a second copy of the DLL/Nuget bodeis in <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries" />.</para>
              <para>Specify the type name of the input artifact type.</para>
              <para>The build artifact type must be deserializable from <see cref="T:JetBrains.Build.Running.BuildOutputFileArtifact" /> (in a simple case, derived from it). This is required to get the body without having the artifact type available as the CLR type, because the DLL required to load that type would usually be present inside this same artifact values being loaded.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptSources">
            <summary>
              <para>The source code of the build script which is compiled by the build engine. Build script is the set of Build Artifacts, Steps and Helpers which are available for execution to obtain the <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" />.</para>
              <para>This is the part of the script which you have in source code form. Already compiled DLLs with build entities are set to <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.BuildScriptBinaries" />.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.CustomEngineBinaries">
            <summary>
            Custom engine files for the <see cref="F:JetBrains.Build.Running.BuildRunnerEngineType.CustomCompiled" /> choice in <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.EngineChoice">
            <summary>
            If custom engine is selected, <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.CustomEngineBinaries" /> must contain the custom engine assemblies and their satellite files.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifacts">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In serialized form.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifactStrings">
            <summary>
            Input artifacts whose values are known before the build begins — from external parameters, or from the previous stage. In string form, to be turned into a real artifact with <see cref="T:System.ComponentModel.TypeConverter" /> or <see cref="T:System.Windows.Markup.ValueSerializer" />.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives">
            <summary>
            The artifacts to be calculated by the build.
            Build steps will be run so that to trace value from known <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.InputArtifacts" /> and to the <see cref="P:JetBrains.Build.Running.IBuildRunnerRequest.Objectives" />.
            Output values in <see cref="T:JetBrains.Build.Running.BuildRunnerResult" /> would contain these objectives, as well as any other artifacts which support serialization.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IBuildRunnerRequest.StageDisplayName">
            <summary>
            Display name for the stage which will be run from this request.
            If omitted, the stage would use the objectives for the name.
            If starting a nested build stage, the runner might also prepend the parent stage name and the index of the child build to the given name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.IBuildTaskHost">
            <inheritdoc cref="T:JetBrains.Application.Threading.Tasks.ITaskHost" />
            <remarks>A Build Helper designated task host interface.</remarks>
        </member>
        <member name="T:JetBrains.Build.Running.IBuiltInBuildEngineExtraction">
            <summary>
            An interface for separating Shell logic (which knows the files possibly belonging to the built-in build engine) and the build engine runner which needs the files but does not reference the Shell and all of than infrastructure.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.IIsolatedBuildRunners">
            <summary>
            Entry point interface to the build runner engine (top-level).
            When running inside the build, import the <see cref="T:JetBrains.Build.Running.INestedBuildRunner" /> build helper into your build step or helper to initiate a nested build.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.IIsolatedBuildRunners.BeginRunBuildScript(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.BuildRunnerRequest)">
            <summary>
            Initiates a new build, async.
            </summary>
            <param name="lifetime">Build-limiting lifetime.</param>
            <param name="request">Build request (defines what to build and initial artifacts).</param>
            <returns>Async build result.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.IncrementalBuild">
            <summary>
            Basic control of the Incremental Build mode in the build process.
            Should be OFF on the server to ensure a clean and repeatable build.
            With a local process, allows to speed up things considerably by turning off much of the sandboxing and re-generation.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IncrementalBuild.JetBrains#Build#Helpers#General#IBooleanArtifact#Value">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildAsync(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Runs a nested build, asynchronously. You should await the result in your build step.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="request">Build request.</param>
            <returns>Build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildInheritedAsync(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.InheritFromParentRequest,JetBrains.Build.Running.FillNestedRequestDelegate)">
            <summary>
            Runs a nested build, asynchronously. You should await the result in your build step.
            Allows to inherit parameters from the parent (=current) request to run a variation of the current build.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="inherit">What parameters are to be copied from the parent request.</param>
            <param name="λFillRequest">You implement this callback to fill the request with your data for the nested build. The request is pre-filled with input artifacts, in object and string form, as taken from the currently running build, so that you could run the nested build on the same inputs (or filter them down).</param>
            <returns>Build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildOnParentInputsAsync(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.FillNestedRequestDelegate)">
            <summary>
            Runs a nested build, asynchronously. You should await the result in your build step.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="λFillRequest">You implement this callback to fill the request with your data for the nested build. The request is pre-filled with input artifacts, in object and string form, as taken from the currently running build, so that you could run the nested build on the same inputs (or filter them down).</param>
            <returns>Build result.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.INestedBuildRunner.RunNestedBuildSync(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.IBuildRunnerRequest)">
            <summary>
            Runs a nested build, synchronously, which means that your build step does not proceed until the nested build completes.
            </summary>
            <param name="lifetime">The lifetime for entities returned as a result of the build (as well as for all the build objects). Use local lifetimes if running many builds, to release build results.</param>
            <param name="request">Build request.</param>
            <returns>Build result.</returns>
        </member>
        <member name="F:JetBrains.Build.Running.InheritFromParentRequest.Inputs">
            <summary>
            Build inputs (in serialized and string form) will be copied to the nested request from its parent (current) build.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InheritFromParentRequest.BuildScript">
            <summary>
            Build script (sources and binaries) will be copied to the nested request from its parent (current) build.
            Build script as pointers (type names) to input artifacts will be copied as pointers if the <see cref="F:JetBrains.Build.Running.InheritFromParentRequest.Inputs" /> flag is also included; otherwise, those artifacts would be loaded from the parent request and passed as actual files.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InheritFromParentRequest.BuildEngine">
            <summary>
            Build engine choice, and binaries if custom.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InheritFromParentRequest.Objectives">
            <summary>
            Build objectives will be copied to the nested request from its parent (current) build.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.InputArtifactStringName">
            <summary>
            When specifying input artifact values as strings, gives the name of the artifact to assign the string value to.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InputArtifactStringName.FullOrLocalTypeName">
            <summary>
            Name of the artifact class type, as either a full or a local name (for nested classes, it's just the local name of the nested class, no outers' names added).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.InputArtifactStringName.IsIgnoringNonexistent">
            <summary>
            It's OK of the targeted artifact does not exist. Just skip assigning the value and issue a warning instead of an error.
            Should potentially be used when new artifacts are introduced to the build in some branch, but other branches still don't know about them — this allows the build configuration which is shared by all branches to define the values for the new artifacts without ruining older builds.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.InputArtifactStringName.Parse(System.String)">
            <summary>
            Applies the default convention where a name of the build artifact class which is OK to be missing is followed by a question sign.
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Running.IRunningIsolatedBuildContext">
            <summary>
            Exposes some of the context which is available to the running Isolated Build guest (guest means we're in the guest appdomain context, rather than the side which spins up the isolated build).
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IRunningIsolatedBuildContext.BindTypesInEngineContext">
            <summary>
            Binds type names of artifact types to actual types in the context if this build.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IRunningIsolatedBuildContext.LowLevelBuildLogRecordWriter">
            <summary>
            <para>Gives access to the low-level writer into the build log records stream.</para>
            To be used for relaying records from the nested step ONLY. Any own logging should go to the real logger, so that all of its attached listeners were duly notified.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.IRunningIsolatedBuildContext.RealizedAssemblyItemUnificationSlave">
            <summary>
            Reuses assemblies realized on disk (incl the parent context of this build).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.PlanCore(System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass},JetBrains.Build.Running.Storage.BuildStorageCore)">
            <summary>
            Core planner, creates the step-by-step graph for dependencies.
            </summary>
            <param name="planneds">The build entities which have been hit while tracing undefined outputs back to available inputs (with unreachable optional parts dropped). We have to add specific Create/Delete/Execute steps for them, and impose ordering.</param>
            <param name="artifactsToKeep">These should be available as outputs after the plan is executed, so they should not be deleted.</param>
            <param name="storage">Build entities storage.</param>
            <returns>The plan, with detailed steps and a topo ordering on them.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.FindAndDropArtifactErrors(JetBrains.Build.Running.Storage.BuildStorageCore,System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass})">
            <summary>
            Assert that any of the unresolved artifacts can actually be resolved with some steps.
            </summary>
            <param name="storage"></param>
            <param name="planneds"></param>
            <param name="unresolveds"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.FindBestPath(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Build.Running.Storage.IBuildEntity)">
            <summary>
            Prefers singular and very much prefers non-optional edges in the path.
            </summary>
            <param name="storage"></param>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutionPlanner.TakeDependenciesOfOutputs(JetBrains.Build.Running.Storage.BuildStorageCore,System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildArtifactClass},System.Collections.Generic.JetHashSet{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            For each output, add what it depends on, transitively.
            That would be the largest possible work set, might only get filtered down if there're uncomposable optional subgraphs.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Logger">
            <summary>
            The logger for regular writes.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.myLowLevelWriter">
            <summary>
            Optional lowlevel writer ONLY for passing metadata. All significant messages should go via <see cref="F:JetBrains.Build.Running.Logic.BuildExecutor.Logger" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.BuildExecutionPlan,JetBrains.Build.Running.BuildLogRecord.Writer,JetBrains.Application.Threading.Tasks.ITaskHost,JetBrains.Util.ILogger)">
            <summary>
            </summary>
            <param name="lifetime"></param>
            <param name="storage">Build entity declarations and states, like artifact values and helper instances.</param>
            <param name="plan">The execution plan, a sequence of steps, helper creation/destruction, and artifact value decommissions.</param>
            <param name="writerLowLevel">Optional. The low-level writer to send up metadata on special activities, like passing the nested steps state.</param>
            <param name="tasker">Threading provider.</param>
            <param name="logger">The main logger for submitting progress messages and errors.</param>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.ExecutingItem">
            <summary>
              <para>The currently executing item, if doing one right now. Might get <c>Null</c>s during a run.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.IsRunning">
            <summary>
              <para>High when running.</para>
              <para>You can tell if it's “not yet run” or “have already run” by the value of <see cref="F:JetBrains.Build.Running.Logic.BuildExecutor.PlanPosition" />.</para>
              <para>This property changes free-threadedly, but under an exclusive lock together with other properties.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.PlanPosition">
            <summary>
              <para>The current position in the plan.</para>
              <para>It's <c>0</c> before execution.</para>
              <para>When executing an item, it's equal to the index of the currently executing item, in case of single-threaded execution. In multithreaded case, it's the number of items ever started to execute, and does not directly correspond to the Plan indices.</para>
              <para>After the run, it's the index after the end of the plan (equal to the Count).</para>
              <para>This property changes free-threadedly, but under an exclusive lock together with other properties.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.GetPlannedItemExecutionPriority(JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItem)">
            <summary>
            For the priority queue on planned items. Queue only holds items which do not have interdependencies, so this lines them up for optimal execution.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.ResolveStepInputs(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.IBuildStepRunnable,JetBrains.Build.Running.Storage.EntityValueRetrievalContext,JetBrains.Util.ILogger)">
            <summary>
            Retrieve artifact values from the storage to fill step inputs.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.RunAsync_ReportExecutingItem(JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItem)">
            <summary>
            Advertise the item executed; as with tasks we now have parallel execution, only flash each item at the end of its execution
            </summary>
            <param name="planneditem"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.RunStepAsync(JetBrains.Build.Running.Storage.IBuildStepRunnable,System.Object[],JetBrains.Util.ILogger)">
            <summary>
            Just invokes the step run on step-native data.
            The step MIGHT return unwaited tasks in some of its outputs. The only case when the step MUST wait for the tasks and unwrap the value is when the task covers more than one output, e.g. is a task of a tuple. As the step has to return split outputs, it has to await the task to split them.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildExecutor.SubmitStepOutputsAsync(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Build.Running.Storage.IBuildStepRunnable,System.Object[],JetBrains.Util.ILogger)">
            <summary>
            After a step is executed, assigns its calculated outputs to the artifacts.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildExecutor.Messages">
            <summary>
            Controls formatting of machine readable log messages.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism">
            <summary>
            Whether planned items might be executed in parallel.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism.Sequential">
            <summary>
            The next planned item only starts to execute after the previous completes its task chain. Even if the prev item sits on an await, the next item is not unblocked for execution. This does not prevent individual items from running activities in parallel, even by means of tasks.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Logic.BuildExecutor.Parallelism.Maximum">
            <summary>
            The items are started as soon as all of their inputs are ready. Any number of items.
            The parallelism is then limited by the task scheduler capacity for active threads (by CPU count usually), which does not exactly mean the number of planned items, because if planned items are yielding on an await, a larger number might be in process of execution on the limited pool.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifact(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Catalogs.PartCatalogType,System.Nullable{JetBrains.Application.Catalogs.PartCatalogAttribute},JetBrains.Util.OnError)">
            <summary>
            A helper method to create a build artifact from the specific type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifact``1(JetBrains.Lifetimes.Lifetime)">
            <summary>
            A helper method to create a build artifact from the specific type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.CreateArtifactFromValue``1(JetBrains.Lifetimes.Lifetime,``0)">
            <summary>
            A helper method to create a build artifact from the specific artifact value (singular artifacts only).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.ExtractFromCatalog(JetBrains.Lifetimes.Lifetime,JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Creates artifact and build steps by reading the catalog.
            </summary>
            <param name="lifetime">Lifetime for the entities to be created.</param>
            <param name="catalog"></param>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.GetHiddenImplementations(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            For a type, calculates the set of types hidden by it — base types and <see cref="T:JetBrains.Application.Components.IHideImplementation`1" /> cases.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.TryGetWrapping(JetBrains.Util.dataStructures.Sources.StringSource)">
            <summary>
            Gets the wrapping kind by checking the type, which should be in the form of the open generic definition type (e.g. <c>Full.Type.Name`1</c>).
            Checks the outermost wrapping only.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.TryUnwrap(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Application.Catalogs.PartCatalogType@)">
            <summary>
            Gets the wrapping kind by checking the type, which should be in the form of the open generic definition type (e.g. <c>Full.Type.Name`1</c>).
            Checks the outermost wrapping only.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.WrapWithModifiers(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            For a wrapped item (with an <see cref="T:JetBrains.Application.Components.Optional`1" /> or a <see cref="T:System.Threading.Tasks.Task`1" /> or else of the supported values), wraps up the value to get the required outside type.
            </summary>
            <param name="theValue">The raw item value.</param>
            <param name="flags">Flags on the item, shows which wrappings are legal and expected.</param>
            <param name="pctypeTarget">The type which should be achieved after all of the wrappings are applied. Flags are not enough because the nesting order might vary.</param>
            <param name="onerror"></param>
            <returns>The wrapped object whose type equals to the runtime binding of the <paramref cref="!:pctypeTarget" />.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.StepInputOutputFromParameterType``1(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Data.BuildStepParameterFlags@,System.Boolean)">
            <summary>
            </summary>
            <typeparam name="TBuildStepIoInfo"></typeparam>
            <param name="typeOriginalRaw">The original raw parameter with which we start the resolve.</param>
            <param name="typeCurrent">The current (possibly partially unwrapped) type which we are processing. This will eventually become the Item Type.</param>
            <param name="flags">The flags collected so far.</param>
            <param name="isTuplesAllowed">True for method return values, allows to unwrap multiple params from tuples.</param>
            <returns>A single type for in-params our out-params, and single or multiple for a return value (multiple if it's got a tuple).</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.PluralContainers">
            <summary>
            Implementation support: for read (from out params / retvals), expecting all containers to implement <see cref="T:System.Collections.IEnumerable" />; for write (creating an object to be passed to an in param), expecting <see cref="T:System.Collections.Generic.List`1" /> to implement all of the supported container interfaces, but for the <see cref="T:System.Array" />, which is handled separately.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples">
            <summary>
            Support for tuples which allow passing more than one output type in method's return value.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples.ExtractTypesFromTuple(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            In case a method build step returns multiple artifact types, those might be packed into a tuple. This method returns the list of types to work with.
            </summary>
            <param name="typeMaybeTuple"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Logic.BuildTypeSystemHelpers.Tuples.ExtractTypesFromTuple_SystemTuple(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Either type type parameters, or an empty list if not recognized as a tuple.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Logic.IBuildExecutorDrive">
            <summary>
            An interface for driving a proxy build executor object across the thread or apartment boundary.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BindArtifactTypeByName.#ctor(JetBrains.Build.Running.Storage.BuildStorage,JetBrains.Application.Catalogs.PartCatalog)">
            <summary>
            Sets up type binding which can bind the type by its fullname into another assembly in case it can't be found in its original assembly.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries">
            <summary>
            Stores binary files for use as a custom build engine, or a the pre-compiled build script.
            </summary>
            <remarks>Serves as a typed wrapper for telling apart storages with such data from any other ones.</remarks>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries.Files">
            <summary>
            The binary files for use as a custom build engine, or a the pre-compiled build script.
            Possible file types:
            • A managed assembly.
            • A satellite file.
            • A Nuget package, which is to be extracted to get any of these files yet again.
            • A Structured Storage with a serialized object of type <see cref="T:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries" /> inside, which is to be extracted to get any of these files yet again.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildEngineOrScriptBinaries.IsInStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Gets whether this storage contains this object in a serialized form.
            // TODO: use serialization infrastructure info for this instead
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.BuildResultsRoot">
            <summary>
            Wraps a <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> with previous build results for typed access to a structured storage on disk.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.#ctor(JetBrains.Build.Serialization.SerializedValuesResolver)">
            <summary>
            Creates over an existing resolver.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Creates over a storage with data. As usual, storage must be open while you're accessing this object.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.IsInStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Gets whether this storage contains this object in a serialized form.
            // TODO: use serialization infrastructure info for this instead
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildResultsRoot.OpenStorageWithArtifacts(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Opens the child storage under the stored copy of <see cref="T:JetBrains.Build.Running.Serialization.BuildResultsRoot" /> which can be treated as <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> backend.
            </summary>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildSerialization.StreamName_ArtifactEntityPointer">
            <summary>
            Current artifact type info, keeps just the build entity pointer in text form.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Serialization.BuildSerialization.StreamName_ArtifactProperties">
            <summary>
            Prev-gen artifact type info, in the property class.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Serialization.BuildSerialization.ReadArtifact_EntityPointer(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Util.OnError)">
            <summary>
            Helper for reading the entity pointer to the artifact, which gives the artifact type to create the instance.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Serialization.Build.DataHelpers.ArtifactProperties">
            <summary>
            <see cref="T:JetBrains.Build.Running.Serialization.BuildSerialization" /> serialization helper.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityLifetime">
            <summary>
            Handles importing a lifetime into a build entity.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityLogger">
            <summary>
            Handles importing a logger into a build entity so that the logger were configured with the entity's namespace and type name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildEntityPointer">
            <summary>
            A serializable identification of a build entity.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.myKindIndex">
            <summary>
            An index of the build entity kind in the <see cref="F:JetBrains.Build.Running.Storage.BuildEntityKinds.AllKinds" /> array.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.AssemblyShortName">
            <summary>
              <para>Short name of the assembly which declares the entity.</para>
              <para>Might be empty for some entities because it does not form the strong identity anymore.</para>
              <para>Note: assembly excluded from identity because the same build entity might be compiled either as a part of the build script (into the source build entities assembly) or into the product package (into a product assembly). The entity equality must be retained, even though assembly names do differ.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.BuildEntityPointer.EntityKind">
            <summary>
            Gets the build entity kind of this entity.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.BuildEntityPointer.LocalName">
            <summary>
            Calculates the local name of the type, or type and member.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.MemberName">
            <summary>
              <para>For type-based entities, an empty string.</para>
              <para>For member-based entities, the member name.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildEntityPointer.TypeFullName">
            <summary>
              <para>Full name of the type which declares the entity.</para>
              <para>Should be defined for all entities.</para>
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.Dependencies">
            <summary>
            Dependencies between the items in <see cref="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems" />, as pairs of indices in the <see cref="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems" /> list: the from-index and the to-index along the dependency flow, meaning that the to-item depends on the from-item. As the planned items are sorted in a ready-for-execution order, the second index in any pair is always larger than the first one.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.Objectives">
            <summary>
            The objectives of this plan.
            We're running this execution to obtain the values of these artifacts.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildExecutionPlan.PlannedItems">
            <summary>
            The items planned for execution/creation/deletion.
            Sorted in a safe to execute order.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildExecutorRunResolveContext">
            <summary>
            A context for the whole build run.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStepResolveContext">
            <summary>
            Works for the single build step only.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStepResolveContext.myLifetimeOutsideBody">
            <summary>
            A lifetime which is broader than that passed to the user in the build step body — to make sure all of the stuff created under it outlives any user code.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStepResolveContext.myLifetimeBuildStepBody">
            <summary>
            The lifeitme passed in constructor governs our object. For passing to user, make a nested lifetime.
            Basically equivalent to user's creating a <see cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" /> lifetime, but more handy.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStepResolveContext.#ctor(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.Storage.IBuildStepRunnable,JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext)">
            <summary>
            </summary>
            <param name="lifetime">Lifetime for the context. Created only for the time of the single build step operation.</param>
            <param name="buildstep">The owning step.</param>
            <param name="contextRun">An outer context, for this build executor run.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorage">
            <summary>
            An interface to the runtime storage of build steps and artifacts, as well as their relations (which steps are involved with the given artifact, etc).
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorage.ResolveExact(JetBrains.Build.Running.Data.BuildStepIoInfo)">
            <summary>
            Resolves the input/output item into a type-based entity by its item type, also validating the cardinality.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorage.ResolveExact(JetBrains.Application.Catalogs.PartCatalogType)">
            <summary>
            Resolves a type-based entity by its originating type.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorageCore">
            <summary>
            Backend for <see cref="T:JetBrains.Build.Running.Storage.BuildStorage" /> which calculates and maintains all of the relations.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.BuildHelperHides">
            <summary>
            An outgoing reference means that its origin hides its destination (e.g. inherits).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByBaseType">
            <summary>
            All type-based build entities, by their exact type (as reported by entitry) and all of its assignable-to types, which includes base classes and interfaces. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByLocalName">
            <summary>
            All build entities cached by their local name. Runtime access: free, R/O.
            Note that there's no uniqueness guarantee for the local name really, so there might be more than one result.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheEntityByType">
            <summary>
            All type-based build entities, by their exact type (as reported by entitry). Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheInputsResolution">
            <summary>
            Caches resolved inputs when filling the storage. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.CacheOutputsResolution">
            <summary>
            Caches resolved outputs when filling the storage. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.Dependencies">
            <summary>
            Immediate dependencies between all the build entities.
            Edges go from outputs to inputs. If A depends on B, then it's from A and to B. This might be if step A takes input B, or step B returns output A.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.EntityInstances">
            <summary>
            Stores entity instances. Runtime access: free, R/W, beware concurrent modifications (by the build plan, should not be races on access to instances of the same entity).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.BuildStorageCore.PointerToEntity">
            <summary>
            Looks up entities by entity pointers. Runtime access: free, R/O.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.AddEntities(System.Collections.Generic.IList{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            Adds a pack of (possibly mutually-dependent) entities to the build storage.
            All of the references must resolve either into this group or into the previously-registered entities.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.AddEntities_EnsureCustomObjects(System.Collections.Generic.IList{JetBrains.Build.Running.Storage.IBuildEntity})">
            <summary>
            Makes sure that if the entity being added references the custom object entities, those are actually added to the storage too.
            Emits their entities on demand and adds to the list.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.InitDataFlow_AssertCachedByType(JetBrains.Lifetimes.Lifetime,JetBrains.DataFlow.ICollectionEvents{JetBrains.Build.Running.Storage.IBuildEntity},System.Collections.Generic.IDictionary{JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Storage.IBuildEntityOnType})">
            <summary>
            Type-based access to entities which are type-based.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageCore.IsGoodInputForBuildHelper(JetBrains.Build.Running.Storage.IBuildEntityOnType,JetBrains.Util.OnError)">
            <summary>
            Checks whether what we have resolved is legal to be assigned to a build helper's input.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.BuildStorageCore.EntityDependencyFlags">
            <summary>
            Flags on the entity dependency edges in the <see cref="F:JetBrains.Build.Running.Storage.BuildStorageCore.Dependencies" /> graph.
            Note that flags are not necessarily mutually exclusive because there might be multiple dependencies between two entities, and flags are merged among them.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageInstances.GetRunningInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)">
            <summary>
            Gets an already-created instance.
            This method is kept separated from <see cref="M:JetBrains.Build.Running.Storage.BuildStorageInstances.CreateEntityInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)" /> because an instance is created as a part of the execution plan at a certain iteration, and then must be available when the other iterations need its value.
            </summary>
            <returns>NotNull if throwing.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageInstances.SetEntityInstance(JetBrains.Lifetimes.Lifetime,JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,System.Object,JetBrains.Util.OnError)">
            <summary>
            A pairing method for <see cref="M:JetBrains.Build.Running.Storage.BuildStorageInstances.GetRunningInstance(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Storage.IBuildEntity,JetBrains.Util.OnError)" /> in case you already have an entity instance.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepInputInfo[][],JetBrains.Util.OnError)">
            <summary>
            Resolves an overload list to possible assignable type-based entities.
            </summary>
            <param name="storage"></param>
            <param name="overloads"></param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepInputInfo,JetBrains.Util.OnError)">
            <summary>
            Resolves the input item into a type-based entity assignable to the parameter type, also validating the cardinality.
            NotNull, but reports an error if nothing were found.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveAssignable(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            Resolves type-based entities which are assignable to the requested type.
            NotNull, but reports an error if nothing were found.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveExact(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Build.Running.Data.BuildStepIoInfo,JetBrains.Util.OnError)">
            <summary>
            Resolves the input/output item into a type-based entity by its item type, also validating the cardinality.
            </summary>
            <returns>NotNull in case of a throwing onerror.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.ResolveExact(JetBrains.Build.Running.Storage.BuildStorageCore,JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Util.OnError)">
            <summary>
            Resolves a type-based entity by its originating type.
            </summary>
            <returns>NotNull in case of a throwing onerror.</returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.IsResolveAllowed(JetBrains.Application.Catalogs.PartCatalogType,JetBrains.Build.Running.Storage.IBuildEntityOnType,JetBrains.Util.OnError)">
            <summary>
            Checks if it's valid for an entity to be resolved from the specific type.
            E.g. build artifacts cannot be resolved by an arbitrary base type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageResolve.OverloadResolutionInfo.ToException">
            <summary>
            Builds an exception with an outline with all the information we collected, mostly in the exception data.
            By traversing the data tree, all of the details will be rendered.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageValues.UnwrapValue(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Util.OnError)">
            <summary>
            Unwraps a runtime value possibly wrapped with <see cref="T:JetBrains.Application.Components.Optional`1" /> or <see cref="T:System.Threading.Tasks.Task`1" />. This is for reading the method output values. Sync version.
            </summary>
            <param name="value"></param>
            <param name="flags"></param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.BuildStorageValues.UnwrapValueAsync(System.Object,JetBrains.Build.Running.Data.BuildStepParameterFlags,JetBrains.Util.OnError)">
            <summary>
            Unwraps a runtime value possibly wrapped with <see cref="T:JetBrains.Application.Components.Optional`1" /> or <see cref="T:System.Threading.Tasks.Task`1" />. This is for reading the method output values. Async version: chains waiting for the task result if async.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2">
            <summary>
            Adds a capacity of associating attributes to the graph edges.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.myMapEdgeData">
            <summary>
            Data on the edge.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.AddDependency(`0,`0,`1)">
            <summary>
            Sets edge data replacing the previous one, if there were any. Registers the dependency if the edge does not exist yet.
            </summary>
            <param name="from">From-node of the edge.</param>
            <param name="to">To-node of the edge.</param>
            <param name="edgedata">The new data to associate with the edge.</param>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.AddOrUpdateDependency(`0,`0,`1,System.Func{`1,`1,`1})">
            <summary>
            Sets edge data replacing the previous one, if there were any. Registers the dependency if the edge does not exist yet.
            </summary>
            <param name="from">From-node of the edge.</param>
            <param name="to">To-node of the edge.</param>
            <param name="edgedata">The new data to associate with the edge.</param>
            <param name="FCombineOldAndNew">Optional function to handle assigning data to an edge which already has data on it. Has a chance to combine datas based on whatever rules the graph owner thinks applicable.</param>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.TryGetEdge(`0,`0)">
            <summary>
            Gets the data associated with an edge.
            If there is no such edge in the graph, returns NULL.
            If the edge exists, but has no data associated with it, also returns NULL.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.TryGetEdgeData(`0,`0)">
            <summary>
            Gets the data associated with an edge.
            If there is no such edge in the graph, returns NULL.
            If the edge exists, but has no data associated with it, also returns NULL.
            </summary>
            <param name="from"></param>
            <param name="to"></param>
            <returns></returns>
        </member>
        <member name="F:JetBrains.Build.Running.Storage.DirectedGraphWithEdges`2.EdgeEnd.OtherEnd">
            <summary>
            Some end of the edge, depending of whether we're considering incoming our outgoing edges.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.EntityValueRetrievalContext.#ctor(System.Func{JetBrains.Lifetimes.Lifetime},JetBrains.Build.Running.Storage.IBuildEntity)">
            <summary>
            </summary>
            <param name="FImportLifetime">The lifetime, as it should be imported into the entity. It's a func mostly not because it's a lazy instance, but to outline that it's not a lifetime for this object.</param>
            <param name="entityImportingFor">The entity for which the values are imported in this context.</param>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildArtifactClass">
            <summary>
            Represents a build artifact and its calculated value, if any.
            Mark a class with <see cref="T:JetBrains.Build.BuildArtifactAttribute" /> to let use it as an artifact.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildArtifactClass.ArtifactValues">
            <summary>
              <para>Empty, if the artifact has not been calculated yet by the build.</para>
              <para>A single value, for a fully-defined <see cref="F:JetBrains.Build.Cardinality.Singular" /> artifact.</para>
              <para>One or more values, for a (partially or fully) defined <see cref="F:JetBrains.Build.Cardinality.Plural" /> artifact.</para>
              <para>New values might be added, but never removed.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildArtifactClass.Cardinality">
            <summary>
              <para>Whether the artifact value is singular or plural.</para>
              <para>If your data is a list of values, there's a choice: either define a singular artifact which holds the complete list inside, or a plural artifact class whch holds just one item, and there'll be a set of them during the build. The determination is whether different build steps might contribute to the list: a singular artifact can only be produced once by a single build step, and values for a plural artifact will be collected from all the producing steps.</para>
              <para>A singular artifact is imported just with the type of the artifact class. A plural artifact is imported as a <see cref="T:System.Collections.Generic.IEnumerable`1" />, <see cref="T:System.Collections.Generic.ICollection`1" /> or <see cref="T:System.Collections.Generic.IList`1" /> of the artifact class type.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildCustomObject">
            <summary>
            An entity for importing dynamically-created objects into other build entities, such as they're specific to those entities, such as lifetime, logger, etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntity">
            <summary>
            Common base for build-related entities which could have dependencies on each other etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityEx.EntityKindAndNameString">
            <summary>
            A delay-rendered string value.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityEx.EntityPointerKindAndNameString">
            <summary>
            A delay-rendered string value.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityInstanceResolveContext">
            <summary>
            Gets or creates instances for build entities in a specific context.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityOnMember">
            <summary>
            Common base for a build entity which is produced out of a type member, and can be uniquely identified by that type member.
            An example is a method-based build step.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildEntityOnMember.Member">
            <summary>
            The type member on which this build entity is based on.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildEntityOnType">
            <summary>
            Common base for a build entity which is produced out of a type, and can be uniquely identified by that type.
            Most entities are, but for maybe method-based build steps.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildEntityOnType.Type">
            <summary>
            The type on which this build entity is based on.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildHelper">
            <summary>
              <para>A build helper class, which could be imported into a build step as an input parameter.</para>
              <para>If not marked with the <see cref="F:JetBrains.Build.BuildHelperFlags.IsSingleton" /> flag, which is the preferrable default, is a throw-away class which can be created on-demand (maybe in multiple instances) and discarded at any time. These don't have to be serializable because a new instance can be created at any moment.</para>
              <para>If <see cref="F:JetBrains.Build.BuildHelperFlags.IsSingleton" />, the one and only instance might exist, and it should be serializable to support suspended builds.</para>
              <para>Free-threaded access possible.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildHelper.InputsChoice">
            <summary>
            Input parameters from various constructor overloads.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.IBuildHelper.CreateInstance(System.Collections.Generic.IList{JetBrains.Build.Running.Data.BuildStepInputInfo},System.Object[])">
            <summary>
            Creates an instance of the build helper object.
            </summary>
            <param name="inputsChosen">The inputs set, out of <see cref="P:JetBrains.Build.Running.Storage.IBuildHelper.InputsChoice" />, chosen for the instantiation. This tells which .ctor to use.</param>
            <param name="inputvalues">Values for the .ctor input parameters.</param>
            <returns>The instance.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IBuildStepRunnable">
            <summary>
            Represents a build step which can be run if we known its inputs and need to learn its outputs.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs">
            <summary>
            Input parameters.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs">
            <summary>
            Output parameters.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Running.Storage.IBuildStepRunnable.RunAsync(System.Object[])">
            <summary>
            Runs the build step implementation.
            </summary>
            <param name="inputs">Inputs. Indices correspond to the <see cref="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Inputs" /> collection.</param>
            <returns>Outputs. Indices correspond to the <see cref="P:JetBrains.Build.Running.Storage.IBuildStepRunnable.Outputs" /> collection.</returns>
        </member>
        <member name="T:JetBrains.Build.Running.Storage.IHaveCardinality">
            <summary>
            Tells whether it's singular or plural.
            Exact semantic depends on the object it's applied to.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Running.Storage.IHaveCardinality.Cardinality">
            <summary>
            Tells whether it's singular or plural.
            Exact semantic depends on the object it's applied to.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel">
            <summary>
            Writes and reads build message records on some channel.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel.ChannelName.ChannelEngine">
            <summary>
            Which channel engine handles communication and how to open the media.
            Must not contain slashes.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel.ChannelName.InstanceName">
            <summary>
            Name of the instance of the channel in this specific channel engine.
            Might contain slashes.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel.ChannelName.Version">
            <summary>
            Version of the data serialization or channel engine or both.
            Must not contain slashes.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Engine.IsolatedBuild.BuildLogRecordChannel.ChannelName.ToString">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName">
            <summary>
            Represents an assembly-qualified type name with a name of a member in the type.
            Optionally supports loose-matching with some allowance for a difference in version numbers (expected with assembly binding redirections in effect).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.EqualityByLooseVersionMatch">
            <summary>
            Requires a match in Major.Minor, but allows a difference in subsequent version components.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.EqualityByTypeFullNameOnly">
            <summary>
            Ignores the assembly name completely when checking for type equality.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.AssemblyName">
            <summary>
            Gets or sets the assembly name of the assembly containing the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.MemberName">
            <summary>
            Gets or sets the name of the member identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeFullName">
            <summary>
            Gets or sets the full name of the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeLocalName">
            <summary>
            Gets the local name of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.TypeNamespace">
            <summary>
            Gets the namespace of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeMemberName.AsBareAssemblyName">
            <summary>
            Returns a copy which has only the bare assembly name, without any version, culture, or public key specifications on it.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Build.Serialization.AssemblyQualifiedTypeName">
            <summary>
            Represents an assembly-qualified type name.
            Optionally supports loose-matching with some allowance for a difference in version numbers (expected with assembly binding redirections in effect).
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.EqualityByLooseVersionMatch">
            <summary>
            Requires a match in Major.Minor, but allows a difference in subsequent version components.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.EqualityByTypeFullNameOnly">
            <summary>
            Ignores the assembly name completely when checking for type equality.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.AssemblyName">
            <summary>
            Gets or sets the assembly name of the assembly containing the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeFullName">
            <summary>
            Gets or sets the full name of the type identified by this object.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeLocalName">
            <summary>
            Gets the local name of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.TypeNamespace">
            <summary>
            Gets the namespace of the type, if the type name is set.
            Calculated.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.AsBareAssemblyName">
            <summary>
            Returns a copy which has only the bare assembly name, without any version, culture, or public key specifications on it.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRealPartType(JetBrains.Application.Parts.IPartCatalogueFactory)">
            <summary>
            Binds to a fully-initialized part catalog type.
            This requires binding to a runtime type currently, so the assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRealPartType2(JetBrains.Application.Parts.IPartCatalogueFactory)">
            <summary>
            Binds to a fully-initialized part catalog type.
            This requires binding to a runtime type currently, so the assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.AssemblyQualifiedTypeName.ToRuntimeType(JetBrains.Build.Serialization.IBindTypeByName,JetBrains.Util.OnError)">
            <summary>
            Binds to the runtime type.
            The assembly name must resolve in the current appdomain.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.BindIntoLoadedAssemblies">
            <summary>
            Considers assemblies loaded into the current appdomain for remapping by full type name.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.BindTypeByName">
            <summary>
            Default impl. Just looks up the runtime type.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.BindTypeByName.Default">
            <summary>
            The default instance of the default binder.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.BindTypeByNameEx.HintBindingIfApplicable(JetBrains.Build.Serialization.IBindTypeByName,JetBrains.Build.Serialization.AssemblyQualifiedTypeName,JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            Hints possible binding if (a) the binder is a hinted binder, and (b) the two types have the same full name (but possibly not the same assembly).
            </summary>
            <param name="binder"></param>
            <param name="redirectFrom"></param>
            <param name="redirectTo"></param>
        </member>
        <member name="M:JetBrains.Build.Serialization.BindTypeByNameHinted.AddHintFromTypeFullName(JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            When you only know the target type, adds a hint for that type's full name (essentially, tells in which an assembly to look for such a name).
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.DataHelpers.InstanceTypeInfo">
            <summary>
            <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> serialization helper.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.IBindTypeByName">
            <summary>
            Binds a type upon deserialization when only its assembly-qualified name is known.
            Allows to apply redirection rules, such as changing the version in the assembly full name, or even redirecting assemblies when dealing with build artifacts in script/comnpiled transition.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.IBindTypeByName.Equality">
            <summary>
            Gets the equality comparer for comparing type names before they're bound, assuming that two different type names that bind into the same type should be deemed equal.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.IBindTypeByName.Bind(JetBrains.Build.Serialization.AssemblyQualifiedTypeName,JetBrains.Util.OnError)">
            <summary>
            Binds the type to runtime type by its name.
            This should perform two things:
            (1) Load the appropriate assembly, if needed.
            (2) Loosely bind by partial type name match (e.g. if redirecting to another assembly name), if required.
            </summary>
            <param name="name">Type name. Some binders are not looking at the assembly name, for example.</param>
            <param name="onerror"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Build.Serialization.ISerializedValuesResolverLoader.Resolver">
            <summary>
            Gets or lazy-loads the resolver object.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver">
            <summary>
            Stores a list of values.
            Can give out values by base types / interfaces.
            Can serialize them into a storage.
            Upon deserialization, does not unpack the actual values until the instance is actually requested, which allows to install the
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.myMapTypeFullNameToExactInstances">
            <summary>
            Looks up types by their type full name (no assembly name involved). This way we can avoid asking the binder to bind our types, because the exact type is already known from the request. Does not work for bases and interfaces, though.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.myMapTypeToAssignableInstances">
            <summary>
            Looks up types by their AQN (matching rules depend on the binder) or by AQNs of their bases and interfaces, hence “assignable”.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.#ctor(JetBrains.Lifetimes.Lifetime,System.Collections.Generic.IEnumerable{System.Object},JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            </summary>
            <param name="lifetime">The lifetime for this object, AND the lifetime during which we can still access the <paramref name="storage" /> for on-demand deserialization of the actual values. This also applies to all the storages added later with <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)" /> calls.</param>
            <param name="instances">Object instances to add. Same as calling <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.Register(System.Object)" />.</param>
            <param name="storage">The serialized storage. MUST be available for reading throughout the whole <paramref name="lifetime" />. Same as calling <see cref="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)" /> later.</param>
            <param name="typebinder">Knows how to bind the types written in the storage to actual runtime types. In case there might be multiple alternatives it's critical to match the specific type expected for the usage, e.g. in case of build artifacts.</param>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.AsContainerForChaining">
            <summary>
              <para>Exposes this <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> with the <see cref="T:JetBrains.Application.Components.IComponentContainer" /> interface suitable for chaining from child containers.</para>
              <para>If you then use the standard <see cref="!:ComponentContainerEx.ChainTo" /> function, it will prevent NULL <see cref="T:JetBrains.Application.Components.Optional`1" /> instances from leaking along the chain (which prevents looking them up along the chain as the value is found, even though it holds NULL).</para>
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(System.Func{JetBrains.Lifetimes.Lifetime,JetBrains.Util.Storage.StructuredStorage.IStructuredStorage})">
            <summary>
            Loads serialized instances from a storage.
            As the storage object must be available thru the whole lifetime of this instance, simplifies tracking by giving you the lifetime to load the storage in.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.LoadFromStorage(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage)">
            <summary>
            Loads serialized instances from a storage.
            The provided storage object must be available thru the whole lifetime of this instance. Use an overload with lifetime if not sure.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Register(System.Object)">
            <summary>
            Registers a new instance in this resolver.
            Fluent.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Resolve(System.Type)">
            <summary>
            Resolves the component by its type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.Resolve``1">
            <summary>
            Resolves the component by its type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultiple``1">
            <summary>
            Resolves the components list by its type.
            It is an error if there are no components of such type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultiple(JetBrains.Build.Serialization.AssemblyQualifiedTypeName)">
            <summary>
            For the <see cref="T:JetBrains.Application.Components.EnumerableValueResolver" />.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveMultipleOrEmpty``1">
            <summary>
            Resolves the components list by its type.
            It is an error if there are no components of such type.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.ResolveCore_Wrappers``1(``0,JetBrains.Application.Components.ValueResolveRequester.RequestRoute)">
            <summary>
            Handles wrapping types like <see cref="T:JetBrains.Application.Components.Optional`1" />, <see cref="T:System.Lazy`1" />, etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.Instance">
            <summary>
            A single object instance in this container, either coming as a runtime object instance, or being deserialized from the container.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfosStreamV3">
            <summary>
            V3 format: a single SEXP file with type infos for ALL instances, and per-instance substorages hold right the value without an intermediate level.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfoStreamV1">
            <summary>
            V1 format: each instance has its own storage with the name info XAML stream and a substorage for the value itself.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameInfoStreamV2">
            <summary>
            V2 format: same as V1, but SEXP not XAML, for faster deserialization and to avoid setting up XAML infrastructure on load.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.NameValueStorageV1V2">
            <summary>
            For V1 and V2 format, a substorage with the value.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.SerializedValuesResolver.Instance.SerializedInstanceRecord">
            <summary>
            Serialization-specific accessor, which allows restored instance to keep FLList all around.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.LiveInstance">
            <summary>
            An instance which got the real live value as an input.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance">
            <summary>
            An instance restored from the persistent storage.
            </summary>
        </member>
        <member name="F:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance.myActualFormat">
            <summary>
            V1, V2, V3 fmt based on how we deserialized.
            </summary>
        </member>
        <member name="M:JetBrains.Build.Serialization.SerializedValuesResolver.RestoredInstance.#ctor(JetBrains.Util.Storage.StructuredStorage.IStructuredStorage,JetBrains.Build.Serialization.IBindTypeByName)">
            <summary>
            V1, V2 deserialization ctor.
            </summary>
        </member>
        <member name="P:JetBrains.Build.Serialization.SerializedValuesResolver.SelfComponentContainer.JetBrains#Application#Components#IComponentContainer#Threading">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Build.Serialization.SerializedValuesResolver.SelfValueResolveContext">
            <summary>
            Exposes the <see cref="T:JetBrains.Build.Serialization.SerializedValuesResolver" /> APIs as the <see cref="T:JetBrains.Application.Components.IValueResolveContext" /> interface, for calling the standard value resolvers for Optional, Lazy, Enumerable, etc.
            </summary>
        </member>
        <member name="T:JetBrains.Build.Serialization.StringSerializationHelper">
            <summary>
            Implements string serialization via a <see cref="T:System.Windows.Markup.ValueSerializer" /> or a <see cref="T:System.ComponentModel.TypeConverter" /> attached to the class.
            </summary>
        </member>
    </members>
</doc>
