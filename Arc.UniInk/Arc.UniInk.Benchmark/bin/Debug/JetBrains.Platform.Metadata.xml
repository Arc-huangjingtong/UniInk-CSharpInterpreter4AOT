<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Platform.Metadata</name>
    </assembly>
    <members>
        <member name="F:JetBrains.Metadata.Access.CorFileFlags.ffContainsMetaData">
            <summary>
            Indicates that the file is not a resource file
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.CorFileFlags.ffContainsNoMetaData">
            <summary>
            Indicates that the file, possibly a resource file, does not contain metadata
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.CodedTokenTables.ourCodedTokenBits">
            <summary>
            Contains number of bits to represent coded token.
            Indexed by number of possible values in given coded token type
            </summary>
            <remarks>
            Number of bits in coded token tag for a coded token that refers to n tables
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.EncodedTokenType">
            <summary>
            Type of the encoded token in the CIL tables
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes">
            <summary>
            Bits for heap offset/index sizes
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.HeapString4">
            <summary>
            If flag is set, #Strings heap offsets are stored as 4 bytes; 2 otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.HeapGuid4">
            <summary>
            If flag is set, #GUID heap indices are stored as 4 bytes; 2 otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.HeapBlob4">
            <summary>
            If flag is set, #Blob heap offsets are stored as 4 bytes; 2 otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.Padding">
            <summary>
            Tables can be created with an extra bit in columns, for growth
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.DeltaOnly">
            <summary>
            If set, only deltas were persisted
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.ExtraData">
            <summary>
            If set, schema persists an extra 4 bytes of data
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.HeapOffsetSizes.HasDelete">
            <summary>
            If set, this metadata can contain _Delete tokens
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess">
            <summary>
            PE file metadata reader
            </summary>
            <remarks>
            Has faster implementation of some methods
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Access.ILReader.ILReaderMetadataAccess.PeFile">
            <remarks> Returns null for metadata only stream</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ILReaderMetadataProvider">
            <summary>
            Provides metadata interface for various sources (ILReader version, only managed code)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.ILReader.ITableReader">
            <summary>
            Metadata tables reader 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadString">
            <summary>
            Read offset to the #Strings heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadGuid">
            <summary>
            Read index to the #GUID heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.ITableReader.ReadBlob">
            <summary>
            Read offset to the #Blob heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.MetadataAccessBase.GetInitialEntityValue(JetBrains.Metadata.Access.MetadataToken,JetBrains.Metadata.Access.MetadataTokenType,System.Boolean,System.Int32,System.Int32,System.Int32,JetBrains.Metadata.Access.MetadataTokenType[])">
            <remarks>
            Rows in metadata delta TypeDef, MethodDef, etc. tables have 0 (null) values for MethodList, FieldList, ParamList and other *List
            =>
            need to use the corresponding values from the original (initial) table
            =>
            use GetInitialEntityValue instead of GetEntityValue for *List columns
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Access.ILReader.MetadataAccessBase.SortedByPrimaryKeyTables">
            <summary>
            ECMA-335 p.22
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ILReader.PdbStream.Signature">
            <summary>
            Portable PDB Signature should match ((DebugInfo7)DebugDirectory.Entry.GetEntry()).Signature in PE file
            (Version (DebugDirectory.Entry) Major=any, Minor=0x504d. The Age shall be 1.)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ILReader.PdbStream.TimeDateStamp">
            <summary>
            Portable PDB TimeDateStamp should match DebugDirectory.Entry.DateTimeStamp in PE file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ILReader.StreamsManager.IsMinimalDelta">
            <summary>
            True if the metadata stream has minimal delta format.
            Used for EnC.
            </summary>
            <remarks>
            The metadata stream has minimal delta format if "#JTD" stream is present.
            Minimal delta format uses large size (4B) when encoding table/heap references.
            The heaps in minimal delta only contain data of the delta, there is no padding at the beginning of the heaps that would align them with the original full metadata heaps.
            (#GUID heap accumulates - previous heap is copied to the next generation <see cref="M:System.Reflection.Metadata.Ecma335.MetadataAggregator.GetGenerationHandle(System.Reflection.Metadata.Handle,System.Int32@)"/>???)
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.ILReader.TableManager.TableReader.ReadCodedToken(JetBrains.Metadata.Access.ILReader.EncodedTokenType)">
            <summary>
            Read coded (multi targeting) token
            </summary>
            <param name="type">Set of the token targets</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Metadata.Access.TypeDefProperties">
            <summary>
            Structure for storing typedef properties
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.FullName">
            <summary>
            Gets fully qualified type name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.Base">
            <summary>Gets base token</summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeDefProperties.TypeDefFlags">
            <summary>Gets typedef flags</summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.TypeRefProperties">
            <summary>
            Structure for storing typeref properties
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.ResolutionScope">
            <summary>
            Gets type reference resolution scope
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.NamespaceName">
            <summary>
            Gets references type namespace name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.TypeName">
            <summary>
            Gets references type name (without namespace)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.TypeRefProperties.FullName">
            <summary>
            Gets references type name (namespace_name.type_name)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParameterProperties.Name">
            <summary>
            Gets name of generic parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParameterProperties.ParamIndex">
            <summary>
            Gets generic parameter index
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParameterProperties.Owner">
            <summary>
            Gets owner token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParameterProperties.GenericParameterAttributes">
            <summary>
            Gets generic param attributes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.GenericParameterProperties.GenericParameterConstraints">
            <summary>
            Gets generic parameter constraints
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.CustomAttributeProperties.Type">
            <summary>
            .ctor method token
            (the owner of that constructor method is the type of the custom attribute)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.MemberReferenceProperties">
            <summary>
            Stores properties of a member reference
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.AssemblyRefProperties">
            <summary>
            Stores properties of a assembly reference
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.IMetadataAccess">
            <summary>
            Interface for accessing metadata in abstract way
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.MetadataProvider">
            <summary>
            Metadata provider used to create metadata access
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetAssemblyInfo">
            <summary>
            Gets assembly info interface if available
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.Id">
            <summary>
            Gets unique MVID and size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.ModuleName">
            <summary>
            Gets ModuleName
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.TargetPlatform">
            <summary>
            Gets target platform
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetModuleRefs">
            <summary>
            Gets array of all available module references
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeDefs">
            <summary>
            Gets array of all available typedef tokens
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeDefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a typedef
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeRefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a typeref
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeSpecBlob(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for typeSpec
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetStandaloneSignatureBlob(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for StandAloneSig
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodSpecProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets blob for typeSpec
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindMethodSpecs(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Find all MethodSpec records for concrete method def or ref
            </summary>
            <param name="methodDefOrRef">MethodDefOrRef token</param>
            <returns>Array of corresponding MethodSpec tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetGenericParameters(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of generic type parameters for the specified owner
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetGenericParameterProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a generic type parameter
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetGenericParameterConstraintProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a generic parameter constraint
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetInterfaceImplementations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets InterfaceImpl tokens for specified type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodImpls(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets MethodImpl tokens for specified type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetInterfaceImplementationProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of an interface implementation
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMemberName(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets member (field, method, event or property) name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetFields(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type fields
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetFieldProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets field properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethods(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type methods
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameters(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method parameters
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameterByIndex(JetBrains.Metadata.Access.MetadataToken,System.UInt32)">
            <summary>
            Gets parameter by its index in method signature
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetParameterProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets parameter properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetPropertyProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets property properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEvents(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of type events
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEventProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets event properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEnclosingType(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets enclosing type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributes(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of custom attributes attached to the specified entity
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributeProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets custom attribute properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomAttributeTypeName(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets custom attribute type fully qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetModuleRefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a module reference
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMemberReferenceProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a member reference
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetAssemblyRefProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a member reference
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetManifestResourceProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets properties of a manifest resource
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodBodyToDeclarations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method implementation map (method body -> method declarations array; from MethodImpl table) for a type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetImplementedMethods(JetBrains.Metadata.Access.MetadataToken,JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets tokens of declarations of [explicitly] implemented methods
            </summary>
            <remarks>
            GetMethods(typeToken).Contains(methodBodyToken)
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetPInvokeProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets PInvoke dispatch information for method 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetImplMapProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets ImplMap information
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEncLogProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets Edit and Continue Log information
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEncMapProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets Edit and Continue Map information
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMarshalSpec(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets marshalling specification for field or parameter if available, null if not
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeRefs">
            <summary>
            Gets array of type references from the assembly
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetClassLayout(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets class layout if specified, null if not
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetDeclSecurity(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Get DeclSecurity rows
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetDeclSecurityProperties(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Get DeclSecurity properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetDeclSecurityTypeNames(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Get DeclSecurity attribute types names (extracted from blob)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindTypeRef(JetBrains.Metadata.Access.MetadataToken,System.String)">
            <summary>
            Finds a record in TypeRef table
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetTypeSpecs">
            <summary>
            Enumerates all TypeSpec records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodSpecs">
            <summary>
            Enumerates all MethodSpec records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetStandAloneSigs">
            <summary>
            Enumerates all StandAloneSig records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethods">
            <summary>
            Enumerates all MethodDef records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetManifestResources">
            <summary>
            Enumerates all ManifestResource records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMemberRefs">
            <summary>
            Enumerates all MemberRef records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.FindMemberRefs(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Finds all MemberRefs owned by type <paramref name="typeToken"/>
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.NestedTypeMap">
            <summary>
            Nested-relation between types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataAccess.TypeName2TokenMapping">
            <summary>
            Mapping between qualified type names and their typedef tokens
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodRvaMap">
            <summary>
            Returns code RVA for every method in assembly.
            Offset in array corresponds to method RID (at zero position - RID 1)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEmbeddedResourceOffset(System.Int64)">
            <summary>
            Returns embedded resource offset (in PE file) by resource offset from
            metadata table or -1 if not available
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetFields">
            <summary>
            Enumerates all Field records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetProperties">
            <summary>
            Enumerates all Property records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEvents">
            <summary>
            Enumerates all Event records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetImplMaps">
            <summary>
            Enumerates all ImplMap records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEncLogs">
            <summary>
            Enumerates all Edit and Continue Log records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetEncMaps">
            <summary>
            Enumerates all Edit and Continue Map records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetDocuments">
            <summary>
            Enumerates all Document records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetMethodDebugInformations">
            <summary>
            Enumerates all MethodDebugInformation records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetLocalScopes">
            <summary>
            Enumerates all LocalScope records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetScopeVariables(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of scope local variables
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetScopeConstants(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets array of scope local constants
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetImportScopes">
            <summary>
            Enumerates all ImportScope records
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAccess.GetCustomDebugInformations">
            <summary>
            Enumerates all CustomDebugInformation records
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.Token">
            <summary>
            Exported type token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.TypeName">
            <summary>
            The name of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.TypeNamespace">
            <summary>
            The namespace of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.ClrName">
            <summary>
            The FQN of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.Implementation">
            <summary>
            An mdFile, mdAssemblyRef, or mdExportedType metadata token that contains or allows access to the properties of the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.TypeDef">
            <summary>
            mdTypeDef token that represents a type in the file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.ExportedTypeProperties.ExportedTypeFlags">
            <summary>
            flags that describe the metadata applied to the exported type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.Name">
            <summary>
            The simple name of the file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.Token">
            <summary>
            Token of file reference
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.FileReference.FileFlags">
            <summary>
            flags that describe the metadata applied to a file
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.IMetadataAssemblyInfo">
            <summary>
            Provides access to assembly metadata info
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetAssemblyName">
            <summary>
            Gets full assembly name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetReferencedAssembliesNames">
            <summary>
            Gets names of referenced assemblies
            (from AssemblyRef table)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetReferencedModulesNames">
            <summary>
            Gets names of referenced modules
            (from ModuleRef table)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetExportedTypesFromOtherModules">
            <summary>
            Get ExportedType table
            (types, defined within OTHER modules of THIS assembly)
            ExportedType table stores TypeDef row numbers of all types that are marked public in other modules that this Assembly comprises
            </summary>
            <remarks>
            Do not confuse this method with System.Reflection.Assembly.GetExportedTypes() method
            (which returns public types defined in this assembly that are visible outside the assembly)
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetReferencedFiles">
            <summary>
            files referenced in the current assembly manifest
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataAssemblyInfo.GetToken">
            <summary>
            Gets assembly token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataProvider.DisposeMetadataAccess(JetBrains.Metadata.Access.IMetadataAccess)">
            <summary>
            You must call DisposeMetadataAccess after every GetFrom* method,
            but if you're loading assemblies via MetadataLoader that will be done for you automatically
            on loader dispose
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetUserString(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets the string from userstring (#US) heap
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetAllGuids">
            <remarks>use 1-based indices</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetAllStringsWithOffsets">
            <remarks>
            <para>The physical heap can contain garbage, that is,
            it can contain parts that are unreachable from any of the tables.</para>
            <para> For heap \0ABCDEF\0 this method returns {{0,""}, {1, "ABCDEF"}},
            however, string "CDEF" can be reached from another table by offset 3,
            while string "ABCDEF" can be unreachable at the same time
            (there is no table which contains string offset 1).</para>
            <para>We do not skip garbage for performance reason
            (to do this we need to read all string offset usages from all tables).</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetAllStrings">
            <remarks>Can contain garbage (see <see cref="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetAllStringsWithOffsets"/>)</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetBlobHeapReader">
            <summary>Provides direct access to blob heap, do not use it except for optimization</summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.IMetadataStreamsAccess.GetTableSize(JetBrains.Metadata.Access.MetadataTableId)">
            <summary>
            Row count for metadata table
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Access.IMetadataStreamsAccess.StringHeapSize">
            <remarks>
            Size without 4b aligning zeros
            (only one terminating zero at the end)
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataProviderFactory">
            <summary>
            Provides metadata interface for various sources
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataTableId">
            <summary>
            Metadata tables
            </summary>
            <remarks>
            Partition II: Metadata Definition and Semantics. 22 Metadata logical format: tables.
            bh - Blob heap,
            sh - String heap,
            gh - GUID heap
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Access.MetadataTablesStructure.Column.PresentationName">
            <remarks>null - for reserved values, column can be skipped in table presentation</remarks>
        </member>
        <member name="F:JetBrains.Metadata.Access.MetadataTablesStructure.Column.DataType">
            <summary>
            <list type="bullet">
            <item><term>MetadataTokenType values</term><description>for corresponding tokens (RID for table tokens)</description></item>
            <item><term>ColumnDataType.StringHeap</term><description>for offset in #Strings</description></item>
            <item><term>ColumnDataType.BlobHeap</term><description>for offset in #Blob</description></item>
            <item><term>ColumnDataType.GuidHeap</term><description>for index in #GUID</description></item>
            <item><term>Negative values (ColumnDataType.OneByte, ColumnDataType.TwoBytes, ColumnDataType.FourBytes)</term><description>for -number of bytes</description></item>
            </list>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Access.MetadataTablesStructure.Column.IsRange">
            <remarks>
            If true then DataType has MetadataTokenType value (less than or equal to MaxTableTokenType).
            Token (RID of token) in this column marks the first of a contiguous run of tokens in corresponding table
            (with id (MetadataTableId)DataType).
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Access.MetadataTablesStructure.Column.FlagsType">
            <remarks>null only if !IsFlags</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Access.MetadataToken">
            <summary>
            Represents metadata token
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Access.Prologs">
            <summary>
            Enumerates prologs for different signatures
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Access.TargetPlatformUtil.GetTargetPlatform(JetBrains.Interop.WinApi.MachineId,JetBrains.Metadata.Utils.PE.CLIFlags,JetBrains.Metadata.Utils.PE.PESignature)">
            <summary>
            <list type = "table">
            <listheader>
            <term> PE / 32BITREQ / 32BITPREF </term> <description> </description>
            </listheader>
            <item> <term> PE32 / 0 / 0 </term> <description> <see cref="F:JetBrains.Metadata.Access.TargetPlatform.AnyCpu"/> </description> </item>
            <item> <term> PE32 / 1 / 0 </term> <description> <see cref="F:JetBrains.Metadata.Access.TargetPlatform.X86"/> </description> </item>
            <item> <term> PE32 / 0 / 1 </term> <description> <see cref="F:JetBrains.Metadata.Access.TargetPlatform.AnyCpuPrefer32Bit"/> </description> </item>
            <item> <term> PE32+ / 0 / 0 </term> <description> <see cref="F:JetBrains.Metadata.Access.TargetPlatform.X64"/> </description> </item>
            </list>
            </summary>
            <remarks>
            32BITREQ - cliFlags contains <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Required32Bit"/> and does not contain <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Preferred32Bit"/>;
            32BITPREF - cliFlags contains <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Required32Bit"/> and <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Preferred32Bit"/>
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Access.TargetPlatformUtil.GetProcessorArchitecture(JetBrains.Metadata.Access.AssemblyFlags,JetBrains.Interop.WinApi.MachineId,JetBrains.Metadata.Utils.PE.PESignature,JetBrains.Metadata.Utils.PE.CLIFlags)">
            <see cref="!:AssemblyName.CalculateProcArchIndex(PortableExecutableKinds,ImageFileMachine,AssemblyNameFlags)"/>
        </member>
        <member name="M:JetBrains.Metadata.Access.TargetPlatformUtil.GetTargetPlatform(JetBrains.Util.VirtualFileSystemPath,System.Boolean)">
            <summary>
            Detects target platform of a PE file
            </summary>
            <param name="path">path to file</param>
            <param name="detectNative">if set to true the method will detect platform for native PEs (instead of returning Unknown). If false the method returns Unknown for any non-CLI file</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Access.TargetPlatformUtil.GetTargetPlatform(JetBrains.Metadata.Reader.API.IAssemblyLocation,System.Boolean)">
            <summary>
            Detects target platform of a PE file
            </summary>
            <param name="assemblyLocation">path to file</param>
            <param name="detectNative">if set to true the method will detect platform for native PEs (instead of returning Unknown). If false the method returns Unknown for any non-CLI file</param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Metadata.ApiVerifier.IErrorConsumer">
            <summary>
            Сan be used to display verification errors and make a decision to continue verification.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.ApiVerifier.IErrorConsumer.OnError(JetBrains.Metadata.ApiVerifier.ErrorReport)">
            <summary>
            Method called when an error occurs during the verification process.
            </summary>
            <returns><b>true</b> to continue the verification process otherwise <b>false</b></returns>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.BeginTypeMemberMarker.Token">
            <summary>
            Type / type member token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference.MethodBody">
            <summary>
            Method which contains original and sequence point instructions
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference.Instruction">
            <summary>
            Original instruction
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference.SequencePointInstruction">
            <summary>
            Sequence point instruction associated with original instruction 
            (with IL offset less or equal to original instruction IL offset)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReferenceUtil.ChooseFirstSequencePoint(JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference,JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference)">
            <summary>
            If both sequence point instructions from one method then chooses first of them,
            otherwise returns ir1
            (If one of the instructions is null then choose another)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.InstructionReferenceUtil.GetInstructionIndex(JetBrains.Metadata.Debug.CodeTextWriter.InstructionReference.IInstructionReference)">
            <summary>
            Gets instruction ir.Instruction index in ir.MethodBody.Instructions array
            (returns -1 in case of error)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.ISequencePointMarker.InstructionReference">
            <summary>
            IL instruction (with corresponding method) of sequence point
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.CodeTextWriter.MetadataRenderOrchestrationOptions.OwnNamespace">
            <remarks>
            OwnNamespace is used to determine import scopes tree structure
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Debug.CodeTextWriter.SequencePointCollection">
            <summary>
            Collection of sequence points for one source file.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.CodeTextWriter.SequencePointCollection.GetMethods">
            <summary>
            Gets metadata tokens of methods containing sequence points from this collection
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugData.UserEntryPoint">
            <summary>
            Token of the entry point method (null for dll)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugData.Documents">
            <summary>
            Source files
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugData.OriginalPdbFilePath">
            <summary>
            Path to pdb file from which the data was obtained
            </summary>
            <remarks>Should be null for decompiler-generated DebugData</remarks>
        </member>
        <member name="F:JetBrains.Metadata.Debug.DebugData.DocumentToMemberRanges">
            <summary>
            Ranges of types / methods / etc for source file with given index
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.CreateDocument(System.String)">
            <summary>
            Creates document with given url and adds it to content
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.CreateDocument(System.String,System.Guid,System.Guid,System.Guid,System.Guid,System.Byte[])">
            <summary>
            Creates document with given parameters and adds it to content
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.GetOrCreateDocument(System.String)">
            <summary>
            Gets (or creates and adds to content, if missing) document for the url
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.GetOrCreateDocument(JetBrains.Metadata.Debug.DebugDocument)">
            <summary>
            Gets existing source with baseDocument.URL name or creates new
            </summary>
            <remarks>baseDocument.Index is ignored, so input and output documents may have different indices</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.TryGetBestMatchingDocument(JetBrains.Util.FileSystemPath)">
            <summary>
            Document with the same name and the longest common suffix with the given path
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.CreateMethod(JetBrains.Metadata.Access.MetadataToken,JetBrains.Metadata.Access.MetadataToken,System.Int32,JetBrains.Metadata.Debug.ImportScope,System.Collections.Generic.IReadOnlyList{JetBrains.Metadata.Debug.SequencePoint},JetBrains.Metadata.Debug.MethodCustomDebugInformation)">
            <summary>
            Creates and adds to content method with token methodToken and [0, codeLength] IL range
            </summary>
            <param name="methodToken"></param>
            <param name="localVariablesSignatureToken"></param>
            <param name="codeLength">Method IL code length in bytes</param>
            <param name="importScope"></param>
            <param name="sequencePoints"></param>
            <param name="methodCustomDebugInformation"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.GetMethod(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets method for the token (fails if such method is missing)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugData.GetNextDocumentIndex">
            <summary>
            Generates next index (starting from 1)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.SingleDocumentIndex(JetBrains.Metadata.Debug.DebugData)">
            <returns>1-based index of source file, if it is only one in debugData, DebugDocument.NullDocumentIndex otherwise</returns>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.SingleDocumentIndex(JetBrains.Metadata.Debug.DebugMethod)">
            <returns>DocumentIndex that all sequence points have, DebugDocument.InvalidDocumentIndex otherwise</returns>
            <remarks>Sequence points can have DebugDocument.NullDocumentIndex DocumentIndex, it means that containing DebugData does not have any documents</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.AddLocalVariable(JetBrains.Metadata.Debug.DebugMethod,System.Int32,System.String,JetBrains.Util.Reflection.LocalVariableAttributes,JetBrains.Metadata.Access.MetadataToken,JetBrains.Metadata.Reader.Impl.CustomDebugInformation.TupleElementNamesData)">
            <summary>
            Adds local variable to scope that encloses the entire method
            (RootScope)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.AddLocalVariable(JetBrains.Metadata.Debug.DebugMethod,System.Int32,System.String,JetBrains.Util.Reflection.LocalVariableAttributes,JetBrains.Metadata.Access.MetadataToken,JetBrains.Metadata.Reader.Impl.CustomDebugInformation.TupleElementNamesData,System.Int32,System.Int32,JetBrains.Metadata.Debug.ImportScope)">
            <summary>
            Adds local variable to scopes covering [scopeStartOffest, scopeEndOffset]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.AddLocalVariables(JetBrains.Metadata.Debug.DebugMethod,JetBrains.Metadata.Debug.DebugLocalVariable[],System.Int32,System.Int32,JetBrains.Metadata.Debug.ImportScope)">
            <summary>
            Adds local variable to scopes covering [scopeStartOffest, scopeEndOffset]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.CreateDocumentSection(JetBrains.Metadata.Debug.DebugData,System.Int32,System.String)">
            <summary>
            Create DebugData from data related to document with documentIndex
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDataExtensions.CreateDocumentsSection(JetBrains.Metadata.Debug.DebugData,System.Int32[],System.String[])">
            <summary>
            Create DebugData from data related to documents with documentIndices
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.DebugDocument">
            <summary>
            Partial implementation of System.Diagnostics.SymbolStore.ISymbolDocument
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.Index">
            <remarks>1 based</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.URL">
            <summary>
            The URL (file name) of the current document
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.DocumentType">
            <summary>
            Gets the type of the current document
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.Language">
            <summary>
            Gets the language of the current document
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.LanguageVendor">
            <summary>
            Gets the language vendor of the current document
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.ChecksumAlgorithmId">
            <summary>
            Gets the checksum algorithm id of the current document
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugDocument.Checksum">
            <summary>
            Gets the checksum of the current document
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugDocument.Update(JetBrains.Metadata.Debug.DebugDocument)">
            <summary>
            Updates all data except Index
            </summary>
            <remarks>
            For combine infos from
            WindowsPdbFile.ReadStreamNames (only lowercase URL and index) and
            DocumentInfoVisitor.Visit_FILECHKSMS (all document info except index)
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Debug.DebugLocalVariable">
            <summary>
            System.Diagnostics.SymbolStore.ISymbolVariable
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugLocalVariable.Name">
            <summary>
            The name of the variable
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugLocalVariable.LocalVariablesSignatureToken">
            <summary>
            The metadata token of the local variables signature for method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugLocalVariable.Attributes">
            <summary>
            The local variable attributes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugLocalVariable.IlIndex">
            <summary>
            see SymAddressKind.ILOffset
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.DebugMethod">
            <summary>
            Partial implementation of System.Diagnostics.SymbolStore.ISymbolMethod
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.Token">
            <summary>
            The metadata token for the current method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.LocalVariablesSignatureToken">
            <summary>
            The metadata token of the local variables signature for this method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.RootScope">
            <summary>
            The root lexical scope that encloses the entire method.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugMethod.SetImportScope(JetBrains.Metadata.Debug.ImportScope)">
            <summary>
            Set importScope to all nodes of method's LocalScope tree
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.IsEmpty">
            <summary>
            Gets if there're no sequence points in the method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.SequencePoints">
            <summary>
            Sequence points for the current method
            (sorted in the increasing order of IL offsets)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugMethod.GetSequencePointsForDocument(System.Int32)">
            <summary>
            Sequence points for the current method in specified source file
            (sorted in the increasing order of IL offsets)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.DebugMethod.SequencePointsDocumentIndices">
            <summary>
            Indices of source files in which current method is defined
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.DebugMethod.GetSequencePointByIlOffset(System.Int32)">
            <remarks>Slow!!!</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.IMetadataLocalVariablesNameProvider.NamesSource">
            <summary>
            Source of local variable names
            (pdb path, decompiler, etc.)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Import.TargetAssembly">
            <remarks>AssemblyRef token or MetadataToken.Nil if not set</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Import.TargetType">
            <remarks>TypeDef, TypeRef or TypeSpec token or MetadataToken.Nil if not set</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Debug.LocalScope">
            <summary>
            Represents a lexical scope within DebugMethod, 
            providing access to the start and end offsets of the scope, 
            as well as its child and parent scopes.
            (see System.Diagnostics.SymbolStore.ISymbolScope)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.Method">
            <summary>
            The method that contains the current lexical scope
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.Parent">
            <summary>
            The parent lexical scope of the current scope
            (null for root scope of the DebugMethod)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.StartOffset">
            <summary>
            The start offset of the current lexical scope
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.EndOffset">
            <summary>
            The end offset of the current lexical scope 
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.SortedChildScopes">
            <summary>
            The child lexical scopes of the current lexical scope
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.LocalScope.LocalVariables">
            <summary>
            The local variables within the current lexical scope
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.LocalScope.TryGetLocalVariable(System.Int32)">
            <summary>
            Returns local variable with specified index  
            if this variable is presented within the current lexical scope,
            null otherwise
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.LocalScope.TryGetLocalVariableFromParentScopes(System.Int32)">
            <summary>
            Returns local variable with specified index  
            if this variable is presented within parent scopes of current lexical scope,
            null otherwise
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.LocalScope.TryAddLocalVariable(JetBrains.Metadata.Debug.DebugLocalVariable)">
            <summary>
            Adds local variable and returns true if local variable with index localVariable.IlIndex is not contained 
            in this, child or parent scopes,
            otherwise returns false
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.LocalScope.GetOrCreateInnerScopes(System.Int32,System.Int32,System.Collections.Generic.ICollection{JetBrains.Metadata.Debug.LocalScope},JetBrains.Metadata.Debug.ImportScope)">
            <summary>
            Adds obtained inner scopes (existed or created) covering [startOffest, endOffset] to scopes collection
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.MethodCustomDebugInformation.TupleElementNames">
            <remarks>For Windows Pdb only</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.MethodCustomDebugInformation.KickoffMethod">
            <summary>
            The method that initializes and starts the state machine
            (for MoveNext method that implements the state transition)
            </summary>
            <see cref="F:JetBrains.Metadata.Access.MetadataTableId.StateMachineMethod"/>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Common.PackedBitSet.#ctor(System.Int32)">
            <summary>
            Creates bit set where IsSet(index) when index less than num
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Common.PackedBitSet.#ctor(System.Collections.Generic.IEnumerable{System.Int32},System.Int32)">
            <summary>
            Creates bit set where IsSet(index) when index in indices
            </summary>
            <param name="indices"></param>
            <param name="maxIndex">maximum value of index in indices</param>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Common.PackedBitSet.#ctor(System.Collections.Generic.IList{System.Int32})">
            <summary>
            Creates bit set where IsSet(index) when index in sortedIndices
            (sortedIndices[i] not greater than sortedIndex[i + 1])
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.Common.PdbStream">
            <summary>
            PDB stream descriptor
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Common.PdbStream.#ctor(System.UInt32,System.UInt32[])">
            <summary>
            ctor
            </summary>
            <param name="size"></param>
            <param name="blocks"></param>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.Common.PdbStream.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.Common.PdbStream.Blocks">
            <summary>
            Stream blocks
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.Common.PdbStreamInfo">
            <summary>
            PDB (v 2.0) stream information stored in the Table of the Contents
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Common.PdbStreamInfo.#ctor(System.IO.BinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.Common.PdbStreamInfo.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.Common.PdbSubStream">
            <summary>
            Stream for reading sub range of the underlayed stream
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.UsingGroups">
            <summary>
            C# only. Encodes the sizes of using groups that are applicable to the method.
            The actual import strings are stored separately through ISymUnmanagedWriter.UsingNamespace.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.ForwardMethodInfo">
            <summary>
            C# only. Indicates that per-method debug information (import strings) is stored on another method, 
            whose token is specified.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.ForwardModuleInfo">
            <summary>
            C# only. Indicates that per-module debug information (assembly reference aliases) is stored on another method, 
            whose token is specified.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.StateMachineHoistedLocalScopes">
            <summary>
            C# only. Specifies local scopes for state machine hoisted local variables.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.StateMachineTypeName">
            <summary>
            C# and VB. The name of the state machine type. Emitted for async and iterator kick-off methods.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.DynamicLocals">
            <summary>
            C# only. Dynamic flags for local variables and constants.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.EditAndContinueLocalSlotMap">
            <summary>
            C# and VB. Encodes EnC local variable slot map.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.EditAndContinueLambdaMap">
            <summary>
            C# and VB. Encodes EnC lambda map.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.CustomDebugInfoKind.TupleElementNames">
            <summary>
            C# and VB. Tuple element names for local variables and constants.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.Dbi.DbiDbgHeader.HeaderSize">
            <summary>
            Dbg header size in bytes
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Dbi.DbiFileInfo.GetFileInfoSize">
            <summary>
            Size in bytes of file info section of DBI stream
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.Dbi.DbiHeader.HeaderSize">
            <summary>
            DBI header size in bytes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.Dbi.DbiHeader.PdbAge">
            <summary>
            Pdb file age
            (ever-incrementing value, which is initially set to 1 and 
            incremented every time when a part of the PDB file is updated without rewriting the whole file)
            (assembly should have the same age and guid signature as pdb)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Dbi.DbiModuleInfo.GetModuleInfoSizeWithoutAlign">
            <summary>
            Size in bytes of module info without align (but with strings)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Dbi.DbiModuleInfo.GetModuleInfoSize">
            <summary>
            Module info size in bytes (4 bytes align is taken into account)
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.Dbi.DbiSectionContribution.SectionContributionSize">
            <summary>
            DBI section contribution size in bytes
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Generator.PdbFileBuilder.BuildAllStreamsAndTocPointers">
            <remarks> After call this method adding streams is not allowed </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.Generator.PdbStreamGenerator.GetStringSizeInBytes(System.String)">
            <summary>
            Calculates size of string s in bytes for UTF8 encoding
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.IDebugAssemblyInfo.PdbSignature">
            <summary>
            Null if we cannot extract signature, for example an assembly file is not found
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbDocumentInfo.Index">
            <remarks>1 based; DebugDocument.NullDocumentIndex if index can't be determined</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbFunction.CodeLength">
            <summary>
            Function IL code length in bytes
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.PdbHeader">
            <summary>
            PDB 7.0 file header info
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Debug.Pdb.PdbHeader.HeaderSize">
            <summary>
            Pdb header size in bytes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.Signature">
            <summary>
            Signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.BlockSize">
            <summary>
            Size of the file blocks
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.NumPages">
            <summary>
            Count of debug info pages
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.TocSize">
            <summary>
            Size of the Table of Contents
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.TocBlocksPage">
            <summary>
            Index of the TOC Pointers Page
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbHeader.FirstPage">
            <summary>
            First page in PDB
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbNameAndSignature.Name">
            <summary>
            Pdb file name without .pdb extension
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbNameAndSignature.Signature">
            <summary>
            &lt;guid&gt;&lt;age&gt; or &lt;guid&gt;FFFFFFFF
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbReader.TemporarilyExtractEmbeddedPdb(JetBrains.Lifetimes.Lifetime,JetBrains.Metadata.Reader.API.IAssemblyLocation)">
            <summary>
            Extracts embedded portable Pdb to temp file
            </summary>
            <param name="lifetime">lifetime of temporary file</param>
            <param name="assemblyWithEmbeddedPdb"></param>
            <returns>temporary file path</returns>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.PdbRootRecord">
            <summary>
            Root record of the PDB info
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbRootRecord.#ctor(System.IO.BinaryReader)">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbRootRecord.Version">
            <summary>
            Symbolic info version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbRootRecord.TimeDateStamp">
            <summary>
            TimeStamp
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbRootRecord.PdbSignature">
            <summary>
            Symbolic info ID (SymId)
            (a unique identifier, which changes with every rebuild of the executable and PDB file)
            (assembly should have the same signature as pdb)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbRootRecord.PdbAge">
            <summary>
            Pdb file age
            (ever-incrementing value, which is initially set to 1 and 
            incremented every time when a part of the PDB file is updated without rewriting the whole file)
            (assembly should have the same age as pdb)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Debug.Pdb.PdbToc">
            <summary>
            PDB File table of the contents
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PdbToc.Streams">
            <summary>
            Streams existed in the PDB File
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.GetChecksumString(JetBrains.Util.FileSystemPath,System.String)">
            <summary>
            Return checksum from PE fie with preferable algorithm.
            </summary>
            <returns>
              string in format [ALGO]:[HEXSUM]
              <example>SHA256:B6BD70C213FD15DB859068A5DB485BE5FB82FB05EE77D22B8E7D852BD8FB6BC8</example>
            </returns>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.GetChecksumString(JetBrains.Metadata.Reader.API.IAssemblyLocation,System.String)">
            <summary>
            Return checksum from PE fie with preferable algorithm.
            </summary>
            <returns>
              string in format [ALGO]:[HEXSUM]
              <example>SHA256:B6BD70C213FD15DB859068A5DB485BE5FB82FB05EE77D22B8E7D852BD8FB6BC8</example>
            </returns>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.OfAnyStandaloneType(System.Collections.Generic.IEnumerable{JetBrains.Metadata.Utils.PE.Directories.DebugInfo})">
            <remarks> Only Standalone and StandalonePortable types </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.GetSignatureAndAge(JetBrains.Util.FileSystemPath,System.Guid@,System.UInt32@)">
            <summary>
            Signature and Age of Windows PDB
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.GetSignatureAndAge(JetBrains.Metadata.Debug.Pdb.WindowsPdbFile,System.Guid@,System.UInt32@,System.UInt32@)">
            <summary>
            Signature and Age of Windows PDB
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.GetSignatureAndTimestamp(JetBrains.Util.FileSystemPath,System.Guid@,System.UInt32@)">
            <summary>
            Signature and TimeDateStamp of standalone Portable PDB
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.InferTypeToFiles(JetBrains.Util.DataStructures.CompactOneToListMap{System.String,System.String},JetBrains.Metadata.Reader.API.IMetadataAssembly,JetBrains.Metadata.Access.IMetadataAccess,System.String[],System.Collections.Generic.IEnumerable{System.String},System.Collections.Generic.HashSet{System.String}@)">
            <summary>
            Infer sources names for types without mapping
            and add this new mappings to typeToFiles
            </summary>
            <param name="typeToFiles">initially contains only existing mappings
            (obtained from sequence points)</param>
            <param name="metadataAssembly"></param>
            <param name="metadataAccess"></param>
            <param name="typeFqns">FQNs from TypeDef metadata table</param>
            <param name="allFileNames">sources names from pdb</param>
            <param name="typesWithInferredMapping">FQNs for types with inferred sources names</param>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.IsPortablePdbSignature(System.String)">
            <summary>
            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxFFFFFFFF
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.IsAge1PdbSignature(System.String)">
            <summary>
            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx1
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.ToAge1PdbSignature(System.String)">
            <summary>
            &lt;guid&gt;FFFFFFFF -&gt; &lt;guid&gt;1
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.ToPortablePdbSignature(System.String)">
            <summary>
            &lt;guid&gt;1 -&gt; &lt;guid&gt;FFFFFFFF
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastWindowsDebugInfo(JetBrains.Util.FileSystemPath)">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastWindowsDebugInfo(System.Collections.Generic.IList{JetBrains.Metadata.Utils.PE.Directories.DebugInfo})">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastAnyStandaloneDebugInfo(JetBrains.Util.FileSystemPath)">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/> or <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastAnyStandaloneDebugInfo(JetBrains.Metadata.Reader.API.IAssemblyLocation)">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/> or <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastAnyStandaloneDebugInfo(System.Collections.Generic.IList{JetBrains.Metadata.Utils.PE.Directories.DebugInfo})">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/> or <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PdbUtils.TryGetLastDebugInfoExceptDeterministic(System.Collections.Generic.IList{JetBrains.Metadata.Utils.PE.Directories.DebugInfo})">
            <remarks>If returned value is not null, it has type <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows"/> or <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable"/> or <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.EmbeddedPortable"/></remarks>
        </member>
        <member name="P:JetBrains.Metadata.Debug.Pdb.PortablePdbFile.TypeToFiles">
            <remarks>
            Type to files mapping can be retrieved only when we have information about types
            (i.e. we have assembly metadata)
            </remarks>
            <returns>
            null if assembly passed to ctor is null
            </returns>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PortablePdbFile.CalculateTypeToFiles">
            <summary>
            Calculate myTypeToFiles and myTypesWithInferredMapping
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PortablePdbFile.TryGetDocumentIndex(System.String)">
            <summary>
            Index of Document table row with Name == documentName (ignore case) or
            DebugDocument.NullDocumentIndex if such row is absent
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.PortablePdbFile.TryGetEmbeddedSource(System.Int32)">
            <summary>
            Content of CustomDebugInformation Value blob for row: Kind - Embedded Source, Parent - Document with index documentIndex or
            null if such row is absent
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.SrcSrv.SourceLink.TryGetUnixPath(System.String)">
            <remarks>reverse to <see cref="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbFile.NormalizePath(System.String)"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.SymbolWriter.WindowsPdbWriter.Write(JetBrains.Metadata.Debug.DebugData,JetBrains.Util.FileSystemPath,JetBrains.Util.FileSystemPath,System.Guid,System.UInt32)">
            <remarks>Call on the main thread</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.SymbolWriter.WindowsPdbWriter.PatchPdb(JetBrains.Util.FileSystemPath,System.Guid,System.UInt32)">
            <summary>
            Replaces signature and age info in PDB header 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo.ReadUsingGroups(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            For each namespace declaration enclosing a method (innermost-to-outermost), there is a count
            of the number of imports in that declaration.
            </summary>
            <remarks>
            There's always at least one entry (for the global namespace).
            </remarks>
            <see cref="!:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeUsingRecord"/>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo.ReadForwardMethodInfo(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            This indicates that further information can be obtained by looking at the custom debug
            info of another method (specified by token).
            </summary>
            <remarks>
            Appears when multiple method would otherwise have identical using records
            (see <see cref="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo.ReadUsingGroups(JetBrains.Metadata.Utils.IBinaryReader)"/>).
            </remarks>
            <see cref="!:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeForwardRecord"/>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo.ReadTupleElementNames(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            Tuple element names for locals.
            </summary>
            <see cref="!:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeTupleElementNamesRecord"/>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbCustomDebugInfo.ReadTupleInfo(JetBrains.Metadata.Utils.IBinaryReader)">
            <see cref="!:Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader.DecodeTupleElementNamesInfo"/>
        </member>
        <member name="M:JetBrains.Metadata.Debug.Pdb.WindowsPdbFile.GetDocumentNameToInfoDictionary">
            <remarks>
            GetDebugData(...).TryGetDocument(documentName).(Index, Checksum)
            equals to
            GetDocumentNameToInfoDictionary()[documentName]
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Debug.SequencePoint">
            <summary>
            Sequence point within the current method. 
            StartLine and StartColumn define the start of a statement within a method in source file with index DocumentIndex. 
            EndLine and EndColumn define the end of a statement within a method.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.IlOffset">
            <summary>
            The IL offset of the sequence point measured from the beginning of the method (in bytes)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.StartLine">
            <summary>
            The starting line number of the sequence point
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.StartColumn">
            <summary>
            The starting column number of the sequence point
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.EndLine">
            <summary>
            The ending line number of the sequence point
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.EndColumn">
            <summary>
            The ending column number of the sequence point
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.IsHidden">
            <summary>
            if sequence point is hidden then the debugger will skip over it
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Debug.SequencePoint.DocumentIndex">
            <summary>
            Index of source file where statement is located (DebugDocument.Index)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.SequencePoints.ISequencePointInstructionRedirector.ToSequencePointInstructionIndex(System.Int32)">
            <summary>
            Redirects instructionIndex to associated sequence point instruction index
            (returns -1 in case of error)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Debug.SequencePoints.SequencePointUtils.CheckBranchTarget(JetBrains.Metadata.IL.Instruction[],System.Int32,System.Collections.Generic.ICollection{System.Int32})">
            <remarks>
            Branch instruction can be associated with hidden SP 
            if branch target instruction is after this instruction and
            there are regular SP between this instruction and branch target instruction 
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Debug.SequencePoints.SequencePointUtils.GetHiddenSequencePointsOffsets(JetBrains.Metadata.IL.Instruction[],System.Collections.Generic.ICollection{System.Int32},JetBrains.Metadata.Debug.SequencePoints.ISequencePointInstructionRedirector)">
            <summary>
            Returns offsets of all hidden sequence points  
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyItem.ProgramDatabase">
            <summary>
            Optional program database (PDB) file for this DLL.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyItem.XmlDocumentation">
            <summary>
            Optional XmlDoc file for this DLL.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameMetadataExtensions.FindAssemblyFile(JetBrains.Util.FileSystemPath,JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean)">
            <summary>
            Checks for the existing files and chooses the assembly extension from the list, eg “exe” or “dll”.
            Throws if not found.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameMetadataExtensions.FindAssemblyFile(JetBrains.Util.VirtualFileSystemPath,JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean)">
            <summary>
            Checks for the existing files and chooses the assembly extension from the list, eg “exe” or “dll”.
            Throws if not found.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameMetadataExtensions.FindAssemblyFile(JetBrains.Util.VirtualFileSystemPath,System.String,System.Boolean)">
            <summary>
            Checks for the existing files and chooses the assembly extension from the list, eg “exe” or “dll”.
            Throws if not found.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyNameReader">
            <summary>
            Assembly name reader in managed code.
            No .NET framework or Fusion API used.
            Opens files in non-blocking mode.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameReader.GetModuleRefs">
            <summary>
            Info from ModuleRef (0x1A) table
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameReader.GetReferences">
            <summary>
            Info from AssemblyRef (0x23) table
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyNameReader.GetAssemblyNameRaw(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Assembly name reader in managed code.
            No .NET framework or Fusion API used.
            Opens files in non-blocking mode.
            DOES NOT CHECK FOR THE FILE EXISTENCE!
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.AssemblyResolver">
            <summary>
            Helps with looking up the referenced assemblies.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyResolver.myBaseDirs">
            <summary>
            The list of base directories to be probed for the assembly being resolved.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.AssemblyResolver.myInstalledOn">
            <summary>
            The list of appdomains we've been installed onto.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.#ctor(System.Collections.Generic.IEnumerable{JetBrains.Util.VirtualFileSystemPath},System.Func{JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean})">
            <summary>
            Creates the instance. Call <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Install(System.AppDomain)"/> to attach, don't forget to call <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Uninstall(System.AppDomain)"/> or <see cref="M:JetBrains.Metadata.Utils.AssemblyResolver.Dispose"/> to detach on shutdown.
            </summary>
            <param name="basedirs">The list of base directories to be probed for the assembly being resolved.</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.FromAssembly(System.Reflection.Assembly,System.Func{JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean})">
            <summary>
            Creates a resolver over the single probing directory that is the home directory of the <param name="assembly"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.FromFolder(JetBrains.Util.VirtualFileSystemPath,System.Func{JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean})">
            <summary>
            Creates a resolver over the single probing directory <param name="folder"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Install(System.AppDomain)">
            <summary>
            Starts listening for failed assembly loads on the given appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Uninstall(System.AppDomain)">
            <summary>
            Stops listening for failed assembly loads on the given appdomain.
            It is not an error to uninstall from a non-installed appdomain.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyResolver.Dispose">
            <summary>
            Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.
            </summary>
            <filterpriority>2</filterpriority>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AssemblyScanner.TransitivelyCloseAssemblyReferencesWithinTheirFolders(System.Collections.Generic.IReadOnlyCollection{JetBrains.Util.VirtualFileSystemPath})">
            <summary>
            Takes a set of assemblies (as file paths).
            Reads their references (with metadata reader, not runtime) and tries to look up in the same folders as the set of assemblies. Adds only those found, transitively. Returns paths with actual names on disk (not as written in references, but as found in files, no runtime correction).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AttributeUtil.TrimAttributeSuffix(System.String)">
            <summary>
            Trim "Attribute" suffix if it exists
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AttributeUtil.TrimAttributeSuffix(JetBrains.Metadata.Reader.API.IClrTypeName)">
            <summary>
            Trim "Attribute" suffix if it exists
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.AttributeUtil.GetAttributeNameLength(System.String)">
            <summary>
            Attribute type name length (without "Attribute" suffix)
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.Bundle.AppHostType.None">
            <summary>
            File is not app host
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.Bundle.AppHostType.SingleFileBundle">
            <summary>
            App host is single-file bundle
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Bundle.BundleFileEntryLocation">
            <summary>
            Location of file entry inside single file bundle
            (location of bundle file + pointer to file entry inside bundle)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.Bundle.BundleFileEntryLocation.CreateKey(JetBrains.Util.VirtualFileSystemPath,System.String,System.Int32)">
            <remarks>
            For use as key in dictionary (or for comparison) only
            some methods or properties may throw exceptions
            (OpenForReading, FileEntryRelativePath, etc.)
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Bundle.BundleManifest">
             <summary>
              BundleManifest is a description of the contents of a bundle file.
              This class handles creation and consumption of bundle-manifests.
            
              Here is the description of the Bundle Layout:
              _______________________________________________
              AppHost
            
             ------------Embedded Files ---------------------
             The embedded files including the app, its
             configuration files, dependencies, and
             possibly the runtime.
            
             ------------ Bundle Header -------------
                 MajorVersion
                 MinorVersion
                 NumEmbeddedFiles
                 ExtractionID
                 DepsJson Location [Version 2+]
                    Offset
                    Size
                 RuntimeConfigJson Location [Version 2+]
                    Offset
                    Size
                 Flags [Version 2+]
             - - - - - - Manifest Entries - - - - - - - - - - -
                 Series of FileEntries (for each embedded file)
                 [File Type, Name, Offset, Size information]
             _________________________________________________
             </summary>
             <remarks><see cref="!:Microsoft.NET.HostModel.Bundle.Manifest"/></remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Bundle.BundleManifest.BundleID">
            <summary>
            Bundle ID is a string that is used to uniquely
            identify this bundle. It is chosen to be compatible
            with path-names so that the AppHost can use it in
            extraction path.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Bundle.BundleManifest.BundleIDStringLength">
            <summary>
            Length in bytes (including length prefix)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Bundle.BundleManifest.BundleMinorVersion">
            <remarks>The Minor version is currently unused, and is always zero</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.Bundle.BundleUtil.GetAppHostType(JetBrains.Util.VirtualFileSystemPath,System.Int64@,JetBrains.Metadata.Utils.Bundle.BundleManifest@,JetBrains.Util.ILogger)">
            <summary>
            Check if the an AppHost is a single-file bundle
            or native exe with corresponding managed dll
            </summary>
            <param name="appHostFilePath">The path of Apphost to check</param>
            <param name="bundleHeaderOffset">An out parameter containing the offset of the bundle header (if any)</param>
            <param name="bundleHeader"></param>
            <param name="logger"></param>
            <remarks><see cref="!:Microsoft.NET.HostModel.AppHost.HostWriter.IsBundle"/></remarks>
            <remarks>bundleHeader is not null for AppHostType.SingleFileBundle</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Bundle.FileEntry">
             <summary>
             FileEntry: Records information about embedded files.
            
             The bundle manifest records the following meta-data for each
             file embedded in the bundle:
             * Type       (1 byte)
             * NameLength (7-bit extension encoding, typically 1 byte)
             * Name       ("NameLength" Bytes)
             * Offset     (Int64)
             * Size       (Int64)
             === present only in bundle version 3+ (or 6+???)
             * CompressedSize   (Int64)  0 indicates No Compression
             </summary>
             <remarks><see cref="!:Microsoft.NET.HostModel.Bundle.FileEntry"/></remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Bundle.FileEntry.RelativePath">
            <summary>
            Path of an embedded file, relative to the Bundle source-directory.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.Bundle.FileEntry.RelativePathStringLength">
            <summary>
            Length in bytes (including length prefix)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Bundle.FileType">
             <summary>
             FileType: Identifies the type of file embedded into the bundle.
            
             The bundler differentiates a few kinds of files via the manifest,
             with respect to the way in which they'll be used by the runtime.
             </summary>
             <remarks><see cref="!:Microsoft.NET.HostModel.Bundle.FileType"/></remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.Bundle.HeaderFlags">
            <summary>
            NetcoreApp3CompatMode flag is set on a .net5 app,
            which chooses to build single-file apps in .netcore3.x compat mode,
            by constructing the bundler with BundleAllContent option.
            This mode is expected to be deprecated in future versions of .NET.
            </summary>
            <remarks><see cref="!:Microsoft.NET.HostModel.Bundle.Manifest.HeaderFlags"/></remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.ConflictingNamesHelper.GetConflictingNames(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Short names of properties, fields, events, nested types of typeElement (and its base type) which may conflict with names of used types
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.CursorPositionStringBuilder.#ctor(System.Int32)">
            <param name="startLinesCount">Count of lines at document start (before code lines).
             All positions should be shifted after appending lines at document start (e.g. comments in header)</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.ITypesCache.GetNamespacesContainingTypeShortName(System.String,System.Int32)">
            <summary>
            All namespaces with definition of type with short name and parameters count
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.ITypesCache.GetNamespacesContainingAttributeShortName(System.String,System.Int32)">
            <summary>
            All namespaces with definition of attribute with short name and parameters count
            (short name without attribute suffix trimming)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.OptimizedTypesPresentation.#ctor(JetBrains.Metadata.Utils.CodeTextWriter.ITypesCache,JetBrains.Metadata.Utils.CodeTextWriter.IIdentifierFixer,System.String,System.Collections.Generic.ICollection{System.String},System.Collections.Generic.ICollection{JetBrains.Metadata.Reader.API.IClrTypeName},System.Collections.Generic.ICollection{JetBrains.Metadata.Reader.API.IClrTypeName},System.Boolean)">
            <param name="typesCache"></param>
            <param name="identifierFixer"></param>
            <param name="ownNamespace"></param>
            <param name="conflictingNames">short names of properties, fields, events, nested types (which may conflict with names of used types)</param>
            <param name="types">The set of types being referenced</param>
            <param name="attributes">The set of attributes being referenced</param>
            <param name="projectionIsUsed"></param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.OptimizedTypesPresentation.GetParentNamespaces(System.String)">
            <summary>
            Parent namespaces of given namespace including namespace itself
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.RenderEx.RenderToCSharp(JetBrains.Metadata.Reader.API.IMetadataType,System.Boolean)">
            <summary>
            Used mainly for debugging purpose.
            </summary>
            <param name="type">A type to format.</param>
            <param name="typeShortName">Format types with or without namespace</param>
            <returns>A string representing the type.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.RenderEx.GetMethodIdentifierForSmartStepInto(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>Renders a method name for Smart Step Into, respecting the local function naming.</summary>
            <param name="method">Method to render.</param>
            <returns>Method or local function name.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.CodeTextWriter.TypeRenderingParameters.#ctor(JetBrains.Metadata.Reader.API.IMetadataEntity,System.Boolean,JetBrains.Metadata.Utils.CodeTextWriter.INullableRenderer,System.Boolean,System.Boolean)">
            <remarks>
            If <paramref name="skipFirstNullableAnnotation"/> is true, then annotation for type
            (only, not for its generic arguments) is not rendered
            and nullable context is not switched
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.CodeTextWriter.TypeRenderingParameters.ExplicitInterfaceImplementation">
            <remarks>
            true: do not use type aliases, spaces and nullable annotations
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.CodeTextWriter.ValueTupleRenderingParameters.RenderAsTuple">
            <summary>
            true - (Type1, ..., TypeN);
            false - ValueTuple&lt;Type1, ..., TypeN&gt;
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyContentType">
            <summary>
            Provides information about the type of code contained in an assembly.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer">
            <summary>
            Compares assembly identities. 
            Derived types may implement platform specific unification and portability policies.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ComparisonResult">
            <summary>
            A set of possible outcomes of <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo"/> comparison.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ComparisonResult.NotEquivalent">
            <summary>
            Reference doesn't match definition.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ComparisonResult.Equivalent">
            <summary>
            Strongly named reference matches strongly named definition (strong identity is identity with public key or token),
            Or weak reference matches weak definition.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ComparisonResult.EquivalentIgnoringVersion">
            <summary>
            Reference matches definition except for version (reference version is lower or higher than definition version).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ReferenceMatchesDefinition(System.String,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            Compares assembly reference name (possibly partial) with definition identity.
            </summary>
            <param name="referenceDisplayName">Partial or full assembly display name.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference name matches the definition identity.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.ReferenceMatchesDefinition(JetBrains.Metadata.Utils.AssemblyNameInfo,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            Compares assembly reference identity with definition identity.
            </summary>
            <param name="reference">Reference assembly identity.</param>
            <param name="definition">Full assembly display name.</param>
            <returns>True if the reference identity matches the definition identity.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyNameInfoComparer.Compare(JetBrains.Metadata.Utils.AssemblyNameInfo,JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            Compares reference assembly identity with definition identity and returns their relationship.
            </summary>
            <param name="reference">Reference identity.</param>
            <param name="definition">Definition identity.</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyVersion.op_Explicit(System.Version)~JetBrains.Metadata.Utils.DotNetLegacy.AssemblyVersion">
            <summary>
            Converts <see cref="T:System.Version"/> to <see cref="T:JetBrains.Metadata.Utils.DotNetLegacy.AssemblyVersion"/>.
            </summary>
            <exception cref="T:System.InvalidCastException">Major, minor, build or revision number are less than 0 or greater than 0xFFFF.</exception>
        </member>
        <member name="M:JetBrains.Metadata.Utils.DotNetLegacy.DesktopAssemblyNameComparer.IsFrameworkAssembly(JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            Returns true if the identity is a Framework 4.5 or lower assembly.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.IAssemblyItem">
            <summary>
            An assembly item, which can tell the name of the assembly and its bytes content.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.IAssemblyItem.AssemblyName">
            <summary>
            Full name of this assembly.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.IAssemblyItem.File">
            <summary>
            The byte content of the assembly, as well as its original file name.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.IAssemblyItem2">
            <summary>
            Optional properties for an assembly item.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.IAssemblyItem2.ProgramDatabase">
            <summary>
            Optional program database (PDB) file for this DLL.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.IAssemblyItem2.XmlDocumentation">
            <summary>
            Optional XmlDoc file for this DLL.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.IAssemblyItemEx.ModuleVersionIdentifier(JetBrains.Metadata.Utils.IAssemblyItem)">
            <summary>
            Reads the assembly MVID from the stream.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.IBinaryReader.ReadStringUtf8">
            <summary>
            Read zero-terminated UTF-8 string (C string)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.IBinaryReader.ReadUtf8Constant">
            <summary>
            Read length-prefixed UTF-8 string
            (compressed int is used for size)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.IBlob.ReadStringUtf8(System.Int32,System.Int32@)">
            <summary>
            Read zero-terminated UTF-8 string (C string)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.IBlob.ReadUtf8Constant(System.Int32,System.Int32@)">
            <summary>
            Read length-prefixed UTF-8 string
            (compressed int is used for size)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.KeyToValuesArrayDictionary`2">
            <remarks>
            Optimized for one value per key
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataHelpers.GetTupleComponentType(JetBrains.Metadata.Reader.API.IMetadataClassType,System.Int32)">
            <returns>
            not null tuple component type, if valueTupleType.IsGenericValueTuple and
            0 &lt;= componentIndex &lt; valueTupleType.GetTupleComponentsCount();
            null otherwise
            </returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.MetadataHelpers.GetValueTupleItemIndex(System.String)">
            <returns>Index starting from 1; 0 in case of invalid item field name</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.ModuleQualificationUtil.GetIndexOfCommaAfterTypeName(System.String)">
            <returns>Zero-based index position of the first occurrence of comma
            (outside of angle brackets) if it is found,
            or -1 if it is not.</returns>
            <remarks>Assumption: input string has regular bracket sequence</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Characteristics">
            <summary>
            COFF file characteristics
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.RELOCS_STRIPPED">
            <summary>
            Relocation info stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.EXECUTABLE_IMAGE">
            <summary>
            File is executable
            (i.e. file is neither object file nor library file,
            so there are no unresolved external references).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LINE_NUMS_STRIPPED">
            <summary>
            Line numbers stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LOCAL_SYMS_STRIPPED">
            <summary>
            Local symbols stripped from file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.AGGRESSIVE_WS_TRIM">
            <summary>
            Aggressively trim working set
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.LARGE_ADDRESS_AWARE">
            <summary>
            Application can handle >2gb addresses
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.MACHINE_16BIT">
            <summary>
            Use of this flag is reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.BYTES_REVERSED_LO">
            <summary>
            Bytes of machine word are reversed.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.MACHINE_32BIT">
            <summary>
            32 bit word machine.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.DEBUG_STRIPPED">
            <summary>
            Debugging info stripped from file in .DBG file
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.REMOVABLE_RUN_FROM_SWAP">
            <summary>
            If Image is on removable media, copy and run from the swap file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.NET_RUN_FROM_SWAP">
            <summary>
            If Image is on Net, copy and run from the swap file.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.SYSTEM">
            <summary>
            This flag is used to indicate that the file
            is a system file, such as device driver.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.DLL">
            <summary>
            This flag indicates that the file
            is a dynamic library (DLL).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.UP_SYSTEM_ONLY">
            <summary>
            File should only be run on a uniprocessor (UP) machine.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Characteristics.BYTES_REVERSED_HI">
            <summary>
            Bytes of machine word are reversed.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.CLIFlags">
            <remarks>
            <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Required32Bit"/> and <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Preferred32Bit"/> flags interact as a pair
            (retaining backwards compatibility with pre-4.5 runtimes/OSs, which don't know about <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Preferred32Bit"/>):
            <list type = "table">
            <listheader>
            <term> <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Required32Bit"/> / <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.Preferred32Bit"/> </term> <description> </description>
            </listheader>
            <item> <term> 0 / 0 </term> <description> no special meaning, <see cref="T:JetBrains.Interop.WinApi.MachineId"/> and <see cref="F:JetBrains.Metadata.Utils.PE.CLIFlags.IlOnly"/> flag determine image requirements </description> </item>
            <item> <term> 0 / 1 </term> <description> illegal </description> </item>
            <item> <term> 1 / 0 </term> <description> image is x86-specific </description> </item>
            <item> <term> 1 / 1 </term> <description> image is platform neutral and prefers to be loaded 32-bit when possible </description> </item>
            </list>
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.CLIHeader">
            <summary>
            CLI (Cor20) header
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.CLIHeader.#ctor(JetBrains.Metadata.Utils.IBinaryReader,JetBrains.Metadata.Utils.PE.PEFile)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
            <param name="file"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CLIHeader.Size">
            <summary>
            cb
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.CoffHeader">
            <summary>
            COFF header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.Signature">
            <summary>
            A 4-byte signature identifying the file as a PE image. The bytes are "PE\0\0"
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.Machine">
            <summary>
            The architecture type of the computer.
            An image file can only be run on the specified computer or a system that emulates the specified computer.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.NumberOfSections">
            <summary>
            The number of sections.
            This indicates the size of the section table, which immediately follows the headers.
            Note that the Windows loader limits the number of sections to 96.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.TimeDateStamp">
            <summary>
            The low 32 bits of the time stamp of the image.
            This represents the date and time the image was created by the linker.
            The value is represented in the number of seconds elapsed since
            midnight (00:00:00), January 1, 1970, Universal Coordinated Time, according to the system clock.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.PointerToSymbolTable">
            <summary>
            The offset of the symbol table, in bytes, or zero if no COFF symbol table exists.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.NumberOfSymbols">
            <summary>
            The number of symbols in the symbol table
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.SizeOfOptionalHeader">
            <summary>
            The size of the optional header, in bytes.
            This value should be 0 for object files.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.CoffHeader.Characteristics">
            <summary>
            The characteristics of the image
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.DataDirectory">
            <summary>
            PE section information record
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.DataDirectory.RVA">
            <summary>
            Data RVA
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.DataDirectory.Size">
            <summary>
            Data size
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugDataInfo">
            <summary>
            Base information about debug entry
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDataInfo.Age">
            <summary>
            Ever-incrementing value, which is initially set to 1 and
            incremented every time when a part of the PDB file is updated without rewriting the whole file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDataInfo.PdbFile">
            <summary>
            Name of the PDB file.
            It can also contain full or partial path to the file
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugInfo2">
            <summary>
            PDB 2.0 debugging info
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugInfo2.Timestamp">
            <summary>
            The time when debug information was created
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugInfo7">
            <summary>
            PDB 7.0 Debugging info
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugInfo7.Signature">
            <summary>
            A unique identifier, which changes with every rebuild of the executable and PDB file
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory">
            <summary>
            Debug information headers in PE FILE.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entries">
            <summary>
            Debug info entries located in directory
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Read(JetBrains.Metadata.Utils.IBinaryReader,System.Int32,JetBrains.Metadata.Utils.PE.PEFile)">
            <summary>
            Read directory
            </summary>
            <param name="rdr">reader</param>
            <param name="size">Size of directory</param>
            <param name="peFile"></param>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry">
            <summary>
            Debug Directory entry
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.#ctor(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="rdr">Binary reader</param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.Characteristics">
            <summary>
            Entry params
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.TimeDateStamp">
            <summary>
            Seconds from 1970
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.MajorVersion">
            <summary>
            Major version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.MinorVersion">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.Type">
            <summary>
            Debug info type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.SizeOfData">
            <summary>
            Data size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.AddressOfRawData">
            <summary>
            Address in PE file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.PointerToRawData">
            <summary>
            Pointer to the data in PE File
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.Entry.GetEntry">
            <summary>
            Returns actual info stored in the referencied PE block
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.DebugDirectory.ReadDebugDataInfo(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            Read DebugInfo7 or DebugInfo2 structure from stream
            Caller must be sure that current stream position points to the begining of DebugInfo record
            Returns null if there is no proper signature in stream (neither CodeViewSignaturePdb7 nor CodeViewSignaturePdb2)
            </summary>
            <param name="reader"></param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugInfo.Signature">
            <summary>
            Signature of PDB for <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows" /> and <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable" />, Guid.Empty for other types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugInfo.AgeOrTimestamp">
            <summary>
            Age of PDB for <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows" />, TimeDateStamp of PDB for <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable" />, 0 for other types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.DebugInfo.PdbFile">
            <summary>
            Name of the PDB file for <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows" /> and <see cref="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable" />
            (it can also contain full or partial path to the file),
            null for other types
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Windows">
            <summary>
            <para>Type 2 (CodeView), data format version Major=0, Minor=0: standalone Windows (native) PDB</para>
            <para>Path, Signature and Age can be used to find the corresponding PDB file</para>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Portable">
            <summary>
            <para>Type 2 (CodeView), data format version Major=any, Minor=0x504d: standalone portable PDB</para>
            <para>Together 16 bytes of the Signature concatenated with 4 bytes of the TimeDateStamp form a PDB ID
            that should be used to match the PE/COFF image with the associated PDB (instead of Signature and Age; the Age shall be 1)</para>
            <para>Matching PDB ID is stored in the #Pdb stream of the .pdb file</para>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.EmbeddedPortable">
            <summary>
            Type 17, data format version Major=any, Minor=0x0100: embedded portable PDB
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Directories.DebugInfoType.Deterministic">
            <summary>
            <para>Type 16, other fields shall be zero</para>
            <para>Presence of this entry indicates that the containing PE/COFF file is deterministic</para>
            <para>If the containing PE/COFF file is deterministic the Signature and TimeDateStamp of the directory entry
            are calculated deterministically based solely on the content of the associated .pdb file.
            Otherwise the value of Signature is random and the value of TimeDateStamp indicates the time and date that the debug data was created.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.DebugType">
            <summary>
            Summary description for DebugType.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.ExportDirectory">
            <summary>
            Export headers in PE FILE.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.ExportDirectory.Read(JetBrains.Metadata.Utils.IBinaryReader,System.Int32,JetBrains.Metadata.Utils.PE.PEFile)">
            <summary>
            Read directory
            </summary>
            <param name="rdr">reader</param>
            <param name="size">Size of directory</param>
            <param name="peFile"></param>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.ExportDirectory.NameEntry">
            <summary>
            Export Directory Name with info
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.ExportDirectory.NameEntry.#ctor(System.UInt32,System.String,System.UInt16,System.UInt32)">
            <summary>
            Export Directory Name with info
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase">
            <summary>
            Base class for PE directory
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.Directories.PEDirectoryBase.Read(JetBrains.Metadata.Utils.IBinaryReader,System.Int32,JetBrains.Metadata.Utils.PE.PEFile)">
            <summary>
            Read directory
            </summary>
            <param name="rdr">reader</param>
            <param name="size">Size of directory</param>
            <param name="peFile"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry.OffsetToData">
            <summary>
            (Data RVA)
            Address of a unit of resource data in the Resource Data area
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry.Size">
            <summary>
            Size, in bytes, of the resource data pointed to by the OffsetToData (Data RVA) field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry.Codepage">
            <summary>
            Code page used to decode code point values within the resource data.
            Typically, the code page would be the Unicode code page.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.Directories.ResourceDataEntry.Reserved">
            <summary>
            Reserved (must be set to 0)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Directories.ResourceType">
            <summary>
            https://docs.microsoft.com/en-us/windows/desktop/menurc/resource-types
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.DllCharacteristics">
            <summary>
            Optional NT header DllCharacteristics entry meanings
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.HighEntropyVa">
            <summary>
            ASLR with 64 bit address space
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.DynamicBase">
            <summary>
            DLL can be relocated at load time
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.ForceIntegrity">
            <summary>
            Code integrity checks are enforced
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.NxCompat">
            <summary>
            Image is NX compatible
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.NoIsolation">
            <summary>
            Isolation aware, but do not isolate the image
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.NoSeh">
            <summary>
            Does not use structured exception handling (SEH).
            No SEH handler may be called in this image
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.NoBind">
            <summary>
            Do not bind the image
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.Appcontainer">
            <summary>
            Image should execute in an AppContainer
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.WdmDriver">
            <summary>
            A WDM driver
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.GuardCf">
            <summary>
            Image supports Control Flow Guard
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.DllCharacteristics.TerminalServerAware">
            <summary>
            Terminal Server aware
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.ExeSignature">
            <summary>
            Image signatures
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.DOS">
            <summary>
             "MZ"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.OS2">
            <summary>
            "NE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.OS2_LE">
            <summary>
             "LE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.VXD">
            <summary>
             "LE"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.NT">
            <summary>
             "PE", the complete signature is "PE\0\0"
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.ExeSignature.NT2">
            <summary>
            second part of the PE FULL sig
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.Signature">
            <summary>
            Netadata header signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.MajorVersion">
            <summary>
            Major version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.MinorVersion">
            <summary>
            Minor version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.Reserved">
            <summary>
            Reserved
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.VersionString">
            <summary>
            CLR version
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.VersionStringLength">
            <summary>
            The length of the ASCII version string.
            The length has to be rounded up to a multiple of 4
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.Flags">
            <summary>
            Metadata flags
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.MetadataHeader.StreamHeaders">
            <summary>
            Metadata streams information
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.MetadataReaderException">
            <summary>
            Exceptions raised during module IL reading
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor">
            <summary>
            Ctor
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message">Exception reason</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message">Exception reason</param>
            <param name="innerException">Inner exception</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.MetadataReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Special ctor for deserialization
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptHeaderSize">
            <summary>
            Standard HT optional header sizes
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_ROM_OPTIONAL_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_STD_OPTIONAL_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_NT_OPTIONAL32_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.OptHeaderSize.IMAGE_SIZEOF_NT_OPTIONAL64_HEADER">
            <summary>
            
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptionalNtHeader32">
            <summary>
            NT header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.BaseOfData">
            <summary>
            A pointer to the beginning of the data section, relative to the image base
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.ImageBase">
            <summary>
            The preferred address of the first byte of the image when it is loaded in memory.
            This value is a multiple of 64K bytes.
            The default value for DLLs is 0x10000000.
            The default value for applications is 0x00400000,
            except on Windows CE where it is 0x00010000
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.SizeOfStackReserve">
            <summary>
            The number of bytes to reserve for the stack.
            Only the memory specified by the SizeOfStackCommit member is committed at load time;
            the rest is made available one page at a time until this reserve size is reached.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.SizeOfStackCommit">
            <summary>
            The number of bytes to commit for the stack
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.SizeOfHeapReserve">
            <summary>
            The number of bytes to reserve for the local heap.
            Only the memory specified by the SizeOfHeapCommit member is committed at load time;
            the rest is made available one page at a time until this reserve size is reached.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader32.SizeOfHeapCommit">
            <summary>
            The number of bytes to commit for the local heap
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.OptionalNtHeader64">
            <summary>
            NT header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader64.ImageBase">
            <summary>
            The preferred address of the first byte of the image when it is loaded in memory.
            This value is a multiple of 64K bytes.
            The default value for DLLs is 0x10000000.
            The default value for applications is 0x00400000,
            except on Windows CE where it is 0x00010000
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader64.SizeOfStackReserve">
            <summary>
            The number of bytes to reserve for the stack.
            Only the memory specified by the SizeOfStackCommit member is committed at load time;
            the rest is made available one page at a time until this reserve size is reached.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader64.SizeOfStackCommit">
            <summary>
            The number of bytes to commit for the stack
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader64.SizeOfHeapReserve">
            <summary>
            The number of bytes to reserve for the local heap.
            Only the memory specified by the SizeOfHeapCommit member is committed at load time;
            the rest is made available one page at a time until this reserve size is reached.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeader64.SizeOfHeapCommit">
            <summary>
            The number of bytes to commit for the local heap
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.SectionAlignment">
            <summary>
            The alignment of sections loaded in memory, in bytes.
            This value must be greater than or equal to the FileAlignment member.
            The default value is the page size for the system.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.FileAlignment">
            <summary>
            The alignment of the raw data of sections in the image file, in bytes.
            The value should be a power of 2 between 512 and 64K (inclusive).
            The default is 512.
            If the SectionAlignment member is less than the system page size, this member must be the same as SectionAlignment.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MajorOperatingSystemVersion">
            <summary>
            The major version number of the required operating system
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MinorOperatingSystemVersion">
            <summary>
            The minor version number of the required operating system
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MajorImageVersion">
            <summary>
            The major version number of the image
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MinorImageVersion">
            <summary>
            The minor version number of the image
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MajorSubsystemVersion">
            <summary>
            The major version number of the subsystem
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.MinorSubsystemVersion">
            <summary>
            The minor version number of the subsystem
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.Win32VersionValue">
            <summary>
            This member is reserved and must be 0
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.SizeOfImage">
            <summary>
            The size of the image, in bytes, including all headers.
            Must be a multiple of SectionAlignment
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.SizeOfHeaders">
            <summary>
            The combined size of the following items, rounded to a multiple of the value specified in the FileAlignment member:
            - e_lfanew member of DOS header,
            - 4 byte signature,
            - size of optional header,
            - size of all section headers.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.CheckSum">
            <summary>
            The image file checksum.
            The following files are validated at load time:
            all drivers, any DLL loaded at boot time, and any DLL loaded into a critical system process.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.Subsystem">
            <summary>
            The subsystem required to run this image
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.DllCharacteristics">
            <summary>
            The DLL characteristics of the image
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.LoaderFlags">
            <summary>
            This member is obsolete
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.OptionalNtHeaderBase.NumberOfRvaAndSizes">
            <summary>
            The number of directory entries in the remainder of the optional header.
            Each entry describes a location and size
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PeDirectoryEntry">
            <summary>
            PE File directory entry
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PEFile">
            <summary>
            Portable Executable file
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.#ctor(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader">PE file native image reader</param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.DOSheader">
            <summary>
            PE File DOS stub header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.COFFheader">
            <summary>
            PE File COFF header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.PEHeader">
            <summary>
            PE File PE header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.NTHeader">
            <summary>
            PE File Optional NT header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.Entries">
            <summary>
            PE File directory infos
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.Sections">
            <summary>
            PE file sections dictionary
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.CLIHeader">
            <summary>
            PE File CLI data header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.ReadyToRunHeader">
            <summary>
            R2R header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.MetadataHeader">
            <summary>
            CLI Metadata Header
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.GetDirectory(JetBrains.Metadata.Utils.PE.PeDirectoryEntry)">
            <summary>
            Read directory from PE File
            </summary>
            <param name="directoryId"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.RvaToVa(System.UInt32)">
            <summary>
            Translate Relative Virtual Address (RVA) to the actual Virtual Address (VA)
            </summary>
            <param name="rva">RVA to translate</param>
            <returns></returns>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEFile.IsValid">
            <summary>
            Returns <c>False</c> if the DOS header was not detected.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFile.CreateDirectory(JetBrains.Metadata.Utils.PE.PeDirectoryEntry,System.Int32)">
            <summary>
            Create PE directory according its Index
            </summary>
            <param name="directoryId">Directory index</param>
            <param name="dirSize">Size of directory</param>
            <returns>Created object or null if:
            <list type="bullet">
             <item>
               <description>Directory type not implemented yet</description>
             </item>
             <item>
               <description>Passed Size of the directory less than required</description>
             </item>
             <item>
               <description>Unknown directory index passed</description>
             </item>
            </list>
            </returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.PEFileEx.GetEntryPoint(JetBrains.Metadata.Utils.PE.PEFile)">
            <returns>MetadataToken.Nil if entry point is absent</returns>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PEHeader">
            <summary>
            PE file section header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.Magic">
            <summary>
            The state of the image file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.MajorLinkerVersion">
            <summary>
            The major version number of the linker
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.MinorLinkerVersion">
            <summary>
            The minor version number of the linker
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.SizeOfCode">
            <summary>
            The size of the code section, in bytes, or the sum of all such sections if there are multiple code sections
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.SizeOfInitializedData">
            <summary>
            The size of the initialized data section, in bytes, or the sum of all such sections if there are multiple initialized data sections
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.SizeOfUninitializedData">
            <summary>
            he size of the uninitialized data section, in bytes, or the sum of all such sections if there are multiple uninitialized data sections
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.AddressOfEntryPoint">
            <summary>
            A pointer to the entry point function, relative to the image base address.
            For executable files, this is the starting address.
            For device drivers, this is the address of the initialization function.
            The entry point function is optional for DLLs.
            When no entry point is present, this member is zero.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.PEHeader.BaseOfCode">
            <summary>
            A pointer to the beginning of the code section, relative to the image base
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.PESignature">
            <summary>
            PE Header magic numbers
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.PESignature.PE_32BIT">
            <summary>
            PE Is 32 bit executable
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.PESignature.PE_64BIT">
            <summary>
            PE is 64 bit executable (PE32+)
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.PESignature.PE_ROM">
            <summary>
            PE is a ROM image
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.SectionCharacteristics">
            <summary>
            Section header Characteristics entry meanings
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeDsect">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeNoload">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeGroup">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeNoPad">
            <summary>
            Section should not be padded to next boundary.
            This is obsolete and replaced by Align1Bytes.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeCopy">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.CntCode">
            <summary>
            Section contains executable code
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.CntInitializedData">
            <summary>
            Section contains initialized data
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.CntUninitializedData">
            <summary>
            Section contains uninitialized data
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.LnkOther">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.LnkInfo">
            <summary>
            Section contains comments or other information.
            The .drectve section has this type.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.TypeOver">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.LnkRemove">
            <summary>
            Section will not become part of the image.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.LnkComdat">
            <summary>
            Section contains COMDAT data.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.NoDeferSpecExc">
            <summary>
            Reset speculative exceptions handling bits in the TLB entries for this section
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Gprel">
            <summary>
            The section contains data referenced through the global pointer
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemPurgeable">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemLocked">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemPreload">
            <summary>
            Reserved for future use
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align1Bytes">
            <summary>
            Align data on a 1-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align2Bytes">
            <summary>
            Align data on a 2-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align4Bytes">
            <summary>
            Align data on a 4-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align8Bytes">
            <summary>
            Align data on a 8-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align16Bytes">
            <summary>
            Align data on a 16-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align32Bytes">
            <summary>
            Align data on a 32-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align64Bytes">
            <summary>
            Align data on a 64-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align128Bytes">
            <summary>
            Align data on a 128-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align256Bytes">
            <summary>
            Align data on a 256-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align512Bytes">
            <summary>
            Align data on a 512-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align1024Bytes">
            <summary>
            Align data on a 1024-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align2048Bytes">
            <summary>
            Align data on a 2048-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align4096Bytes">
            <summary>
            Align data on a 4096-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.Align8192Bytes">
            <summary>
            Align data on a 8192-byte boundary.
            This is valid for object files only
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.LnkNrelocOvfl">
            <summary>
            Section contains extended relocations.
            The count of relocations for the section exceeds the 16 bits that is reserved for it in the section header.
            If the NumberOfRelocations field in the section header is 0xffff, the actual relocation count is stored in the VirtualAddress field of the first relocation.
            It is an error if LnkNrelocOvfl is set and there are fewer than 0xffff relocations in the section
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemDiscardable">
            <summary>
            Section can be discarded as needed
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemNotCached">
            <summary>
            Section cannot be cached
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemNotPaged">
            <summary>
            Section is not pageable
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemShared">
            <summary>
            Section can be shared in memory
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemExecute">
            <summary>
            Section can be executed as code
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemRead">
            <summary>
            Section can be read
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.SectionCharacteristics.MemWrite">
            <summary>
            Section can be written to
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.SectionHeader">
            <summary>
            PE File section header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.VirtualSize">
            <summary>
            The total size of the section when loaded into memory, in bytes.
            If this value is greater than the SizeOfRawData member, the section is filled with zeroes.
            This field is valid only for executable images and should be set to 0 for object files.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.VirtualAddress">
            <summary>
            The address of the first byte of the section when loaded into memory, relative to the image base.
            For object files, this is the address of the first byte before relocation is applied.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.SizeOfRawData">
            <summary>
            The size of the initialized data on disk, in bytes.
            This value must be a multiple of the FileAlignment member of the Optional header structure.
            If this value is less than the VirtualSize member, the remainder of the section is filled with zeroes.
            If the section contains only uninitialized data, the member is zero.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.PointerToRawData">
            <summary>
            A file pointer to the first page within the COFF file.
            This value must be a multiple of the FileAlignment member of the Optional header structure.
            If a section contains only uninitialized data, set this member is zero.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.PointerToRelocations">
            <summary>
            A file pointer to the beginning of the relocation entries for the section.
            If there are no relocations, this value is zero.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.PointerToLineNumbers">
            <summary>
            A file pointer to the beginning of the line-number entries for the section.
            If there are no COFF line numbers, this value is zero.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.NumberOfRelocations">
            <summary>
            The number of relocation entries for the section.
            This value is zero for executable images.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.NumberOfLineNumbers">
            <summary>
            The number of line-number entries for the section.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.SectionHeader.Characteristics">
            <summary>
            The characteristics of the image
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.StreamHeader">
            <summary>
            Metadata stream information
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.PE.StreamHeader.#ctor(JetBrains.Metadata.Utils.IBinaryReader)">
            <summary>
            ctor
            </summary>
            <param name="reader"></param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Offset">
            <summary>
            Stream offset in PE file from metadata header
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Size">
            <summary>
            Stream size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.PE.StreamHeader.Name">
            <summary>
            Stream name
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.PE.Subsystem">
            <summary>
            Optional NT header Subsystem entry meanings
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.UNKNOWN">
            <summary>
            Unknown subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.NATIVE">
            <summary>
            Image doesn't require a subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_GUI">
            <summary>
            Image runs in the Windows GUI subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_CUI">
            <summary>
            Image runs in the Windows character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.OS2_CUI">
            <summary>
            Image runs in the OS/2 character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.POSIX_CUI">
            <summary>
             Image runs in the Posix character subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.NATIVE_WINDOWS">
            <summary>
            Image is a native Win9x driver.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_CE_GUI">
            <summary>
            Image runs in the Windows CE subsystem.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_APPLICATION">
            <summary>
            An EFI application.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_BOOT_SERVICE_DRIVER">
            <summary>
            An EFI driver with boot services.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_RUNTIME_DRIVER">
            <summary>
            An EFI driver with run-time services.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.EFI_ROM">
            <summary>
            An EFI ROM image.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.XBOX">
            <summary>
            XBOX.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.PE.Subsystem.WINDOWS_BOOT_APPLICATION">
            <summary>
            A BCD application.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.SdkModuleInfo">
            <summary>
            data class to be used to create SdkModule from it.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.SdkModuleInfo.ManifestPath">
            <summary>
            Path to SDKManifest.xml file
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.SdkModuleInfo.NestedAssemblies">
            <summary>
            Those content files which are assemblies (not included in ContentFiles hash set)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.SdkModuleInfo.ContentFiles">
            <summary>
            Content files to be processed (i.e. css, js)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.SdkModuleInfo.HierarchyItems">
            <summary>
            All items including folders
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Utils.StreamBinaryReader.myBufSizePositionInStream">
            <summary>
            A position in <see cref="F:JetBrains.Metadata.Utils.StreamBinaryReader.myStream" /> coordinates which corresponds to the end of the usable data in <see cref="F:JetBrains.Metadata.Utils.StreamBinaryReader.myBuf" />.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.StreamBinaryReader.AssertValidBuffer">
            <summary>
            Self-check to make sure that the pre-fetched buffer still corresponds the stream.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.TargetPlatformData">
            <summary>
            Data class which represents an info about a hardware platform, the selected project is applicable to. 
            I.e.'Windows, 8.0'
            Is necessary to determine which sdk modules might be applicable to the selected project.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.ToolLocationHelper.EnumerateContentRoots(JetBrains.Util.VirtualFileSystemPath,System.String,System.String)">
            <summary>
            Enumerates sdk content roots. Can return nulls. The first enumerated not null value will be the most specific content root.
            </summary>
            <param name="sdkRoot">path to a directory containing sdkManifest.xml file</param>
            <param name="targetConfiguration">commonConfiguration, retail, debug</param>
            <param name="targetArchitecture">x64, x86, ARM, neutral</param>
            <returns>Nullable paths. The first enumerated not null value will be the most specific contnet root. Results may be not distinct.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.ToolLocationHelper.GetSdkModuleInfo(JetBrains.Util.VirtualFileSystemPath,System.Collections.Generic.ICollection{JetBrains.Util.VirtualFileSystemPath})">
            <summary>
            Reads sdk manfest file and fills SdkModuleInfo with sdk content files
            see http://msdn.microsoft.com/en-us/library/hh768146(v=vs.110).aspx for more information
            </summary>
            <param name="manifestPath">path to a directory with sdkManifest file</param>
            <param name="contentRoots">most specific path to sdk content files</param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.ToolLocationHelper.RetrieveSdkModuleInfo(JetBrains.Util.VirtualFileSystemPath,JetBrains.Util.VirtualFileSystemPath,System.Xml.XmlElement)">
            <summary>
            creates the new instance of SdkModuleInfo 
            </summary>
            <param name="contentRoot">The content root path. Sometimes need to resolve relative path references to js files from html</param>
            <param name="manifestPath"></param>
            <param name="fileListElement"></param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException.#ctor(System.String)">
            <summary>
            Ctor
            </summary>
            <param name="message">Error Message</param>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.InvalidTypeNameException.#ctor(System.String,System.Exception)">
            <summary>
            Ctor
            </summary>
            <param name="message">Error Message</param>
            <param name="exInner">Exception that cause PE loading error</param>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.NameToken.Value">
            <summary>
            Token Value
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.NameToken.Range">
            <summary>
            Token Range
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.ParsedTypeName.ElementType">
            <summary>
            Name of the underlying type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Utils.TypeName.Parser">
            <summary>
            .NET Type names parser
            </summary>
            <remarks>
            Type Name BNF
            AQN                := FULLNAME
                               := FULLNAME ASSEMSPEC
               FULLNAME        := NAME
                               := NAME QUALIFIERS
                               := NAME GENPARAMS                    
                               := NAME GENPARAMS QUALIFIERS
            NAME               := T_NAME
            GENPARAMS          := '[' GENARGS ']'
            QUALIFIERS         := QUALIFIER
                               := QUALIFIER QUALIFIERS
            QUALIFIER          := 
                               := '*' 
                               := '&amp;'
                               := ARRAY
               ARRAY           := '[' ']'                 
                               := '[' '*' ']'                 
                               := '[' RANK ']'                 
            RANK               :=
                               := ',' RANK
            GENARGS            := GENARG
                               := GENARG ',' GENARGS
               GENARG          := FULLNAME
                               := '[' EAQN ']'
               EAQN            := FULLNAME
                               := EASSEMSPEC
               EASSEMSPEC      := FULLNAME ',' ASSEMSPEC
            T_NAME    == \d|_[^\.\,\*\&amp;\{\[\}\]\?\&lt;\&gt;]*
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Utils.TypeName.Parser.TypeName">
            <summary>
            Parsing result;
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.START">
            <summary>
            Start state
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.AQN">
            <summary>
            Assembly qualified name
            </summary>
            <returns></returns>
            <remarks>
            /* empty */
            FULLNAME ',' ASSEMSPEC
            FULLNAME
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.ASSEMSPEC">
            <summary>
            Assembly specification
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.FULLNAME">
            <summary>
            Type fullName
            </summary>
            <returns></returns>
            <remarks>
            NAME GENPARAMS QUALIFIER
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.GENPARAMS">
            <summary>
            Generic parameters
            </summary>
            <returns></returns>
            <remarks>
            *empty*
            '[' GENARGS ']'
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.GENARGS">
            <summary>
            Generic argument
            </summary>
            <returns></returns>
            <remarks>
            GENARG
            GENARG ',' GENARGS
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.EAQN">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            '[' EAQN ']'
            FULLNAME
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.QUALIFIER">
            <summary>
            type qualifier
            </summary>
            <returns></returns>
            <remarks>
            *empty*
            '&amp;'
            '*' QUALIFIER
            ARRAY QUALIFIER
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.ARRAY">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            '[' RANK ']'
            '[' '*' ']'
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.RANK(System.UInt32@)">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            *empty*
            ',' RANK
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Utils.TypeName.Parser.NAME">
            <summary>
            
            </summary>
            <returns></returns>
            <remarks>
            id
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetInitialTableSize(JetBrains.Metadata.Access.MetadataTableId)">
            <summary>
            Row count for initial metadata table
            (Generation 0, without EnC delta additional rows)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.EditAndContinue.IAggregatedStreamsAccess.GetInitialTableRow(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Row in initial metadata table (no redirects) for token with rid &lt;= GetInitialTableSize,
            GetInitialTableRow otherwise
            </summary>
            <remarks>
            E.g. rows in metadata delta TypeDef table have 0 (null) values for MethodList and FieldList
            =>
            need to use the corresponding values from the original (initial) table
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.EditAndContinue.IEncMetadataAccess.EncId">
            <summary>
            Unique Guid for delta metadata,
            Guid.Empty for full metadata.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.EditAndContinue.IEncMetadataAccess.Generation">
            <summary>
            Zero for initial metadata,
            non-zero for initial metadata combined with EnC deltas.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock.StartOffset">
            <summary>
            Offset of the first instruction of the block
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock.EndOffset">
            <summary>
            Offset of the first instruction following the block
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock.Parent">
            <summary>
            Containing block
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.CodeBlocks.IlCodeBlock.mySortedChildren">
            <summary>
            Children sorted by start offset
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ExceptionHandler">
            <summary>
            MSIL exception handler record
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ExceptionHandlerType">
            <summary>
            Exception handler type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.FlowControl">
            <summary>
             IL Code FlowControl enumeration
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IInstructionRedirector.Redirect(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Instruction redirection
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderType(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType[],JetBrains.Metadata.Reader.API.IMetadataType[],JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            II.7.1: Type ::= ...
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderTypeReference(JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            II.7.3: TypeReference ::= [ ResolutionScope ] DottedName [ '/' DottedName ]*
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderResolutionScope(JetBrains.Metadata.Utils.AssemblyNameInfo)">
            <summary>
            II.7.1: ResolutionScope ::= '[' [ .module ] DottedName ']'
            ('[' .module Filename ']' | '[' AssemblyRefName ']')
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderTypeSpec(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType[],JetBrains.Metadata.Reader.API.IMetadataType[],JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            II.7.1: TypeSpec ::= ResolutionScope | TypeReference | Type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderDottedName(System.String)">
            <summary>
            II.5.3: DottedName ::= Id ['.' Id]*
            Id ::= ID | SQSTRING
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderId(System.String)">
            <summary>
             II.5.3: Id ::= ID | SQSTRING
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.IsID(System.String,System.Boolean)">
            <summary>
            Checks whether the s is ID (or ID ['.' ID]* if dotSeparatedIDs)
            II.5.2: ID is a contiguous string of characters which starts with either an alphabetic character (A–Z, a–z)
            or one of "_", "$", "@", "`" (grave accent), or "?",
            and is followed by any number of alphanumeric characters (A–Z, a–z, 0–9) or the characters "_", "$", "@", "`", and "?". 
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderQString(System.String)">
            <summary>
            II.5.2: String surrounded by double quote (") marks
            Within the quoted string the character "\" can be used as an escape character,
            with "\t" representing a tab character, "\n" representing a newline character,
            or "\" followed by three octal digits representing a byte with that value.
            The "+" operator can be used to concatenate string literals.
            This way, a long string can be broken across multiple lines by using "+" and a new string on each line.
            An alternative is to use "\" as the last character in a line, in which case,
            that character and the line break following it are not entered into the generated string.
            Any white space characters (space, line-feed, carriage-return, and tab) between 
            the "\" and the first non-white space character on the next line are ignored
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderSqString(System.String)">
            <summary>
            II.5.2: SQSTRING is just like QSTRING except that the former uses single quote (') marks instead of double
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderString(System.String,System.Boolean)">
            <summary>
            QSTRING or bytearray
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderGenericParameters(JetBrains.Metadata.Reader.API.IMetadataTypeParameter[])">
            <summary>
            II.10.1.7: Generic parameters with attributes and constraints
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderGenPar(JetBrains.Metadata.Reader.API.IMetadataTypeParameter)">
            <summary>
            II.10.1.7: GenPar::= [  [  GenParAttribs ]* [ '(' [ GenConstraints ] ')' ]  Id
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderSecurityDecl(JetBrains.Metadata.Reader.API.IMetadataSecurityOwner)">
            <summary>
            II.20: SecurityDecl ::= .permissionset SecAction = '(' Bytes ')'
            | .permission SecAction TypeReference '(' NameValPairs ')'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderSecAction(JetBrains.Metadata.Reader.API.SecurityAction)">
            <summary>
            II.20: SecAction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderFieldInit(System.Object,System.Boolean)">
            <summary>
            II.16.2
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderSpecialnameAttributes(JetBrains.Metadata.Reader.API.IMetadataTypeMember)">
            <summary>
            II.10.1.6, II.15.4.2.6, II.16.1.4, II.17, II.18
            </summary>
            <param name="typeMember"></param>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderAccessor(JetBrains.Metadata.Reader.API.IMetadataMethod,System.String)">
            <summary>
            II.17, II.18
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderType(JetBrains.Metadata.Reader.API.IMetadataTypeInfo,JetBrains.Metadata.Reader.API.IImageBodyReader)">
            <summary>
            II.10: .class ClassHeader '{' ClassMember* '}'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderTypeAssociatedAttributes(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Custom and declarative security attributes
            and
            custom attributes of type parameters and type parameters constraints (for a generic type)
            and
            custom attributes of interface implementations
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderLayoutControl(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Instance layout
            II.10.2, II.10.7: .pack Int32 | .size Int32
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderClassHeader(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Type (class, value type, or interface) header
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderClassAttributes(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            II.10.1: ClassAttr*
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderLocalVariables(JetBrains.Metadata.Reader.API.IMethodBody)">
            <summary>
            II.15.4.1.3: .locals  [ init ] '(' LocalsSignature ')'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderLocal(JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable)">
            <summary>
            Local variable
            15.4.1.3: Local ::= [ '[' Int32 ']' ] Type [ Id ]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderCommentedTupleElementNames(JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable)">
            <summary>
            render variable tuple element names from pdb / decompiler
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderEvent(JetBrains.Metadata.Reader.API.IMetadataEvent)">
            <summary>
            II.18: .event EventHeader '{' EventMember* '}'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderEventHeader(JetBrains.Metadata.Reader.API.IMetadataEvent)">
            <summary>
            .event EventHeader
            II.18: EventHeader ::= [ specialname ] [ rtspecialname ] [ TypeSpec ] Id
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderField(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Render field and custom field attributes
            II.16: Field ::= .field FieldDecl
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderFieldHeader(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            .field FieldDecl
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderFieldDecl(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            II.16: FieldDecl ::= [ '[' Int32 ']' ] FieldAttr* Type Id [ '=' FieldInit | at DataLabel ]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderFieldAttributes(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            II.16.1: FieldAttr*
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMarshallingInformation(JetBrains.Metadata.Utils.IBlob,System.Boolean)">
            <summary>
            II.7.4, II.15.4, II.16.1: [ marshal '(' [ NativeType ] ')' ]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderNativeType(JetBrains.Metadata.Reader.API.MarshalSpec.NativeType,JetBrains.Metadata.Reader.API.MarshalSpec.IMarshalSpec)">
            <summary>
            II.7.4
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethod(JetBrains.Metadata.Reader.API.IMetadataMethod,JetBrains.Metadata.Reader.API.IImageBodyReader)">
            <summary>
            II.15: .method MethodHeader '{' MethodBodyItem* '}'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethodAssociatedInfo(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Attributes, entry point, parameters default values and attributes, type parameters and type parameters constraints attributes, implemented methods
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethodName(System.String)">
            <summary>
            II.15.4: MethodName ::= .cctor | .ctor | DottedName
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethodAttributes(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            II.15.4.2: MethAttr*
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderPlatformInvoke(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            II.15.4.2.5: [ pinvokeimpl '(' QSTRING [ as QSTRING ] PinvAttr* ')' ]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderCallConv(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            II.15.3: CallConv ::= [ instance [ explicit ]] [ CallKind ]
            A calling convention specifies how a method expects its arguments to be passed from the caller to the called method.
            It consists of two parts:
            the first deals with the existence and type of this pointer,
            while the second relates to the mechanism for transporting the arguments
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethodParameters(JetBrains.Metadata.Reader.API.IMetadataMethod,System.Boolean,System.Boolean,System.Int32)">
            <summary>
            II.15.4: '(' Parameters ')'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderMethodImplementationAttributes(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            II.15.4.3: ImplAttr*
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderImplementedMethods(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            II.10.3.2
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderProperty(JetBrains.Metadata.Reader.API.IMetadataProperty)">
            <summary>
            II.17: .property PropHeader '{' PropMember* '}'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderPropertyHeader(JetBrains.Metadata.Reader.API.IMetadataProperty)">
            <summary>
            .property PropHeader
            II.17: PropHeader ::= [ specialname ][ rtspecialname ] CallConv Type Id '(' Parameters ')'
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.WithMultiLineComment(System.Boolean)">
            <remarks>Can be nested: /*parent1/*child*/parent2*/ => /*parent1*//*child*//*parent2*/</remarks>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.RenderLineComment(System.String,System.Boolean)">
            <summary>
            Writes single-line comment characters and comment string 
            and automatically marks end of single-line comment
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.WriteTextWithLineComment(System.String,System.Object[])">
            <summary>
            Writes text with single-line comment characters inside it
            and automatically marks end of single-line comment
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.IlMetadataFormatter.CodeTextWithLineCommentsWriter.MarkLineCommentEnd">
            <summary>
            Adds new line requirenment
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ILMethodBody">
            <summary>
            MSIL Method body
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.ILMethodFlags">
            <summary>
            IL method body flags
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.SmallCode">
            <summary>
            Small Code 
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.TinyCode">
            <summary>
            Tiny code format
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.FatCode">
            <summary>
            Fat code format
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.CodeMask">
            <summary>
            Mask for extract code type
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.InitLocals">
            <summary>
            Runtime call default constructor on all local vars
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.ILMethodFlags.MoreSects">
            <summary>
            there is another attribute after this one
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.Instruction">
            <summary>
            MSIL instruction.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Offset">
            <summary>
            Instruction offset from the method beginning.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Size">
            <summary>
            Instruction size (in bytes) including the operands.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Code">
            <summary>
            Instruction opcode.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.IL.Instruction.Operand">
            <summary>
            Polymorphic operand whose exact type depends on <see cref="P:JetBrains.Metadata.IL.Opcode.OperandType"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.InstructionEx">
            <summary>
            Provides type-safe utilities for extracting <see cref="P:JetBrains.Metadata.IL.Instruction.Operand"/> depending on <see cref="P:JetBrains.Metadata.IL.Opcode.OperandType"/>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionEx.GetBranchTargetOperand(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Target instruction relative offset (from the beginning of the instruction following the current instruction)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionEx.GetNextInstructionOffset(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Next instruction absolute offset (from the beginning of the method)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionEx.GetBranchTargetInstructionOffset(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Target instruction absolute offset (from the beginning of the method)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionEx.GetBranchTargetInstructionIndex(JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.IL.Instruction[])">
            <summary>
            Target instruction index in instructions array
            </summary>
            <param name="instruction"></param>
            <param name="instructions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionEx.GetSwitchTargetInstructionsOffsets(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Target instructions absolute offsets (from the beginning of the method)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetMinimumStackHeightForCallAndCallvirt(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Gets required number of items that should be on stack before execution of this call/callvirt instruction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetMinimumStackHeightForNewobj(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Gets required number of items that should be on stack before execution of this newobj instruction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetMinimumStackHeightForCalli(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Gets required number of items that should be on stack before execution of this calli instruction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetMinimumStackHeightForRet(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Gets required number of items that should be on stack before execution of ret instruction in this method
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetMinimumStackHeight(JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Gets required number of items that should be on stack before execution of this instruction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetStackPushItemsCount(JetBrains.Metadata.IL.Instruction)">
            <summary>
            Gets number of items that are pushed on stack by this instruction
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.InstructionStackEx.GetRequiredPrefixPushCount(JetBrains.Metadata.IL.Instruction,JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Gets number of items that should be pushed into stack before execution of this instruction 
            </summary>
            <remarks>0 - sequence point associated with this instruction is allowed</remarks>
        </member>
        <member name="T:JetBrains.Metadata.IL.Opcode">
            <summary>
            MSIL opcode value
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.IL.OpcodeEx.ResolveNativeInt(JetBrains.Metadata.IL.Opcode,System.Boolean)">
            <summary>
            Replaces *_i/*_u instructions with theirs specified integer variants depending on is64Bit flag
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Metadata.IL.Opcodes">
            <summary>
             OpCodes static definitions
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OpcodeType">
            <summary>
             OpcodeType enumeration
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OpcodeValue">
            <summary>
             Operation codes enumeration
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Break">
            <summary>
            Debugging breakpoint
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Br_s">
            <summary>
            The short-parameter form of br.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Brfalse_s">
            <summary>
            Branch if {value} is zero.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Brtrue_s">
            <summary>
            Branch if {value} is nonzero
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Beq_s">
            <summary>
            Branch if {value1} is equal to {value2}.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.IL.OpcodeValue.Bne_un_s">
            <summary>
            Branch if the two values are not equal. Integer values are interpreted as unsigned
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.OperandType">
            <summary>
            Describes the possible types of <see cref="P:JetBrains.Metadata.IL.Instruction.Operand"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.IL.StackBehavior">
            <summary>
             StackBehaviour enumeration
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.AccessibilityEx.GetOwnAccessibility(JetBrains.Metadata.Reader.API.IMetadataTypeMember)">
            <remarks>
            Accessibility for properties and events
            (type members that do not have explicit accessibility in metadata)
            is the maximum accessibility among the accessors
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.AccessibilityEx.GetActualAccessibility(JetBrains.Metadata.Reader.API.IMetadataTypeMember)">
            <remarks>
            Accessibility for properties and events
            (type members that do not have explicit accessibility in metadata)
            equals to accessibility of containing type
            (accessibility of accessors is not taken into account)
            </remarks>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.AssemblyLocation">
            <summary>
            Assembly location on disk
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.AssemblyReferenceWithSource">
            <summary>
            Data class to encapsulate source module's path and the referenced assembly name to be resolved
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.AssemblyResolverAppDomainAssemblyResolver">
            <summary>
            Enables Fusion's resolving assemblies when loading into the current appdomain based on the <see cref="T:JetBrains.Metadata.Reader.API.IFolderBasedAssemblyResolver" />.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.CompilerSpecificAttributesExtensions.GetMethodCompilerSpecificAttributes(JetBrains.Metadata.Reader.API.IMetadataMethod,System.String)">
            <remarks>methodName is not null if rendered name differs from method.Name
            (e.g. methodName is local function name)</remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver.myGac">
            <summary>
            NULL if lookup in the real GAC has been disabled, that's required if we're planning on modifying the fusion appdomain assembly resolver, might interfere with loading the proper bitness.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver.RuntimeAssemblySources.MachineGac">
            <summary>
            The regular GAC, 2.0, 4.0, etc.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.DotNetFrameworkCurrentRuntimeAssemblyResolver.RuntimeAssemblySources.MachineGacAndVisualStudio">
            <summary>
            Resolve into assemblies of Visual Studio as well.
            With VS up to 14, its assemblies were installed into the GAC, so it worked the regular way.
            With VS 15, assemblies are not getting into GAC, but we still expect that our code is able to use VS assemblies on machines which have VS installed.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.DotNetFrameworkGacAssemblyResolver">
            <summary>
            Searches in gac
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.DotNetFrameworkGacAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.GacResolvePreferences.None">
            <summary>
            Favors the specific version number and public key.
            TODO: should eventually take publisher policies into account.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.GacResolvePreferences.MatchSameOrNewer">
            <summary>
            Prefers the exact match, but also tries to look up a newer assembly with the same name as a fallback.
            This roughly emulates the “unification” e.g. when we're reading a parts catalog on a machine which only has NetFX4+ installed and cannot load “System.Drawing v2.0” for us.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.GacResolvePreferences.RedirectGac20ToGac40">
            <summary>
            If the same assembly is present in both GAC20 and GAC40, take the newer one assuming it covers all of the older functionality.
            This is essential if you're running CLR2 assemblies (with references to v2.0 GAC assemblies) on the new CLR.
            TODO: take assembly unification into account, as probably not all of the assemblies should be redirected this way
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.DotNetRuntimeAssemblyResolver">
            <summary>
            Resolves to .NET Framework runtime assemblies (version 2 and 4 are supported).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.DotNetRuntimeAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.ElementTypeEx.IsImplicitNumericConvertibleTo(JetBrains.Metadata.Reader.API.ElementType,JetBrains.Metadata.Reader.API.ElementType)">
            <summary>
            <list type="bullet">
            <listheader>
            <description>
            C# 2.0 spec paragraph 13.1.2; without decimal
            </description>
            </listheader>
            <item><description>From sbyte to short, int, long, float, double.</description></item>
            <item><description>From byte to short, ushort, int, uint, long, ulong, float, double.</description></item>
            <item><description>From short to int, long, float, double.</description></item>
            <item><description>From ushort to int, uint, long, ulong, float, double.</description></item>
            <item><description>From int to long, float, double.</description></item>
            <item><description>From uint to long, ulong, float, double.</description></item>
            <item><description>From long to float, double.</description></item>
            <item><description>From ulong to float, double.</description></item>
            <item><description>From char to ushort, int, uint, long, ulong, float, double.</description></item>
            <item><description>From float to double.</description></item>
            </list>
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.EmptyResolveContext">
            <summary>
            Suppresses module to module resolution
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IAssemblyLocation">
            <summary>
            Assembly location on disk / file entry inside single file bundle / in memory / etc.
            </summary>
            <remarks>
            It can be not only an assembly, but also a file of another format
            (e.g. .runtimeconfig.json file inside bundle)
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IAssemblyLocation.AssemblyPhysicalPath">
            <remarks>
            null for file entry inside bundle / assembly in memory
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IAssemblyLocation.ContainerPhysicalPath">
            <remarks>
            bundle file path for file entry inside bundle,
            null for assembly in memory
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.AssemblyLocationEx.GetTemporaryPhysicalPath(JetBrains.Metadata.Reader.API.IAssemblyLocation,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Returns AssemblyPhysicalPath if it is not null,
            extracts assembly to temp file otherwise
            </summary>
            <param name="lifetime">lifetime of temporary file</param>
            <param name="assemblyLocation"></param>
            <returns>temporary file path or AssemblyPhysicalPath</returns>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IAssemblyResolver">
            <summary>
            Interface for resolving assembly names to assemblies
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IAssemblyResolver.ResolveAssembly(JetBrains.Metadata.Utils.AssemblyNameInfo,JetBrains.Metadata.Reader.API.IAssemblyLocation@,JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext)">
            <summary>
            Resolves assembly name to assembly metadata interface
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IClrTypeName.GetPersistent">
            <summary>
            Since few implementation relies on internal data, <see cref="T:JetBrains.Metadata.Reader.API.IClrTypeName"/> is valid only during single ReadLock session.
            This returns independent implementation
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IEntityPresentations">
            <summary>
            The main function is to find all presentations of entity using only one presentation, that is:
            <list type="bullet">
              <item>
                Method specs, defs and refs tokens using <see cref="T:JetBrains.Metadata.Reader.API.IMetadataMethod"/> or <see cref="T:JetBrains.Metadata.Access.MetadataToken"/>
                associated with method spec, def or ref.
              </item>
              <item>
                Type specs, defs or refs tokens using <see cref="T:JetBrains.Metadata.Reader.API.IMetadataTypeInfo"/> or <see cref="T:JetBrains.Metadata.Access.MetadataToken"/>
                associated with type spec, def or ref.
              </item>
              <item>
                Field defs or refs tokens using <see cref="T:JetBrains.Metadata.Reader.API.IMetadataField"/> or <see cref="T:JetBrains.Metadata.Access.MetadataToken"/>
                associated with field def or ref.
              </item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetFieldPresentations(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Returns field defs or refs that corresponds to <paramref name="field"/> in this assembly
            </summary>
            <returns>Array of field defs or refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetTypePresentations(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Returns type defs, refs or specs that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>Array of type defs, refs or specs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetMethodPresentations(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns method specs, defs or refs that corresponds to <paramref name="method"/> in this assembly
            </summary>
            <returns>Array of method specs, defs, refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetTokenFromTypeInfo(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Find a token that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>TypeDef or TypeRef or Nil</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetFieldPresentations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Returns field defs or refs that corresponds to <paramref name="token"/> in this assembly
            </summary>
            <returns>Array of field defs or refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetTypePresentations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Returns type defs, refs or specs that corresponds to <paramref name="token"/> in this assembly
            </summary>
            <returns>Array of type defs, refs or specs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IEntityPresentations.GetMethodPresentations(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Returns method specs, defs or refs that corresponds to <paramref name="token"/> in this assembly
            </summary>
            <returns>Array of method specs, defs, refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IFolderBasedAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IImageBodyReader.GetMethodBody(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns method body presentation
            </summary>
            <exception cref="T:JetBrains.Metadata.Utils.PE.MetadataReaderException">Throws if method body reader failed</exception>
            <param name="method"></param>
            <returns>Method body presentation if available, null if no method implementation found</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IImageBodyReader.GetIlMethodBody(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns raw method body presentation. Main difference from GetMethodBody is that Instruction's 
            operands are not resolved.
            </summary>
            <exception cref="T:JetBrains.Metadata.Utils.PE.MetadataReaderException">Throws if method body reader failed</exception>
            <param name="method"></param>
            <returns>Raw method body presentation if available, null if no method implementation found</returns>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataArrayMethod">
            <summary>
            Marker interface to identify array methods
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.ElementType">
            <summary>
            Gets element type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.IsVector">
            <summary>
            Returns whether this type is vector
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.Rank">
            <summary>
            Gets array rank
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.Sizes">
            <summary>
            Gets sizes if specified. Note that sizes might be specified not for all dimensions.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.LBounds">
            <summary>
            Gets low bounds if specified. Note that low bounds might be specified not for all dimensions.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataArrayType.TypeInfo">
            <summary>
            Gets type generated for array
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataAssembly">
            <summary>
            Interface which is used to access metadata of an assembly
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.AssemblyName">
            <summary>
            Gets assembly name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.Id">
            <summary>
            Gets assembly mvid and size
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.ReferencedAssembliesNames">
            <summary>
            Gets array of referenced assemblies' names
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.Location">
            <summary>
            Gets assembly location
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeInfoFromQualifiedName(System.String,System.Boolean)">
            <summary>
            Gets type info from its qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeInfoFromToken(JetBrains.Metadata.Access.MetadataToken)">
            <summary>
            Gets type info from its token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypeFromQualifiedName(System.String,System.Boolean)">
            <summary>
            Gets type from its qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetTypes">
            <summary>
            Gets array of types defined in the assembly
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetExportedTypesFromOtherModules">
            <summary>
            Gets types exported from other modules
            (types, defined within OTHER modules of THIS assembly)
            </summary>
            <remarks>
            Do not confuse this method with System.Reflection.Assembly.GetExportedTypes() method
            (which returns public types defined in this assembly that are visible outside the assembly)
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetForwardedTypes">
            <summary>
            Gets types forwarded to another assembly (TypeForwardedTo)
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.GetManifestResources">
            <summary>
            Gets manifest resources
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.CreateImageBodyReader">
            <summary>
            Returns new image body reader
            It opens module for read and closes it upon Dispose
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataAssembly.CreateUsagesFinder">
            <summary>
            Returns new usages finder
            Note: It reads module into memory upon creation
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.ModuleAttributes">
            <summary>
            Gets array of custom attributes associated with the main module
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataAttributeFieldInitialization">
            <summary>
            Entity which stores data about initialized field of a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributeFieldInitialization.Field">
            <summary>
            Gets initialized field
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument">
            <summary>
            Entity which stores data about initialized member (property or field) of a custom or security attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument.Member">
            <summary>
            Initialized property or field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument.MemberType">
            <summary>
            Type of property or field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument.MemberName">
            <summary>
            Name of initialized property or field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument.Value">
            <summary>
            Value the type member (property or field) is initialized with
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataAttributePropertyInitialization">
            <summary>
            Entity which stores data about initialized property of a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataAttributePropertyInitialization.Property">
            <summary>
            Gets initialized property
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataClassType">
            <summary>
            A type which corresponds to a type or instance of a generic class
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataClassType.Type">
            <summary>
            Gets underlying metadata type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataClassType.Arguments">
            <summary>
            Gets type parameters if applicable
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute">
            <summary>
            Represents a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.UsedConstructorSpecification">
            <summary>
            Gets constructor which is used for instantiating the attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.UsedConstructor">
            <summary>
            Gets constructor which is used for instantiating the attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.ConstructorArguments">
            <summary>
            Gets array of values passed as arguments to the used constructor
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataCustomAttribute.NamedArguments">
            <summary>
            Explicitly initialized properties and fields
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataEntity">
            <summary>
            Base interface for all metadata entities
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.Assembly">
            <summary>
            Assembly where this entity is located
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.Token">
            <summary>
            Gets assembly token
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.CustomAttributes">
            <summary>
            Gets array of custom attributes defined for this metadata entity
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.CustomAttributesTypeNames">
            <summary>
            Gets array of custom attributes type names (much faster than getting entire custom attributes)
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataEntity.GetCustomAttributes(System.String)">
            <summary>
            Gets array of attributes having the specified fully qualified name
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataEntity.HasCustomAttribute(System.String)">
            <summary>
            Checks if an entity has a custom attribute
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEntity.IsResolved">
            <summary>
            Returns whether this entity points to existent entity
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataEvent">
            <summary>
            Represents event metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Type">
            <summary>
            Gets event type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Adder">
            <summary>
            Gets adder method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Remover">
            <summary>
            Gets remover method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.Raiser">
            <summary>
            Gets raiser method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataEvent.OtherMethods">
            <summary>
            Gets array of other event methods
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataField">
            <summary>
            Represents field metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Type">
            <summary>
            Gets field type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.MarshalSpec">
            <summary>
            Gets a marshalling specification if HasMarshalSpec
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataField.GetLiteralValue">
            <summary>
            Gets literal field value
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataField.GetLiteralValueBlob">
            <summary>
            Gets literal field value blob
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Offset">
            <summary>
            Field offset in type instance. Non-negative value if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.Signature">
            <summary>
            Gets the field signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.InitialValueRva">
            <summary>
            Gets initial value RVA in case value stored in the image itself, not metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsAssembly">
            <summary>
            Gets flag indicating whether the field has assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsPrivate">
            <summary>
            Gets flag indicating whether the field is private
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsPublic">
            <summary>
            Gets flag indicating whether the field is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamily">
            <summary>
            Gets flag indicating whether the field has family visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the field has family-and-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the field has family-or-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsStatic">
            <summary>
            Gets flag indicating whether the field is static
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsInitOnly">
            <summary>
            Gets flag indicating whether the field is readonly
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.IsLiteral">
            <summary>
            Gets flag indicating whether the field is literal
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.HasMarshalSpec">
            <summary>
            Gets flag indicating whether the field has associated marshaling spec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataField.NotSerialized">
            <summary>
            Gets flag indicating whether the field must not be serialized
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo.AssemblyName">
            <summary>
            Where the forwarded type is declared (forwarded to)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataForwardedTypeInfo.FullName">
            <summary>
            Forwarded type FQN
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataFunctionPointerType">
            <summary>
            Unmanaged pointer to a function (fnptr)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataMethod">
            <summary>
            Represents a metadata method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.ReturnValue">
            <summary>
            Get the return value (which is encoded as zero-index parameter)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.Parameters">
            <summary>
            Gets method parameters
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.TypeParameters">
            <summary>
            Gets array of generic type parameters of this method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.ImplementedMethods">
            <summary>
            Gets array of explicitly implemented methods
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.Signature">
            <summary>
            Gets method signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.PInvokeInfo">
            <summary>
            PInvoke mapping if IsPInvokeImpl AND signature was successfully decoded
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.MethodImplFlags">
            <summary>
            Gets all impl method flags in one call
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPInvokeImpl">
            <summary>
            Gets flag indicating whether the method has PInvoke implementation
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.CodeType">
            <summary>
            Returns method implementation platform (IL, native code or runtime embedded)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.CodeRva">
            <summary>
            Relative virtual address of method code
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsForwardRef">
            <summary>
            Indicates the method is defined; used primarily in merge scenarios.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPreserveSig">
            <summary>
             Indicates method sig is not to be mangled to do HRESULT conversion.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsInternalCall">
            <summary>
            Method is implemented in runtime (?)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsSynchronized">
            <summary>
            Method is single threaded through the body.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.NoInlining">
            <summary>
            Method may not be inlined
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.AggressiveInlining">
            <summary>
            Method should be inlined if possible
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.NoOptimization">
            <summary>
            Method may not be optimized
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsAssembly">
            <summary>
            Gets flag indicating whether the method has assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPrivate">
            <summary>
            Gets flag indicating whether the method is private
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsPublic">
            <summary>
            Gets flag indicating whether the method is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamily">
            <summary>
            Gets flag indicating whether the method has family visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the method has family-and-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the method has family-or-assembly visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsStatic">
            <summary>
            Gets flag indicating whether the method is static
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsAbstract">
            <summary>
            Gets flag indicating whether the method is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsExtern">
            <summary>
            Gets flag indicating whether the method is implemented externally
            (non-abstract without IL body)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsVirtual">
            <summary>
            Gets flag indicating whether the method is virtual
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsFinal">
            <summary>
            Gets flad indicating whether the method can be overridden
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsHideBySig">
            <summary>
            Gets flag indicating whether the method hides by name and signature
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsNewSlot">
            <summary>
            Gets flag indicating whether the method is newslot
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsStrict">
            <summary>
            Gets flag indicating whether the method overridability is the same as the visibility
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsVarArg">
            <summary>
            Gets flag indicating whether the method is vararg
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataMethod.IsUnmanaged">
            <summary>
            Gets flag indicating whether the method is unmanaged
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataParameter">
            <summary>
            Represents a method parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.Name">
            <summary>
            Gets parameter name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.Type">
            <summary>
            Gets parameter type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.DeclaringMethod">
            <summary>
            Gets method which declares this parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.MarshalSpec">
            <summary>
            Gets a marshalling specification if HasMarshalSpec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsIn">
            <summary>
            Gets flag indicating whether the parameter is input
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsOut">
            <summary>
            Gets flag indicating whether the parameter is output
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsParamArray">
            <summary>
            Gets flag indicating whether the parameter is parameter array
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.IsOptional">
            <summary>
            Gets flag indicating whether the parameter is optional
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.HasMarshalSpec">
            <summary>
            Gets flag indicating whether the parameter has associated marshaling spec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataParameter.HasDefaultValue">
            <summary>
            Gets flag indicating whether the parameter has associated default value
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataParameter.GetDefaultValue">
            <summary>
            Gets default field value
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataParameter.GetDefaultValueBlob">
            <summary>
            Gets default field value
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataPointerType">
            <summary>
            Unmanaged pointer to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataPointerType.Type">
            <summary>
            Gets nested type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataProperty">
            <summary>
            Represents a property metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Type">
            <summary>
            Gets property type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Getter">
            <summary>
            Gets getter method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.Setter">
            <summary>
            Gets setter method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataProperty.OtherAccessors">
            <summary>
            Gets all property accessors
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataReferenceType">
            <summary>
            Managed pointer to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReferenceType.Type">
            <summary>
            Gets nested type
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataReturnValue">
            <summary>
            Represents a method return value (which is encoded as zero-index parameter)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.DeclaringMethod">
            <summary>
            Gets method which declares this parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.Type">
            <summary>
            Gets parameter type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.MarshalSpec">
            <summary>
            Gets a marshalling specification if HasMarshalSpec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataReturnValue.HasMarshalSpec">
            <summary>
            Gets flag indicating whether the parameter has associated marshaling spec
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityAttribute.NamedArguments">
            <summary>
            Explicitly initialized properties and fields
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityAttribute.ConstructorArgumentsBlob">
            <summary>
            Not decoded attribute constructor arguments
            </summary>
            <remarks>
            We don't know which constructor is used for creating this attribute (in contrast to custom attribute),
            therefore we don't know parameters types => can't properly decode arguments
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityAttribute.Action">
            <summary>
            In the normal case it should be equal to DeclaringSecurityRow.Action
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityOwner.Security">
            <summary>
            DeclSecurity rows
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityOwner.SecurityAttributesTypeName">
            <summary>
            Qualified names of security attributes
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataSecurityOwner.HasSecurity">
            <summary>
            Gets flag indicating whether the method has security attributes
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataType">
            <summary>
            Represents a type in metadata.
            Use <see cref="T:JetBrains.Metadata.Reader.API.MetadataTypeComparer"/> as comparer
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataType.AssemblyQualifiedName">
            <summary>
            Gets type presentable name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataType.TypeModifiers">
            <summary>
            Gets array of modopts and modreqs
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataTypeInfo">
            <summary>
            Interface for accessing types metadata
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.FullyQualifiedName">
            <summary>
            Gets fully qualified name of the type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.AssemblyQualifiedName">
            <summary>
            Gets assembly qualified name of the type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.NamespaceName">
            <summary>
            Gets namespace of the type.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.TypeName">
            <summary>
            Gets name of the type. For nested types, it is the combination of (owner name + Name)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.DeclaringAssemblyName">
            <summary>
            Assembly name (if any) where this type is located
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Base">
            <summary>
            Gets base type
            </summary>
            <remarks>Returns null if there is no base type</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.InterfaceImplementations">
            <summary>
            Gets array of interface implementations
            (interface and associated custom attributes, e.g. TupleElementNamesAttribute, NullableAttribute)
            for this type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.TypeParameters">
            <summary>
            Gets array of generic type parameters of this type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsAbstract">
            <summary>
            Gets flag indicating whether the type is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsSealed">
            <summary>
            Gets flag indicating whether the type is abstract
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsImported">
            <summary>
            Gets flag indicating whether the type is imported
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.Layout">
            <summary>
            Fields layout type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.InteropStringFormat">
            <summary>
            Charset for pinvoke calls
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsBeforeFieldInit">
            <summary>
            Gets flag indicating whether the type instructs the CLI that it need not initialize the type before a static method is called
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsClass">
            <summary>
            Gets flag indicating whether the type is a class type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsInterface">
            <summary>
            Gets flag indicating whether the type is an interface
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsSerializable">
            <summary>
            Gets flag indicating whether the type is serializable
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsWindowsRuntime">
            <summary>
            Gets flag indicating whether the type is Windows Runtime type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsPublic">
            <summary>
            Gets flag indicating whether the type is public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNotPublic">
            <summary>
            Gets flag indicating whether the type is not public
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNested">
            <summary>
            Gets flag indicating whether the type is a nested of any type (i.e. any of IsNested* is true)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedPublic">
            <summary>
            Gets flag indicating whether the type is a nested public type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedPrivate">
            <summary>
            Gets flag indicating whether the type is a nested private type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamily">
            <summary>
            Gets flag indicating whether the type is a nested family type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedAssembly">
            <summary>
            Gets flag indicating whether the type is a nested assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamilyAndAssembly">
            <summary>
            Gets flag indicating whether the type is a nested family-and-assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.IsNestedFamilyOrAssembly">
            <summary>
            Gets flag indicating whether the type is a nested family-or-assembly type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.PackingSize">
            <summary>
            Packing size for layout process. Positive value if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.ClassSize">
            <summary>
            Class size. Positive value if specified
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetMemberInfos">
            <summary>
            Get the names of all members (except of nested type names).
            This is fast, not decoding
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetMethods">
            <summary>
            Gets type methods
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetFields">
            <summary>
            Gets type fields
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetProperties">
            <summary>
            Gets type properties
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetEvents">
            <summary>
            Gets type events
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMetadataTypeInfo.GetNestedTypes">
            <summary>
            Gets nested types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeMember.Name">
            <summary>
            Gets member name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeMember.DeclaringType">
            <summary>
            Gets type which declares the member. Always null for top-level types
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeMember.IsSpecialName">
            <summary>
            Gets flag indicating whether the member has special name flag
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeMember.IsRuntimeSpecialName">
            <summary>
            Gets flag indicating whether the member has runtime special name flag
            (name shall be treated in a special way by the runtime)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataTypeParameter">
            <summary>
            Represents a generic type parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.Kind">
            <summary>
            Gets type parameter kind: whether it is owned by a type or by a method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.Name">
            <summary>
            Gets type parameter name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.Index">
            <summary>
            Gets generic type parameter index
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.TypeOwner">
            <summary>
            Gets type owner, if the type parameter belongs to a type
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.MethodOwner">
            <summary>
            Gets method owner, if the type parameter belongs to a method
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.TypeConstraints">
            <summary>
            Gets type parameter type constraints, if specified
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameter.Attributes">
            <summary>
            Gets type parameter attributes
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.IMetadataTypeParameterReferenceType">
            <summary>
            A type which is unbound reference to a generic type parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMetadataTypeParameterReferenceType.TypeParameter">
            <summary>
            Gets referenced generic type parameter
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Method">
            <summary>
            Owner
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Index">
            <summary>
            Sequence number in method local variables list
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IMethodBodyLocalVariable.Type">
            <summary>
            Local variable type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Find usages of <paramref name="method"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Find usages of <paramref name="field"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Find explicit usages of <paramref name="typeInfo"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            
            Be aware of usage count is unknown because it is highly depends of decomplication.
            </summary>
            <remarks>
            Covered cases of explicit type usage in method body: typeof (including generic instantiation,
            modreq, modopt, function pointers), calls of type's static methods and constructors,
            accessing static fields, casts to type, catch arguments, local variables types
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindUsagesOf(JetBrains.Metadata.Access.MetadataToken,System.String)">
            <summary>
            Find usages of <paramref name="userString"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
            <remarks>
            Find all methods and usage count containing ldstr instruction with userStringToken operand
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.IMethodBodyUsagesFinder.FindDefaultConstructorUsagesOfValueType(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Find usages of default constructor of value type <paramref name="typeInfo"/> in method bodies of current assembly
            (one IMethodBodyUsagesFinder was created from).
            </summary>
            <remarks>
            Find all methods containing initobj instruction with typeInfo.Token operand
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext.UniqueName">
            <summary>
            Presentable name for diagnostic issues
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext.Originator">
            <summary>
              <para>If we're resolving the reference as originated in some assembly, specifies that assembly.</para>
              <para>This is useful both for diagnostics and for looking up assembly files in folders nearby the originator.</para>
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MemberInfo">
            <summary>
            Unified information about type member
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MemberInfo.Name">
            <summary>
            Name of the type member
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MemberInfo.Token">
            <summary>
            Member token
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataFieldEx.IsVolatile(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Gets flag indicating whether the field has volatile modifier
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataLoader">
            <summary>
            Manages metadata loading. 
            Note: loading assembly into metadata loader holds assembly metadata
            for loader lifetime. It's a bad idea to hold loader for your product lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataLoader.TryLoad(JetBrains.Metadata.Utils.AssemblyNameInfo,System.Func{JetBrains.Metadata.Utils.AssemblyNameInfo,System.Boolean},System.Boolean,JetBrains.Metadata.Reader.API.IMetadataAssembly,System.Func{System.Boolean})">
            <summary>
            Load assembly with the specified name
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.MetadataLoader.ErrorNotifications">
            <summary>
            Allows to listen to non-fatal metadata reader errors, such as unresolved type.
            Such errors are expected to happen when you're reading just one assembly without resolving its references, thus they're not reported to the logger as regular exceptions. You can opt in for receiving such error notifications.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataLoaderErrors">
            <summary>
            Allows to listen to non-fatal metadata reader errors, such as unresolved type.
            Such errors are expected to happen when you're reading just one assembly without resolving its references, thus they're not reported to the logger as regular exceptions. You can opt in for receiving such error notifications.
            </summary>
            <remarks>A custom implementation of events: allows to know if there're any sinks at all, so that not to fire / prepare eventargs when nobody is listening. This is critical for good PSI performance.</remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.IncompleteAttribute">
            <summary>
            Fires when a Custom Attribute cannot be entirely deserialized.
            You cannot read the CA stream to the end without additional info, which info you must get from external assemblies. If those are missing or walking into references is not allowed, you cannot parse the stream because the records size cannot be determined (for values of an Enum type, their size is not specified, you must load the assembly declaring the enum type to read even the knonw arguments).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.UndeclaredAssemblyReference">
            <summary>
            Fires when an implicit assembly reference is encountered — i.e. to parse metadata, we have to load an external assembly which is not explicitly listed in assembly references.
            An example is reading of the Custom Attribute stream, which might include string representations of assembly-qualified type names pointing to other assemblies. If such assemblies are only used in CA parameters, they would yield no typeref tokens (only a plaintext representation), and CSC would optimize away the assembly references to them.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.UnresolvedType">
            <summary>
            Fires when a type reference cannot be resolved.
            Put aside external calls into assembly thru public API, there're two major cases for internal calls from metadata entities of the assembly:
            (1) <code>MetadataToken.TT_TYPEDEF</code> or <code>MetadataToken.TT_TYPEREF</code> token resolution.
            (2) Resolution of a string representation of an assembly-qualified type reference (e.g. a type of the named actual parameter in Custom Attribute stream).
            In the latter case, you're getting <see cref="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.IncompleteAttribute" /> as well.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.UnresolvedTypeArgs.AssemblyTypeQualification">
            <summary>
            <see cref="F:JetBrains.Metadata.Reader.API.MetadataLoaderErrors.UnresolvedTypeArgs.TypeFqn" /> assembly qualification, if available.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataTupleTypeComparer">
            <summary>
            <inheritdoc cref="T:JetBrains.Metadata.Reader.API.MetadataTypeComparer"/>
            Tuples are considered equal if they have the same names and types of components
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataTypeComparer">
            <summary>
            Compares two metadata types.
            Note: generic argument references are compared by kind and index,
            not actual generic argument entity they are resolved to.
            modopt's and pinned are ignored, modreq's are not.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeEx.IsImplicitNumericConvertibleTo(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType)">
            <summary>
            <list type="bullet">
            <listheader>
            <description>
            C# 2.0 spec paragraph 13.1.2
            </description>
            </listheader>
            <item><description>From sbyte to short, int, long, float, double, or decimal.</description></item>
            <item><description>From byte to short, ushort, int, uint, long, ulong, float, double, or decimal.</description></item>
            <item><description>From short to int, long, float, double, or decimal.</description></item>
            <item><description>From ushort to int, uint, long, ulong, float, double, or decimal.</description></item>
            <item><description>From int to long, float, double, or decimal.</description></item>
            <item><description>From uint to long, ulong, float, double, or decimal.</description></item>
            <item><description>From long to float, double, or decimal.</description></item>
            <item><description>From ulong to float, double, or decimal.</description></item>
            <item><description>From char to ushort, int, uint, long, ulong, float, double, or decimal.</description></item>
            <item><description>From float to double.</description></item>
            </list>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeEx.IsTupleEqualTo(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType)">
            <remarks>
            Mainly for decompiler purposes
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeEx.ToBoxedType(JetBrains.Metadata.Reader.API.IMetadataType)">
            <summary>
            See Partition I, 8.2.4 and Partition III, 1.8.1.1.
            </summary>
            <param name="type">An input type to be boxed.</param>
            <returns>The boxed type.</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeEx.GetTypeParameterNumberDistribution(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
             {
             typeInfo.GetTypeOwnTypeParameters().Length,
             typeInfo.DeclaringType.GetTypeOwnTypeParameters().Length,
             typeInfo.DeclaringType.DeclaringType.GetTypeOwnTypeParameters().Length,
             ...}
             </summary>
             <example>GenericType&lt;T1, T2&gt;.NestedGenericType&lt;T3&gt; => {1, 2} </example>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MetadataTypeReference">
            <summary>
            Reference to type. Name of the type and assembly where it is declared
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataTypeReference.AssemblyName">
            <summary>
            Assembly name
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataTypeReference.NamespaceName">
            <summary>
            Namespace name of the type
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.MetadataTypeReference.TypeName">
            <summary>
            Name of the type without namespace
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.MetadataTypeReference.FullName">
            <summary>
            Name of the type
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeUtil.GetTypeSize(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Returns type size in memory or 0 if can't be calculated for sure
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MetadataTypeUtil.IsMscorlibClassType(JetBrains.Metadata.Reader.API.IMetadataType,System.String)">
            <remarks>mscorlib-like assembly, not always exactly mscorlib</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MethodSignature.AreSimplifiedEqual(JetBrains.Metadata.Reader.API.MethodSignature,JetBrains.Metadata.Reader.API.MethodSignature)">
            <summary>
            Signature comparison using parameter/return types comparison with ignoring assembly names
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MethodSignature.AreSimplifiedEqual(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType)">
            <summary>
            Type comparison ignoring assembly names
            </summary>
            <example>
            System.Collections.IDictionary&lt;System.String, System.String&gt; from mscorlib 2.0.0.0 and from mscorlib 4.0.0.0 are considered equal
            </example>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.MethodUsageCount.Count">
            <summary>
            Count of occurrences of something in IL code.
            
            -1 means unknown count (for example <see cref="T:JetBrains.Metadata.Reader.API.IMetadataTypeInfo"/>
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MethodUsageCount.#ctor(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            use this constructor only if usage count is unknown
            </summary>
            <param name="usage"></param>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MonoCurrentRuntimeAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.MonoGacAssemblyResolver">
            <summary>
            Searches in gac
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.MonoGacAssemblyResolver.IsUnderResolvePaths(JetBrains.Util.VirtualFileSystemPath)">
            <summary>
            Gets whether the given assembly path is under some GAC location.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.Unknown">
            <summary>
            No information. E.g. when in '#nullable disable annotations' context or old assemblies without nullable attributes
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.NotAnnotated">
            <summary>
            Type is located in '#nullable enable annotations' context and doesn't have the '?' annotation
            E.g. string, int, T (including the case when T is unconstrained and can contain null values)
            Note that this annotation doesn't mean that an expression with it doesn't have null values because of unconstrained generics
            You need to use IType.GetValueNullableAnnotation method to get this expression's RValue nullability
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.NotAnnotatedFlowUnknown">
            <summary>
            Explicitly set by flow analysis.
            It thought to be NotAnnotated by the compiler.
            However, this value is obtained via type inference from unannotated code, we might want to consider its nullability less strict as NotAnnotated
            for the purposes of data flow analysis, e.g. we might not want to recommend changing T? to T if the variable might store NotAnnotatedFlowUnknown
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.Annotated">
            <summary>
            Type is located in '#nullable enable annotations' context and have a '?' annotation
            E.g. string?, T? where T : class; int?, T? where T : struct
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.NotNullable">
            <summary>
            Explicitly set by flow analysis.
            Expression with this type does not contain null values according to the flow analysis even if its annotation allows it.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.RuntimeNotNullable">
            <summary>
            Explicitly set by flow analysis.
            Expression with this type definitely doesn't contain null values and this is enforced by actual runtime checks performed in code.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.Nullable">
            <summary>
            Explicitly set by flow analysis.
            Expression with this type might contain null values according to the flow analysis even if its annotation doesn't allow it
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.UnknownJetBrainsCanBeNull">
            <summary>
            Explicitly set by flow analysis.
            Value comes from unannotated API with [CanBeNull] attribute or doesn't have attributes and the analysis is in pessimistic mode
            It thought to be NotNullable by the compiler.
            However we might want to produce warnings and shouldn't suggest removing null checks or annotations for expressions of these types
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.UnknownJetBrainsNotNull">
            <summary>
            Explicitly set by flow analysis.
            Value from unannotated API with [NotNull] attribute or doesn't have attributes and the analysis is in implicit notnull mode
            It thought to be NotNullable by the compiler.
            We can safely suggest removing null checks and annotations for expressions with these types
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.UnknownFlowUnknown">
            <summary>
            Explicitly set by flow analysis.
            It thought to be NotNullable by the compiler.
            However, it comes from unannotated API so we might want to produce warnings and shouldn't suggest removing null checks or annotations for expressions of these types
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.NullableAnnotation.NullableJetBrainsNotNull">
            <summary>
            Explicitly set by flow analysis.
            It thought to be Nullable by the compiler.
            However, ReSharper analysis thinks that the value cannot be nullable e.g. because it's checked via an assertion not recognized by the compiler
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.PInvokeInfo.SupportsLastError">
            <summary>
            Native method supports C style last error querying
            (Microsoft implementation of the CLI on MS Windows)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.PInvokeInfo.NoMangle">
            <summary>
            Indicates that the name in the DLL should be used precisely as specified,
            rather than attempting to add A (for ascii) or W (widechar) to find
            platform-specific variants based on the type of string marshalling requested
            (Microsoft implementation of the CLI on MS Windows)
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.SecurityAction">
            <remarks>
            The values 0–0xFF are reserved for future standards use.
            Values 0x20–0x7F and 0x100–0x07FF are for uses where the action can be ignored if it is not understood or supported.
            Values 0x80–0xFF and 0x0800–0xFFFF are for uses where the action shall be implemented for secure operation; in implementations where the action is not available, no access to the assembly, type, or method shall be permitted.
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.StandardMemberNames.ObsoleteTopLevelEntryPoint">
            <remarks>VS 16.7.x compiler</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.StandardOperatorNames">
            <summary>
            See Paritition I, 10.3.2.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.API.StandardTypeNames.ObsoleteTopLevelProgram">
            <remarks>VS 16.7.x compiler</remarks>
        </member>
        <member name="T:JetBrains.Metadata.Reader.API.StreamAssemblyResolver">
            <summary>
            Resolver used in specific cases, such as when an assembly is in RAM or on the remote server <i>(an extreme case, I
            recommend that you first download it into RAM)</i>. In general nothing can stop you from using file streams.<br/>
            The created <see cref="T:JetBrains.Metadata.Reader.API.IMetadataAssembly"/> with this resolver will have <see cref="P:JetBrains.Metadata.Reader.API.IMetadataAssembly.Location"/> is <see cref="T:JetBrains.Metadata.Reader.API.StreamAssemblyLocation"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.API.StreamAssemblyResolver.Keys">
            <summary>
            The theoretical list of all <see cref="T:JetBrains.Metadata.Utils.AssemblyNameInfo"/> which can be resolved to <see cref="T:JetBrains.Metadata.Access.IMetadataAccess"/>.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.StreamAssemblyResolver.#ctor(JetBrains.Metadata.Access.IMetadataProvider,System.Collections.Generic.IEnumerable{System.Func{System.IO.Stream}})">
            <summary>
            Use this constructor only if you want specify <paramref name="metadataProvider"/>.
            Otherwise, maybe this <see cref="M:JetBrains.Metadata.Reader.API.StreamAssemblyResolver.#ctor(System.Collections.Generic.IEnumerable{System.Func{System.IO.Stream}})"/> constructor is fine for you.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.StreamAssemblyResolver.#ctor(System.Collections.Generic.IEnumerable{System.Func{System.IO.Stream}})">
            <param name="producers">Stream opening functions.</param>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.UnresolvedMetadataEx.IsEqualTo_Unresolved(JetBrains.Metadata.Reader.API.IMetadataType,JetBrains.Metadata.Reader.API.IMetadataType)">
            <remarks>
            Same as MetadataTypeEx.IsEqualTo if both types are resolved;
            compares FQN for unresolved types
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.UnresolvedMetadataEx.IsConstructor_Unresolved(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <remarks>
            Same as MetadataEx.IsConstructor if method is resolved
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.UnresolvedMetadataEx.IsOperator_Unresolved(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <remarks>
            Same as MetadataEx.IsOperator if method is resolved
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.UnresolvedMetadataEx.IsClassConstructor_Unresolved(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <remarks>
            Same as MetadataEx.IsClassConstructor if method is resolved
            </remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.API.UnresolvedMetadataEx.IsImplementedBy_Unresolved(JetBrains.Metadata.Reader.API.MethodSpecification,JetBrains.Metadata.Reader.API.MethodSpecification)">
            <summary>
            See Partition II, 12.2.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.CombiningAssemblyResolver">
            <summary>
            Compound resolver. Tries to resolve the assembly thru all of the given resolvers, in order of appearance.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.CustomDebugInformationBlobDecoder.DecodeStateMachineHoistedLocalScopes(JetBrains.Metadata.Utils.IBlob)">
            <summary>
            Scopes of local variables hoisted to state machine fields
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.CustomDebugInformationBlobDecoder.DecodeDefaultNamespace(JetBrains.Metadata.Utils.IBlob)">
            <summary>
            The default namespace for the module/project
            </summary>
            <remarks>VB compiler</remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.AsyncMethodSteppingInformationData.CatchHandlerOffset">
            <summary>
            IL offset of catch handler or -1
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.AsyncMethodSteppingInformationData.YieldOffsets">
            <summary> 
            Set of IL offsets where await operators yield control
             </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.AsyncMethodSteppingInformationData.ResumeOffsets">
            <summary> 
            Set of IL offsets where await operators are to be resumed
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId">
            <summary>
            Unique identification of an emitted entity (method, lambda, closure) used for debugging purposes (EnC).
            </summary>
            <remarks>
            When used for a synthesized method the ordinal and generation numbers are included its name.
            For user defined methods the ordinal is included in Custom Debug Information record attached to the method.
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId.Ordinal">
            <summary>
            The index of the method in member list of the containing type, or <see cref="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId.UndefinedOrdinal"/> if undefined.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.DebugId.Generation">
            <summary>
            The EnC generation the method was defined in (0 is the baseline build).
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo">
            <summary>
            Debug information maintained for each lambda.
            </summary>
            <remarks>
            The information is emitted to PDB in Custom Debug Information record for a method containing the lambda.
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo.SyntaxOffset">
            <summary>
            The syntax offset of the syntax node declaring the lambda (lambda expression) or its body (lambda in a query).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo.ClosureOrdinal">
            <summary>
            The ordinal of the closure frame the lambda belongs to, or
            <see cref="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo.StaticClosureOrdinal"/> if the lambda is static, or
            <see cref="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LambdaDebugInfo.ThisOnlyClosureOrdinal"/> if the lambda is closed over "this" pointer only.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalDebugId">
            <summary>
            Id that associates an emitted user-defined or long-lived synthesized local variable 
            with a syntax node that defined it. If a syntax node defines multiple variables it 
            provides information necessary to identify which one of these variables is it.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalDebugId.SyntaxOffset">
            <summary>
            We calculate a "syntax offset" for each user-defined and long-lived synthesized variable. 
            Every such variable symbol has to be associated with a syntax node (its declarator). 
            In usual cases this is the textual distance of the declarator from the start of the method body. 
            It gets a bit complicated when the containing method body is not contiguous (constructors). 
            If the variable is in the body of the constructor the definition of syntax offset is the same. 
            If the variable is defined in a constructor  initializer or in a member initializer 
            (this is only possible when declaration expressions or closures in primary constructors are involved) 
            then the distance is a negative sum of the widths of all the initializers that succeed the declarator 
            of the variable in the emitted constructor body plus the relative offset of the declarator from 
            the start of the containing initializer.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.LocalDebugId.Ordinal">
            <summary>
            If a single node is a declarator for multiple variables of the same synthesized kind (it can only happen for synthesized variables) 
            we calculate additional number "ordinal" for such variable. We assign the ordinals to the synthesized variables with the same kind
            and syntax offset in the order as they appear in the lowered bound tree. It is important that a valid EnC edit can't change 
            the ordinal of a synthesized variable. If it could it would need to be assigned a different kind or associated with a different declarator node.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.FileName">
            <summary>
            Name of the metadata file (includes an extension)
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.Aliases">
            <summary>
            Comma-separated list of external aliases for the reference. May be empty
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.Flags">
            <remarks>
            0b0000001 - Embed interop types
            0b0000010 - The referenced file is an assembly (as opposed to a netmodule)
            </remarks>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.TimeStamp">
            <summary>
            PE COFF header Timestamp field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.FileSize">
            <summary>
            PE COFF header SizeOfImage field
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.MetadataReferenceInfo.Mvid">
            <summary>
            Module Version Id (Module metadata table field)
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScope.StartOffset">
            <summary>
            The offset of the first operation in the scope.
            </summary>
        </member>
        <member name="P:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.StateMachineHoistedLocalScope.EndOffset">
            <summary>
            The offset of the first operation outside of the scope, or the method body length.
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind">
            <summary>
            Kind of a synthesized local variable.
            </summary>
            <remarks>
            Synthesized local variables are either 
            1) Short-lived (temporary)
               The lifespan of an temporary variable shall not cross a statement boundary (a PDB sequence point).
               These variables are not tracked by EnC and don't have names.
             
            2) Long-lived
               All variables whose lifespan might cross a statement boundary (include a PDB sequence point)
               must be named in a build configuration that supports EnC. Some of them might need to be named in release, to support EE.
               The kind of such local must be encoded in the name, so that we can retrieve it from debug metadata during EnC.
            
               The integer value of the kind must match corresponding Dev11/12 TEMP_KIND enum values for
               compatibility with assemblies generated by the native compiler.
            
               Long-lived local variables must be assigned slots in source order.
            </remarks>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.FrameCache">
            <summary>
            Temp created for caching "this".
            Technically it is long-lived, but will happen only in optimized code.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.PatternMatchingTemp">
            <summary>
            Temp created for pattern matching by type.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.OptimizerTemp">
            <summary>
            Temp variable created by the optimizer.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.LoweringTemp">
            <summary>
            Temp variable created during lowering.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.EmitterTemp">
            <summary>
            Temp variable created by the emitter.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.UserDefined">
            <summary>
            The variable is not synthesized (C#, VB).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ConditionalBranchDiscriminator">
            <summary>
            Local variable that stores value of an expression consumed by a subsequent conditional branch instruction that might jump across PDB sequence points.
            The value needs to be preserved when remapping the IL offset from old method body to new method body during EnC.
            A hidden sequence point also needs to be inserted at the offset where this variable is loaded to be consumed by the branch instruction.
            (VB, C#).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.LockTaken">
            <summary>
            Boolean passed to Monitor.Enter (C#, VB).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.Lock">
            <summary>
            Variable holding on the object being locked while the execution is within the block of the lock statement (C#) or SyncLock statement (VB).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.Using">
            <summary>
            Local variable that stores the resources to be disposed at the end of using statement (C#, VB).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ForEachEnumerator">
            <summary>
            Local variable that stores the enumerator instance (C#, VB).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ForEachArray">
            <summary>
            Local variable that stores the array instance (C#, VB?).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ForEachArrayLimit">
            <summary>
            Local variables that store upper bound of multi-dimensional array, for each dimension (C#, VB?).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ForEachArrayIndex">
            <summary>
            Local variables that store the current index, for each dimension (C#, VB?).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.FixedString">
            <summary>
            Local variable that holds a pinned handle of a string passed to a fixed statement (C#).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.With">
            <summary>
            Local variable that holds the object passed to With statement (VB). 
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.SelectCaseValue">
            <summary>
            Local variable used to store the value of Select Case during the execution of Case statements.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.AsyncMethodReturnValue">
            <summary>
            Local variable that stores the return value of an async method.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.FunctionReturnValue">
            <summary>
            VB: Stores the return value of a function that is not accessible from user code (e.g. operator, lambda, async, iterator).
            C#: Stores the return value of a method/lambda with a block body, so that we can put a sequence point on the closing brace of the body.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.ExceptionFilterAwaitHoistedExceptionLocal">
            <summary>
            Very special corner case involving filters, await and lambdas.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.StateMachineCachedState">
            <summary>
            Local variable that stores the current state of the state machine while MoveNext method is executing.
            Used to avoid race conditions due to multiple reads from the lifted state.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.AwaitSpill">
            <summary>
            Local that stores an expression value which needs to be spilled.
            This local should either be hoisted or its lifespan ends before 
            the end of the containing await expression.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.LambdaDisplayClass">
            <summary>
            Local variable that holds on the display class instance.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.CachedAnonymousMethodDelegate">
            <summary>
            Local variable used to cache a delegate that is used in inner block (possibly a loop), 
            and can be reused for all iterations of the loop.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.Awaiter">
            <summary>
            Local variable that stores the result of an await expression (the awaiter object).
            The variable is assigned the result of a call to await-expression.GetAwaiter() and subsequently used 
            to check whether the task completed. Eventually the value is stored in an awaiter field.
            
            The value assigned to the variable needs to be preserved when remapping the IL offset from old method body 
            to new method body during EnC. If the awaiter expression is contained in an active statement and the 
            containing MoveNext method changes the debugger finds the next sequence point that follows the await expression 
            and transfers the execution to the new method version. This sequence point is placed by the compiler at 
            the immediately after the stloc instruction that stores the awaiter object to this variable.
            The subsequent ldloc then restores it in the new method version.
            
            (VB, C#).
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.InstrumentationPayload">
            <summary>
            Stores a dynamic analysis instrumentation payload array. The value is initialized in
            synthesized mehtod prologue code and referred to throughout the method body.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.MaxValidValueForLocalVariableSerializedToDebugInformation">
            <summary>
            All values have to be less than or equal to <see cref="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.MaxValidValueForLocalVariableSerializedToDebugInformation"/>
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.AwaiterField">
            <summary>
            An awaiter in async method. 
            Never actually created as a local variable, immediately lifted to a state machine field.
            </summary>
        </member>
        <member name="F:JetBrains.Metadata.Reader.Impl.CustomDebugInformation.SynthesizedLocalKind.DelegateRelaxationReceiver">
            <summary>
            The receiver of a delegate relaxation stub.
            Created as a local variable but always lifted to a relaxation display class field. 
            We never emit debug info for hoisted relaxation variable.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetFieldPresentations(JetBrains.Metadata.Reader.API.IMetadataField)">
            <summary>
            Returns field defs or refs that corresponds to <paramref name="field"/> in this assembly
            </summary>
            <returns>Array of field defs or refs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetTypePresentations(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Returns type defs, refs or specs that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>Array of type defs, refs or specs tokens</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetTokenFromTypeInfo(JetBrains.Metadata.Reader.API.IMetadataTypeInfo)">
            <summary>
            Find a token that corresponds to <paramref name="typeInfo"/> in this assembly
            </summary>
            <returns>TypeDef or TypeRef or Nil</returns>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.EntityPresentations.GetMethodPresentations(JetBrains.Metadata.Reader.API.IMetadataMethod)">
            <summary>
            Returns method specs, defs or refs that corresponds to <paramref name="method"/> in this assembly
            </summary>
            <returns>Array of method specs, defs, refs tokens</returns>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.FailAssemblyResolver">
            <summary>
            Logs assembly resolution failures.
            If adding to <see cref="T:JetBrains.Metadata.Reader.Impl.CombiningAssemblyResolver" />, must be the last one.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.FailAssemblyResolver.ReportDistinctError(JetBrains.Metadata.Utils.AssemblyNameInfo,JetBrains.Metadata.Reader.API.IModuleReferenceResolveContext)">
            <summary>
            Reports the error on assembly resolve, in case no errors have been reported for the same assembly yet.
            </summary>
            <param name="name"></param>
            <param name="ctx">More info for the resolve originator. Does not take part in Distinct.</param>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.FieldSignatureBlobDecoder.DecodeFieldSig``2(JetBrains.Metadata.Utils.IBlob,JetBrains.Metadata.Reader.Impl.ITypeBuilder{``0,``1})">
            <summary>
            Partition II Metadata 23.2.4: FieldSig
            </summary>
        </member>
        <member name="T:JetBrains.Metadata.Reader.Impl.LoadedAssembliesResolver">
            <summary>
            Resolves to the assemblies in the currently loaded appdomain.
            Not threadsafe.
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.MetadataManifestResource.GetDisposition">
            <summary>
            Gets "pointer" to the resource location, independent of ImageBodyReader
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.PermissionSetBlobDecoder.ReadArguments(JetBrains.Metadata.Utils.IBinaryReader,System.Int32,System.Int32,System.Boolean,JetBrains.Metadata.Reader.Impl.CustomAttributeBlobDecoder,System.Collections.Generic.List{JetBrains.Metadata.Reader.API.IMetadataAttributeNamedArgument})">
            <summary>
            Reads field and property initializations and not decoded attribute constructor arguments
            </summary>
            <param name="reader"></param>
            <param name="attributeBlobStartPosition"></param>
            <param name="attributeBlobEndPosition"></param>
            <param name="altFormat">indicates alternative format of named arguments number</param>
            <param name="customAttributeBlobDecoder"></param>
            <param name="namedArguments"></param>
            <returns>not decoded attribute constructor arguments or null</returns>
            <remarks>Attribute blob bytes: [attributeBlobStartPosition, attributeBlobEndPosition) = [attributeBlobStartPosition, attributeBlobEndPosition - 1]</remarks>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.PermissionSetBlobDecoder.GetConstructorArgumentsBlob(JetBrains.Metadata.Utils.IBinaryReader,System.Int32,System.Int32)">
            <summary>
            Blob bytes: [fromPosition, toPosition) = [fromPosition, toPosition - 1]
            </summary>
        </member>
        <member name="M:JetBrains.Metadata.Reader.Impl.PropertySignatureBlobDecoder.DecodePropertySignature``2(JetBrains.Metadata.Utils.IBlob,JetBrains.Metadata.Reader.Impl.IMethodSignatureBuilder{``0,``1})">
            <summary>
            Partition II Metadata 23.2.5: PropertySig
            </summary>
        </member>
    </members>
</doc>
