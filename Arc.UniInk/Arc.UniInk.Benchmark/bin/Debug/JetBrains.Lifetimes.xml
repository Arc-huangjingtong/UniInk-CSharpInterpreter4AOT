<?xml version="1.0"?>
<doc>
    <assembly>
        <name>JetBrains.Lifetimes</name>
    </assembly>
    <members>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.</summary>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><see langword="null"/> may be used as the name of the receiver in an instance method.</remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute.#ctor">
            <summary>Initializes the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute"/>.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:JetBrains.Annotations.CanBeNullAttribute">
            <summary>
            Indicates that the value of the marked element could be <c>null</c> sometimes,
            so the check for <c>null</c> is necessary before its usage.
            </summary>
            <example><code>
            [CanBeNull] object Test() => null;
            
            void UseTest() {
              var p = Test();
              var s = p.ToString(); // Warning: Possible 'System.NullReferenceException'
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotNullAttribute">
            <summary>
            Indicates that the value of the marked element could never be <c>null</c>.
            </summary>
            <example><code>
            [NotNull] object Foo() {
              return null; // Warning: Possible 'null' assignment
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.ItemNotNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can never be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ItemCanBeNullAttribute">
            <summary>
            Can be applied to symbols of types derived from IEnumerable as well as to symbols of Task
            and Lazy classes to indicate that the value of a collection item, of the Task.Result property
            or of the Lazy.Value property can be null.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitNotNullAttribute">
            <summary>
            Implicitly apply [NotNull]/[ItemNotNull] annotation to all the of type members and parameters
            in particular scope where this annotation is used (type declaration or whole assembly).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.StringFormatMethodAttribute">
            <summary>
            Indicates that the marked method builds string by format pattern and (optional) arguments.
            Parameter, which contains format string, should be given in constructor. The format string
            should be in <see cref="M:System.String.Format(System.IFormatProvider,System.String,System.Object[])"/>-like form.
            </summary>
            <example><code>
            [StringFormatMethod("message")]
            void ShowError(string message, params object[] args) { /* do something */ }
            
            void Foo() {
              ShowError("Failed: {0}"); // Warning: Non-existing argument in format string
            }
            </code></example>
        </member>
        <member name="M:JetBrains.Annotations.StringFormatMethodAttribute.#ctor(System.String)">
            <param name="formatParameterName">
            Specifies which parameter of an annotated method should be treated as format-string
            </param>
        </member>
        <member name="T:JetBrains.Annotations.ValueProviderAttribute">
            <summary>
            For a parameter that is expected to be one of the limited set of values.
            Specify fields of which type should be used as values for this parameter.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InvokerParameterNameAttribute">
            <summary>
            Indicates that the function argument should be string literal and match one
            of the parameters of the caller function. For example, ReSharper annotates
            the parameter of <see cref="T:System.ArgumentNullException"/>.
            </summary>
            <example><code>
            void Foo(string param) {
              if (param == null)
                throw new ArgumentNullException("par"); // Warning: Cannot resolve symbol
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.NotifyPropertyChangedInvocatorAttribute">
             <summary>
             Indicates that the method is contained in a type that implements
             <c>System.ComponentModel.INotifyPropertyChanged</c> interface and this method
             is used to notify that some property value changed.
             </summary>
             <remarks>
             The method should be non-static and conform to one of the supported signatures:
             <list>
             <item><c>NotifyChanged(string)</c></item>
             <item><c>NotifyChanged(params string[])</c></item>
             <item><c>NotifyChanged{T}(Expression{Func{T}})</c></item>
             <item><c>NotifyChanged{T,U}(Expression{Func{T,U}})</c></item>
             <item><c>SetProperty{T}(ref T, T, string)</c></item>
             </list>
             </remarks>
             <example><code>
             public class Foo : INotifyPropertyChanged {
               public event PropertyChangedEventHandler PropertyChanged;
             
               [NotifyPropertyChangedInvocator]
               protected virtual void NotifyChanged(string propertyName) { ... }
            
               string _name;
             
               public string Name {
                 get { return _name; }
                 set { _name = value; NotifyChanged("LastName"); /* Warning */ }
               }
             }
             </code>
             Examples of generated notifications:
             <list>
             <item><c>NotifyChanged("Property")</c></item>
             <item><c>NotifyChanged(() =&gt; Property)</c></item>
             <item><c>NotifyChanged((VM x) =&gt; x.Property)</c></item>
             <item><c>SetProperty(ref myField, value, "Property")</c></item>
             </list>
             </example>
        </member>
        <member name="T:JetBrains.Annotations.ContractAnnotationAttribute">
            <summary>
            Describes dependency between method input and output.
            </summary>
            <syntax>
            <p>Function Definition Table syntax:</p>
            <list>
            <item>FDT      ::= FDTRow [;FDTRow]*</item>
            <item>FDTRow   ::= Input =&gt; Output | Output &lt;= Input</item>
            <item>Input    ::= ParameterName: Value [, Input]*</item>
            <item>Output   ::= [ParameterName: Value]* {halt|stop|void|nothing|Value}</item>
            <item>Value    ::= true | false | null | notnull | canbenull</item>
            </list>
            If method has single input parameter, it's name could be omitted.<br/>
            Using <c>halt</c> (or <c>void</c>/<c>nothing</c>, which is the same)
            for method output means that the methods doesn't return normally.<br/>
            <c>canbenull</c> annotation is only applicable for output parameters.<br/>
            You can use multiple <c>[ContractAnnotation]</c> for each FDT row,
            or use single attribute with rows separated by semicolon.<br/>
            </syntax>
            <examples><list>
            <item><code>
            [ContractAnnotation("=> halt")]
            public void TerminationMethod()
            </code></item>
            <item><code>
            [ContractAnnotation("halt &lt;= condition: false")]
            public void Assert(bool condition, string text) // regular assertion method
            </code></item>
            <item><code>
            [ContractAnnotation("s:null => true")]
            public bool IsNullOrEmpty(string s) // string.IsNullOrEmpty()
            </code></item>
            <item><code>
            // A method that returns null if the parameter is null,
            // and not null if the parameter is not null
            [ContractAnnotation("null => null; notnull => notnull")]
            public object Transform(object data) 
            </code></item>
            <item><code>
            [ContractAnnotation("s:null=>false; =>true,result:notnull; =>false, result:null")]
            public bool TryParse(string s, out Person result)
            </code></item>
            </list></examples>
        </member>
        <member name="T:JetBrains.Annotations.LocalizationRequiredAttribute">
            <summary>
            Indicates that marked element should be localized or not.
            </summary>
            <example><code>
            [LocalizationRequiredAttribute(true)]
            class Foo {
              string str = "my string"; // Warning: Localizable string
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.CannotApplyEqualityOperatorAttribute">
            <summary>
            Indicates that the value of the marked type (or its derivatives)
            cannot be compared using '==' or '!=' operators and <c>Equals()</c>
            should be used instead. However, using '==' or '!=' for comparison
            with <c>null</c> is always permitted.
            </summary>
            <example><code>
            [CannotApplyEqualityOperator]
            class NoEquality { }
            
            class UsesNoEquality {
              void Test() {
                var ca1 = new NoEquality();
                var ca2 = new NoEquality();
                if (ca1 != null) { // OK
                  bool condition = ca1 == ca2; // Warning
                }
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.BaseTypeRequiredAttribute">
            <summary>
            When applied to a target attribute, specifies a requirement for any type marked
            with the target attribute to implement or inherit specific type or types.
            </summary>
            <example><code>
            [BaseTypeRequired(typeof(IComponent)] // Specify requirement
            class ComponentAttribute : Attribute { }
            
            [Component] // ComponentAttribute requires implementing IComponent interface
            class MyComponent : IComponent { }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.UsedImplicitlyAttribute">
            <summary>
            Indicates that the marked symbol is used implicitly (e.g. via reflection, in external library),
            so this symbol will not be marked as unused (as well as by other usage inspections).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.MeansImplicitUseAttribute">
            <summary>
            Should be used on attributes and causes ReSharper to not mark symbols marked with such attributes
            as unused (as well as by other usage inspections)
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Access">
            <summary>Only entity marked with attribute considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.Assign">
            <summary>Indicates implicit assignment to a member.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedWithFixedConstructorSignature">
            <summary>
            Indicates implicit instantiation of a type with fixed constructor signature.
            That means any unused constructor parameters won't be reported as such.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseKindFlags.InstantiatedNoFixedConstructorSignature">
            <summary>Indicates implicit instantiation of a type.</summary>
        </member>
        <member name="T:JetBrains.Annotations.ImplicitUseTargetFlags">
            <summary>
            Specify what is considered used implicitly when marked
            with <see cref="T:JetBrains.Annotations.MeansImplicitUseAttribute"/> or <see cref="T:JetBrains.Annotations.UsedImplicitlyAttribute"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.Members">
            <summary>Members of entity marked with attribute are considered used.</summary>
        </member>
        <member name="F:JetBrains.Annotations.ImplicitUseTargetFlags.WithMembers">
            <summary>Entity marked with attribute and all its members considered used.</summary>
        </member>
        <member name="T:JetBrains.Annotations.PublicAPIAttribute">
            <summary>
            This attribute is intended to mark publicly available API
            which should not be removed and so is treated as used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.InstantHandleAttribute">
            <summary>
            Tells code analysis engine if the parameter is completely handled when the invoked method is on stack.
            If the parameter is a delegate, indicates that delegate is executed while the method is executed.
            If the parameter is an enumerable, indicates that it is enumerated while the method is executed.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.PureAttribute">
            <summary>
            Indicates that a method does not make any observable state changes.
            The same as <c>System.Diagnostics.Contracts.PureAttribute</c>.
            </summary>
            <example><code>
            [Pure] int Multiply(int x, int y) => x * y;
            
            void M() {
              Multiply(123, 42); // Waring: Return value of pure method is not used
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.MustUseReturnValueAttribute">
            <summary>
            Indicates that the return value of method invocation must be used.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.ProvidesContextAttribute">
            <summary>
            Indicates the type member or parameter of some type, that should be used instead of all other ways
            to get the value that type. This annotation is useful when you have some "context" value evaluated
            and stored somewhere, meaning that all other ways to get this value must be consolidated with existing one.
            </summary>
            <example><code>
            class Foo {
              [ProvidesContext] IBarService _barService = ...;
            
              void ProcessNode(INode node) {
                DoSomething(node, node.GetGlobalServices().Bar);
                //              ^ Warning: use value of '_barService' field
              }
            }
            </code></example>
        </member>
        <member name="T:JetBrains.Annotations.PathReferenceAttribute">
            <summary>
            Indicates that a parameter is a path to a file or a folder within a web project.
            Path can be relative or absolute, starting from web root (~).
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.CollectionAccessAttribute">
            <summary>
            Indicates how method, constructor invocation or property access
            over collection type affects content of the collection.
            </summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.None">
            <summary>Method does not use or modify content of the collection.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.Read">
            <summary>Method only reads content of the collection but does not modify it.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.ModifyExistingContent">
            <summary>Method can change content of the collection but does not add new elements.</summary>
        </member>
        <member name="F:JetBrains.Annotations.CollectionAccessType.UpdatedContent">
            <summary>Method can add new elements to the collection.</summary>
        </member>
        <member name="T:JetBrains.Annotations.AssertionMethodAttribute">
            <summary>
            Indicates that the marked method is assertion method, i.e. it halts control flow if
            one of the conditions is satisfied. To set the condition, mark one of the parameters with 
            <see cref="!:AssertionConditionAttribute"/> attribute.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.LinqTunnelAttribute">
            <summary>
            Indicates that method is pure LINQ method, with postponed enumeration (like Enumerable.Select,
            .Where). This annotation allows inference of [InstantHandle] annotation for parameters
            of delegate type by analyzing LINQ method chains.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.NoEnumerationAttribute">
            <summary>
            Indicates that IEnumerable, passed as parameter, is not enumerated.
            </summary>
        </member>
        <member name="T:JetBrains.Annotations.RegexPatternAttribute">
            <summary>
            Indicates that parameter is regular expression pattern.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.CollectionEx">
            <summary>
            Extension methods for collections
            </summary>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.ContentHashCode``1(System.Collections.Generic.ICollection{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>
            Calculates polynomial hash code for collection.
            Return 0 if collection == null.
            Return `seed` (in current implementation 0x2D2816FE) if collection is empty.
            In current implementation polynomial factor is 31.
            </summary>
            <param name="collection"></param>
            <param name="comparer">If comparer is null then `EqualityComparer.Default` will be used</param>
            <typeparam name="T"></typeparam>
            <returns>((seed * factor + hash(collection[0])) * factor + hash(collection[1])) * factor + ... </returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.TryDequeue``1(System.Collections.Generic.Queue{``0},``0@)">
            <summary>
            Dequeue <paramref name="queue"/> if it's not empty (or do nothing).
            </summary>
            <param name="queue"></param>
            <param name="res"><see cref="M:System.Collections.Generic.Queue`1.Dequeue"/> if <paramref name="queue"/>.Count > 0 at method start, `default{T}` otherwise</param>
            <typeparam name="T"></typeparam>
            <returns>`true` if <paramref name="queue"/>.Count > 0 at method start, `false` otherwise</returns>
        </member>
        <member name="M:JetBrains.Collections.CollectionEx.Enqueued``1(System.Collections.Generic.Queue{``0},``0)">
            <summary>
            Same as <see cref="M:System.Collections.Generic.Queue`1.Enqueue(`0)"/> but returns added element
            </summary>
            <param name="queue"></param>
            <param name="toEnqueue">Element to enqueue into <paramref name="queue"/></param>
            <typeparam name="T"></typeparam>
            <returns>Added element <paramref name="toEnqueue"/></returns>
        </member>
        <member name="T:JetBrains.Collections.CompactList`1">
            <summary>
            Saves memory footprint and traffic for lists with single element: doesn't allocate real list
            until number of elements is more then 1.
            <see cref="M:JetBrains.Collections.CompactList`1.GetEnumerator"/> return struct that should save memory traffic during enumeration.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.CopyOnWriteList`1">
            <summary>
            A lock-free list that copies the underlying storage on all write operations. This allows for thread-safe operation with well-defined semantics at the cost of performance in write-heavy scenarios.
            Used instead of pulling the whole System.Collections.Immutable nuget package.
            </summary>
            <typeparam name="T">Type of elements contained in this list</typeparam>
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.#ctor">
            <summary>
            Creates a new empty list.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Collections.CopyOnWriteList`1.Count">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Collections.CopyOnWriteList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:JetBrains.Collections.CopyOnWriteList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:JetBrains.Collections.CopyOnWriteList`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="T:JetBrains.Collections.EmptyEnumerator`1">
            <summary>
            Enumerator for empty collection.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetKeyValuePair">
            <summary>
            Facilitates <see cref="T:System.Collections.Generic.KeyValuePair`2"/>
            </summary>
        </member>
        <member name="T:JetBrains.Collections.IPriorityQueue`1">
            <summary>
            JetBrains interface of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.JetPriorityQueue`1">
            <summary>
            JetBrains implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.BlockingPriorityQueue`1">
            <summary>
            Thread-safe implementation of priority queue data structure.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ExtractOrBlock">
            <summary>
            Returns first element from queue or waits until it appears. In case of lifetime termination throws PCE.
            </summary>
            <returns>First element in queue</returns>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.Enqueue(`0)">
            <summary>
            Enqueues an item and returns the total number of items in the queue right after enqueueing, in a thread-safe-consistent manner.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.BlockingPriorityQueue`1.ToArray">
            <summary>
            Copies data to an array, thread-safely.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.PriorityQueueEx.Enqueue``1(JetBrains.Collections.IPriorityQueue{``0},``0)">
            <summary>
            Same as <see cref="!:IPriorityQueue&lt;T&gt;.Add"/>
            </summary>
            <param name="queue"></param>
            <param name="val"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.ReferenceEqualityComparer`1">
            <summary>
            Comparer that uses reference equality.
            Usage: `ReferenceEqualityComparer{T}.Default`
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.SingletonEnumerator`1">
            <summary>
            Enumerator for imaginary collection from single value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedDictionary`2">
            <summary>
            This dictionary is used for Net3.5 as a poor replacement of ConcurrentDictionary.
            All methods are synchronized. <see cref="M:JetBrains.Collections.Synchronized.SynchronizedDictionary`2.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedDictionary`2.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedList`1">
            <summary>
            This is a thread-safe list with all methods synchronized.
            <see cref="M:JetBrains.Collections.Synchronized.SynchronizedList`1.GetEnumerator"/> copies whole content so
            you can change collection as you want during enumeration. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedList`1.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Synchronized.SynchronizedSet`1">
             <summary>
             This is a thread-safe set with all methods synchronized.
             <see cref="M:JetBrains.Collections.Synchronized.SynchronizedSet`1.GetEnumerator"/> copies whole content so
             you can change collection as you want during enumeration.
            
             Useful pattern for filtering):
             <code>
               using (en = syncSet.GetEnumerator()) {
                 while (en.MoveNext()) {
                   if (some_condition(en.Current))
                     syncSet.Remove(en.Current);
                 }
               }
             </code>
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Synchronized.SynchronizedSet`1.GetEnumerator">
            <summary>
            Copies content of collection: O(n) CPU and memory complexity.
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> or <see cref="F:JetBrains.Collections.Viewable.AddRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.AddUpdateRemove">
            <summary>
            Defines whether the event kind is <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Add"/>, <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Update"/> or <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Remove"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.IReadonlyProperty`1">
             <summary>
             Special kind of <see cref="T:JetBrains.Collections.Viewable.ISource`1"/> that remembers last <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/>.
             There are bunch of differences with plain <see cref="T:JetBrains.Collections.Viewable.ISource`1"/>:
             <list type="number">
             <item>It's guaranteed by design that two sequential values received by <c>handler</c> from
             <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/> are not equal.</item>
             <item> if <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Maybe"/>.<see cref="P:JetBrains.Core.Maybe`1.HasValue"/> then <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/> is 
             equals to <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Maybe"/>.<see cref="P:JetBrains.Core.Maybe`1.Value"/>. Invocation of <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/> will execute <c>handler</c>
             synchronously with <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/> and then invoke <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Change"/>.<see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>.
             </item>
            
             <item>
             If <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Maybe"/> is <see cref="!:Maybe.None"/> (no one set this property before) then
             <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/> will throw <see cref="T:System.InvalidOperationException"/>. 
             Invocation of <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>  will just invoke invoke <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Change"/>.<see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>
             without synchronous invocation.  
            </item> 
             </list> 
             </summary>
             <typeparam name="T"></typeparam>
             <remarks>
             If value is set once then it's guaranteed that <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Maybe"/>.<see cref="P:JetBrains.Core.Maybe`1.HasValue"/> <c> == true</c>
             and <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/> won't throw exception. It's impossible to return state to <see cref="!:Maybe.None"/> after
             it was set.
             <remarks>See <see cref="M:JetBrains.Collections.Viewable.ReactiveEx.View``1(JetBrains.Collections.Viewable.IReadonlyProperty{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,``0})"/>
             for structured subscription.
             </remarks> 
             
             </remarks>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Change">
            <summary>
            Underlying <see cref="T:JetBrains.Collections.Viewable.ISource`1"/>. You can advise on this field if you don't want synchronous execution of
            handler with  <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Maybe">
            <summary>
            Before property was set once this field is <see cref="F:JetBrains.Core.Maybe`1.None"/>. After each set 
            <see cref="P:JetBrains.Core.Maybe`1.Value"/> matches <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value"/>.
            </summary>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Value">
            <summary>
            The last remembered value from <see cref="P:JetBrains.Collections.Viewable.IReadonlyProperty`1.Change"/>
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.IScheduler">
            <summary>
            Abstraction of executor. Can be be UI thread, Pooled, synchronous and so on   
            </summary>
        </member>
        <member name="M:JetBrains.Collections.Viewable.IScheduler.Queue(System.Action)">
            <summary>
            Queue action for execution. 
            </summary>
            <param name="action"></param>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IScheduler.IsActive">
            <summary>
            Returns whether current task is being executed on this scheduler. Could be used for assert.
            </summary>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IScheduler.OutOfOrderExecution">
            <summary>
            Helps to relax expectations and speed up some usages if this scheduler
            can doesn't preserve sequential FIFO semantics (e.g. ThreadPool scheduler).
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ISignal`1">
            <summary>
            Extension of <see cref="T:JetBrains.Collections.Viewable.ISource`1"/> that can <see cref="M:JetBrains.Collections.Viewable.ISignal`1.Fire(`0)"/> messages.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JetBrains.Collections.Viewable.ISignal`1.Scheduler">
            <summary>
            Currently all subscribers gets events on the same thread that <see cref="M:JetBrains.Collections.Viewable.ISignal`1.Fire(`0)"/> happened.
            This scheduler is reserved for future use.
            </summary>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ISignal`1.Fire(`0)">
            <summary>
            Fires value that will be seen by all handlers who subscribed by <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ISource`1">
            <summary>
            Analogue of .NET event but subscription could be done only with <see cref="T:JetBrains.Lifetimes.Lifetime"/>
            so no risk to forget to unsubscribe. 
            </summary>
            <typeparam name="T">type of event</typeparam>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})">
            <summary>
            Subscribes for this sources (if lifetime isn't terminated). <paramref name="handler"/> will be unsubscribed when lifetime become <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/>   
            </summary>
            <param name="lifetime">if lifetime <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/> then no subscription will be done</param>
            <param name="handler">handler of events</param>
        </member>
        <member name="T:JetBrains.Collections.Viewable.IViewableList`1">
            <summary>
            Observable list.
            Invocation <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/> for this list will synchronously invoke
            <c>handler</c> with <see cref="P:JetBrains.Collections.Viewable.ListEvent`1.Kind"/> == <see cref="F:JetBrains.Collections.Viewable.AddRemove.Add"/> for
            each existing element of this collection.
            <remarks>See <see cref="M:JetBrains.Collections.Viewable.ReactiveEx.View``1(JetBrains.Collections.Viewable.IViewableList{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,System.Int32,``0})"/>
            for structured subscription.
            </remarks> 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IViewableList`1.Change">
            <summary>
            Advise this source if you don't want synchronous execution of <c>handler</c> on existing
            items of this <see cref="T:JetBrains.Collections.Viewable.ViewableList`1"/>. 
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Collections.Viewable.IViewableMap`2" -->
        <member name="T:JetBrains.Collections.Viewable.IViewableProperty`1">
            <summary>
            Mutable <see cref="T:JetBrains.Collections.Viewable.IReadonlyProperty`1"/>.
            If you put not equal values (in terms of <see cref="M:System.Object.Equals(System.Object)"/>) into
            <see cref="P:JetBrains.Collections.Viewable.IViewableProperty`1.Value"/> than no event will be fired and <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>'s handler
            won't be triggered. So code
            <code>
            //suppose property.Value != 1
            property.Value = 1;
            property.Value = 1;
            </code>
            will fire only one event with value 1.
            
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JetBrains.Collections.Viewable.IViewableProperty`1.Value">
            <summary>
            If value being set is equal to <see cref="P:JetBrains.Collections.Viewable.IViewableProperty`1.Value"/> no event is being fired and handler
            subscribed by <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/> are not triggered.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:JetBrains.Collections.Viewable.IViewableSet`1" -->
        <member name="T:JetBrains.Collections.Viewable.ListEvent`1">
            <summary>
            Event of <see cref="T:JetBrains.Collections.Viewable.IViewableList`1"/>
            </summary>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.MapEvent`2">
            <summary>
            Event of <see cref="T:JetBrains.Collections.Viewable.IViewableMap`2"/>
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ModificationCookieViewableSet`2">
            <summary>
            For usage in code contexts
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCookie"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ReactiveEx.AdviseAddRemove``1(JetBrains.Collections.Viewable.IViewableList{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Collections.Viewable.AddRemove,System.Int32,``0})">
            <summary>
            Same as <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/> but all events with kind=<see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Update"/> are
            split into two sequential events with kinds <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Remove"/> and <see cref="F:JetBrains.Collections.Viewable.AddUpdateRemove.Add"/>
            </summary>
            <param name="me"></param>
            <param name="lifetime"></param>
            <param name="handler"></param>
            <typeparam name="V"></typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ReactiveEx.View``1(JetBrains.Collections.Viewable.IViewableList{``0},JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime,System.Int32,``0})">
            <summary>
            Structured subscription for List. Behaves same as <see cref="M:JetBrains.Collections.Viewable.ISource`1.Advise(JetBrains.Lifetimes.Lifetime,System.Action{`0})"/>
            except <c>handler</c> receives <see cref="T:JetBrains.Lifetimes.Lifetime"/> parameter
            that terminates when someone removes or updates element on corresponding index. 
            </summary>
            <param name="me"></param>
            <param name="lifetime"></param>
            <param name="handler"></param>
            <typeparam name="V"></typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException"></exception>
        </member>
        <member name="T:JetBrains.Collections.Viewable.SetEvent`1">
            <summary>
            Event of <see cref="T:JetBrains.Collections.Viewable.IViewableSet`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.Signal`1">
            <summary>
            Default implementation of <see cref="T:JetBrains.Collections.Viewable.ISignal`1"/>.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.SingleThreadScheduler">
            <summary>
            Task scheduler that either creates separate thread (via <see cref="M:JetBrains.Collections.Viewable.SingleThreadScheduler.RunOnSeparateThread(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Collections.Viewable.SingleThreadScheduler})"/> or use current
            (via <see cref="M:JetBrains.Collections.Viewable.SingleThreadScheduler.CreateOverExisting(JetBrains.Collections.Viewable.SingleThreadScheduler,System.String,System.Int32)"/>). All enqueued tasks are executed sequentially. 
            </summary>
        </member>
        <member name="P:JetBrains.Collections.Viewable.SingleThreadScheduler.Thread">
            <summary>
            Thread is expected to be initialized from factory methods
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.SynchronousScheduler">
            <summary>
            Scheduler that executes task and action synchronously
            Perfect candidate for <see cref="M:System.Threading.Tasks.Task.ContinueWith(System.Action{System.Threading.Tasks.Task,System.Object},System.Object)"/>
            if you want to guarantee synchronous continuation
            </summary>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ViewableList`1">
            <summary>
            Default implementation if <see cref="T:JetBrains.Collections.Viewable.IViewableList`1"/>. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ViewableList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>
            Special delegating constructor that accepts storage backend (e.g. <see cref="T:JetBrains.Collections.Synchronized.SynchronizedList`1"/>) 
            </summary>
            <param name="list"></param>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ViewableMap`2">
            <summary>
            Default implementation of <see cref="T:JetBrains.Collections.Viewable.IViewableMap`2"/>
            </summary>
            <typeparam name="TK"></typeparam>
            <typeparam name="TV"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ViewableMap`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`1})">
            <summary>
            Special delegating constructor that accepts storage backend (e.g. <see cref="T:System.Collections.Concurrent.ConcurrentDictionary`2"/>)
            </summary>
            <param name="storage"></param>
            <param name="valueComparer"></param>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ViewableProperty`1">
            <summary>
            Default implementation of <see cref="T:JetBrains.Collections.Viewable.IViewableProperty`1"/>. Synchronized internally.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Collections.Viewable.ViewableSet`1">
            <summary>
            Default implementation for <see cref="T:JetBrains.Collections.Viewable.IViewableSet`1"/>
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Collections.Viewable.ViewableSet`1.#ctor(System.Collections.Generic.ISet{`0})">
            <summary>
            Special delegating constructor that accepts storage backend (e.g. <see cref="T:JetBrains.Collections.Synchronized.SynchronizedSet`1"/>)
            </summary>
            <param name="storage"></param>
        </member>
        <member name="T:JetBrains.Util.EmptyArray`1">
            <summary>
            Reuses the single instance of an empty array (one per type). If possible, prefer <code>EmptyList{T}.InstanceList</code>
            because each time you enumerate empty array, new <code>Array.SZArrayEnumerator</code> class instance is being created.
            </summary>
        </member>
        <member name="T:JetBrains.Util.EmptyArray">
            <summary>
            Reuses the single instance of an empty array (one per type).
            </summary>
        </member>
        <member name="M:JetBrains.Util.EmptyArray.GetInstance``1">
            <summary>Synonym for <see cref="F:JetBrains.Util.EmptyArray`1.Instance"/></summary>
        </member>
        <member name="F:JetBrains.Util.MethodImplAdvancedOptions.AggressiveInlining">
            <summary>
            Corresponds to <code>MethodImplOptions.AggressiveInlining</code> value in 4.5 framework. This value is just swallowed in lower frameworks
            </summary>
        </member>
        <member name="T:JetBrains.Util.BitHacks">
            <summary>
            Inspired by http://graphics.stanford.edu/~seander/bithacks.html
            </summary>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Floor(System.Int32)">
            <summary>
            Returns largest non-negative integer <c>y</c> such that <c>2^y&lt;=x</c> if <c>x&gt;0</c>, <c>0</c> if <c>x=0</c>, or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>
            <returns><c>y : 2^y&lt;=x</c></returns>
        </member>
        <member name="M:JetBrains.Util.BitHacks.Log2Ceil(System.Int64)">
            <summary>
            Returns lowest non-negative integer <c>y</c> such that <c>2^y&gt;=x</c> if <c>x&gt;=0</c> or throw ArgumentException if <c>x&lt;0</c> 
            </summary>
            <param name="x">Must be greater than or equal to zero.</param>    
            <returns><c>y : 2^y&gt;=x</c></returns>    
        </member>
        <member name="M:JetBrains.Util.BitHacks.NumberOfBitSet(System.Int32)">
            <summary>
            Return number of <c>1</c>-s in binary representation of <c>x</c>
            </summary>
            <param name="x"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Util.Util.Cast32BitEnum`1">
            <summary>
            For converting generic enum based on 32bit integer into in or uint.
            Will throw <see cref="T:System.InvalidOperationException"/> in static ctor if <c>Enum.GetUnderlyingType(typeof(T)) </c> is not int or uint.
            </summary>
            <typeparam name="T">Enum that is based on int or uint</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.Cast64BitEnum`1">
            <summary>
            For converting generic enum based on 64bit integer into in or ulong.
            Will throw <see cref="T:System.InvalidOperationException"/> in static ctor if <c>Enum.GetUnderlyingType(typeof(T)) </c> is not long or ulong.
            </summary>
            <typeparam name="T">Enum that is based on long or ulong</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.CastTo`1">
            <summary>
            !!! Use it with caution. Main purpose is enum to/from int casting without boxing !!!
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.CastTo`1.From``1(``0)">
            <summary>
            /// https://stackoverflow.com/questions/1189144/c-sharp-non-boxing-conversion-of-generic-enum-to-int/23391746#23391746
            Casts <see cref="!:TFrom"/> to TTo  without boxing for value types. Useful in generic methods.
            The only problem is that this method requires around 50ms on startup to warm up.
            So for real hardcore see <see cref="!:ReinterpretFrom&lt;TFrom&gt;"/>  
            </summary>
            <typeparam name="TFrom">Source type to cast from. Usually a generic type.</typeparam>
        </member>
        <member name="T:JetBrains.Util.Util.Statics">
            <summary>
            Represents global statics in a stack-like way 
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Statics.For``1">
            <summary>
            Gets statics holder for type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns>Stack-like holder</returns>
        </member>
        <member name="T:JetBrains.Util.Util.Types">
            <summary>
            Extensions to <see cref="T:System.Type"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.Util.Types.ourPrimitives">
            <summary>
            To prettify Int32, Int64 and so on.
            </summary>
        </member>
        <member name="M:JetBrains.Util.Util.Types.ToString(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Different <c>ToString()</c> of <see cref="T:System.Type"/>.
            
            Samples are provide for:  
            <code>
            namespace Foo { 
              class Outer&lt;T1&gt;
              {
                 internal class Inner&lt;T2&gt; {}
              }    
            }
            
            </code>     
            </summary>
            <param name="thisType"><c>typeof(Outer&lt;string&gt;.Inner&lt;int&gt;)</c></param>
            <param name="withNamespaces">if `true` (and <see cref="!:withGenericArguments"/> == `false`) then <c>Foo.Outer+Inner</c> else <c>Outer+Inner</c> </param>
            <param name="withGenericArguments">if `true` (and <see cref="!:withNamespaces"/> == `false`) then <c>Outer&lt;string&gt;+Inner&lt;int&gt;</c> else <c>Outer+Inner</c> </param>
            <returns>More natural than <see cref="M:System.Type.ToString"/> string representation of type</returns>
        </member>
        <member name="T:JetBrains.Util.LocalStopwatch">
            <summary>
            This structure can be used as a non-allocated version of the <see cref="T:System.Diagnostics.Stopwatch"/>
            </summary>
        </member>
        <member name="F:JetBrains.Util.LocalStopwatch.TicksPerMillisecond">
            TicksPerMillisecond and TicksPerSecond values are synchronized with the internal values of <see cref="T:System.Diagnostics.Stopwatch"/> 
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.TryGetSetter(System.Reflection.MemberInfo)">
            <summary>
            Return setter for either field or property info, or null if can't be set.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetGetter(System.Reflection.MemberInfo)">
            <summary>
            Return getter for either field or property
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetReturnType(System.Reflection.MemberInfo)">
            <summary>
            Get field or property type.
            </summary>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.Call``1(System.Reflection.MethodInfo,System.Object,System.Object[])">
            <summary>
            Calls a method using reflection with captured stack of inner exception
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Util.ReflectionUtil.GetPropertyValueSafe``1(System.Object,System.String,``0)">
            <summary>
            Evaluates property value available on object or any of the interfaces it implements
            </summary>
            <param name="o">Object to invoke property of</param>
            <param name="propertyName">Name of the property</param>
            <param name="defaultValue">Default value to return if failed</param>
            <typeparam name="T">Expected return type</typeparam>
            <returns>Evaluated property value or default value</returns>
        </member>
        <member name="T:JetBrains.Core.Maybe`1">
            <summary>
            Implementation of 'maybe' monad. Either <seealso cref="P:JetBrains.Core.Maybe`1.HasValue"/> is `true` and <seealso cref="P:JetBrains.Core.Maybe`1.Value"/> doesn't throw exception or `false`. 
            
            default(Maybe) == Maybe.None
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:JetBrains.Core.Maybe`1.Value">
            <summary>
            
            </summary>
            <exception cref="T:System.InvalidOperationException">if <seealso cref="P:JetBrains.Core.Maybe`1.HasValue"/> == `false`</exception>
        </member>
        <member name="T:JetBrains.Core.Nothing">
            <summary>
            Type that has no instances. Subclass of all classes, so can be casted to any class.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Nothing.As``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable``1">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as a return value for unreachable code.
            </summary>
            <typeparam name="T"></typeparam>
            <returns>always fail</returns>
        </member>
        <member name="M:JetBrains.Core.Nothing.Unreachable">
            <summary>
            Always throws <see cref="T:System.InvalidOperationException"/>. Could be used as an assertion in unreachable code.
            </summary>
            <returns>always fail</returns>
        </member>
        <member name="T:JetBrains.Core.Result">
            <summary>
            Helper methods for <see cref="T:JetBrains.Core.Result`1" /> and <see cref="T:JetBrains.Core.Result`2"/> building
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result.EmptyFailMessage">
            <summary>
            Message that is being applied to Result.Fail when no message provided 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Success``1(``0)">
            <summary>
            Creates successful <see cref="T:JetBrains.Core.Result`1"/> with value <see cref="!:value"/>
            </summary>
            <param name="value"></param>
            <typeparam name="T"></typeparam>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == true</returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.Exception,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/>
            </summary>
            <param name="exception"></param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.Exception,``0,System.Boolean)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with corresponding <see cref="!:failValue"/>
            </summary>
            <param name="exception"></param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/> </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`2"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="M:JetBrains.Core.Result.Fail(System.String)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Fail``1(System.String,``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`2"/> with <see cref="T:JetBrains.Core.ResultException"/> that wraps provided <see cref="!:message"/>
            </summary>
            <param name="message">Reason of failure. If not defined, <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> is used.</param>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.FailWithValue``1(``0)">
            <summary>
            Creates failed <see cref="T:JetBrains.Core.Result`1"/> with message= <see cref="F:JetBrains.Core.Result.EmptyFailMessage"/> and user-defined failure parameter 
            </summary>
            <param name="failValue">Special user-defined value provided for failed Result</param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`2.Succeed"/> == false. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.Canceled(System.OperationCanceledException,System.Boolean)">
            <summary>
            Creates special failed <see cref="T:JetBrains.Core.Result`1"/> that wraps <see cref="T:System.OperationCanceledException"/>
            </summary>
            <param name="exception">Captured OCE that lead to this cancellation</param>
            <param name="captureStackTrace">Try to capture exception stack (if any), could be unwind by <see cref="M:JetBrains.Core.Result`1.Unwrap"/>. </param>
            <returns>Result with <see cref="P:JetBrains.Core.Result`1.Succeed"/> == false and <see cref="P:JetBrains.Core.Result`1.Canceled"/> == true. Returned type could be implicitly casted to any <see cref="T:JetBrains.Core.Result`1"/></returns>
            <exception cref="T:System.ArgumentNullException">if <see cref="!:exception"/> is null</exception>
        </member>
        <member name="F:JetBrains.Core.Result.Unit">
            <summary>
            Void succeed result for <see cref="F:JetBrains.Core.Result.Unit"/> type
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Func{``0})">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function  to execute</param>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f() if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap(System.Action)">
            <summary>
            Wrap execution of <see cref="!:f"/>() into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action to execute</param>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``1(System.Action{``0},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Action with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result.Unit"/> if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.Wrap``2(System.Func{``0,``1},``0)">
            <summary>
            Wrap execution of <see cref="!:f"/>(<see cref="!:param"/>) into <see cref="T:JetBrains.Core.Result`1"/>. 
            </summary>
            <param name="f">Function with parameter to execute</param>
            <param name="param">function argument</param>
            <typeparam name="T"><see cref="!:param"/> type</typeparam>
            <typeparam name="TRes">type argument of returned Result</typeparam>
            <returns>Succeed result with <see cref="F:JetBrains.Core.Result`1.Value"/> == f(param) if no exception happened during <see cref="!:f"/> execution. Failed result with corresponding exception otherwise </returns>    
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask(JetBrains.Core.Result{System.Threading.Tasks.Task})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.UnwrapTask``1(JetBrains.Core.Result{System.Threading.Tasks.Task{``0}})">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/>.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="T:System.Threading.Tasks.Task"/> in <see cref="F:JetBrains.Core.Result`1.Value"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to completed task with <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> and <see cref="T:System.Exception"/>
            </summary>
            <param name="result">this</param>
            <typeparam name="T">type parameter of returning task</typeparam>
            <returns><see cref="T:System.Threading.Tasks.Task"/> that corresponds <see cref="!:result"/></returns>
        </member>
        <member name="M:JetBrains.Core.Result.FromCompletedTask``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Wrap completed task's result into <see cref="T:JetBrains.Core.Result`1"/> or throw <see cref="T:System.InvalidOperationException"/> is task is <c>!</c><see cref="P:System.Threading.Tasks.Task.IsCompleted"/> 
            </summary>
            <param name="task">Must be finished (<see cref="P:System.Threading.Tasks.Task.IsCompleted"/><c>==true</c>) or <see cref="T:System.InvalidOperationException"/> will be throws</param>
            <typeparam name="T"></typeparam>
            <returns><see cref="M:JetBrains.Core.Result.Success``1(``0)"/>(task.<see cref="P:System.Threading.Tasks.Task`1.Result"/>) or <see cref="M:JetBrains.Core.Result.Fail(System.Exception,System.Boolean)"/>(task.<see cref="P:System.Threading.Tasks.Task.Exception"/>)</returns>
            <exception cref="T:System.InvalidOperationException">in case of <c>!task.</c><see cref="P:System.Threading.Tasks.Task.IsCompleted"/></exception>
        </member>
        <member name="T:JetBrains.Core.Result`1">
            <summary>
            Monad that can can have two states: <see cref="P:JetBrains.Core.Result`1.Succeed"/> and Fail (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>). Also we distinct special type of Fail: <see cref="P:JetBrains.Core.Result`1.Canceled"/>.  
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`1.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`1.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`1.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`1.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailMessage">
            <summary>
            Exception message in case of (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>), null otherwise 
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.#ctor(`0,System.Object)">
            <summary>
            Shouldn't be invoked in user's code
            </summary>
            <param name="success"></param>
            <param name="failure"></param>
        </member>
        <member name="P:JetBrains.Core.Result`1.Succeed">
            <summary>
            Is result successful
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.FailedNotCanceled">
            <summary>
            (!<see cref="P:JetBrains.Core.Result`1.Succeed"/>) and (<see cref="P:JetBrains.Core.Result`1.Canceled"/>
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`1.Canceled">
            <summary>
            Exception has specials type of <see cref="T:System.OperationCanceledException"/> or <see cref="T:System.AggregateException"/> that has <see cref="T:System.OperationCanceledException"/> inside.
            </summary>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(System.Func{`0,``0})">
            <summary>
            Transform this result into new one with given function. if !<see cref="P:JetBrains.Core.Result`1.Succeed"/>, stays untouched./> 
            </summary>
            <param name="transform"></param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Map``1(``0)">
            <summary>
            Map without lambda. Success{Anything} -> Success{<see cref="!:successValue"/>}. Fail -> Fail
            </summary>
            <param name="successValue">In case of success we always create successful result with this value</param>
            <typeparam name="TRes"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Core.Result`1.Unwrap">
            <summary>
            Returns <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/>, throws <see cref="P:JetBrains.Core.Result`1.Exception"/> otherwise
            </summary>
            <returns> <see cref="F:JetBrains.Core.Result`1.Value"/> if <see cref="P:JetBrains.Core.Result`1.Succeed"/> </returns>
            <exception cref="P:JetBrains.Core.Result`1.Exception">if !<see cref="P:JetBrains.Core.Result`1.Succeed"/></exception>
        </member>
        <member name="M:JetBrains.Core.Result`1.AsCompletedTask">
            <summary>
            Transforms this <see cref="T:JetBrains.Core.Result"/> into <see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state state.
            <see cref="P:JetBrains.Core.Result`1.Succeed"/> corresponds to <see cref="!:Task.IsRanToCompletion"/>.
            <see cref="P:JetBrains.Core.Result`1.Canceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsCanceled"/>
            <see cref="P:JetBrains.Core.Result`1.FailedNotCanceled"/> corresponds to <see cref="P:System.Threading.Tasks.Task.IsFaulted"/> with <see cref="P:JetBrains.Core.Result`1.Exception"/>
            </summary>
            <returns><see cref="T:System.Threading.Tasks.Task"/> in <see cref="P:System.Threading.Tasks.Task.IsCompleted"/> state</returns>
        </member>
        <member name="T:JetBrains.Core.Result`2">
            <summary>
            Special kind of <see cref="T:JetBrains.Core.Result`1"/> to store custom <see cref="F:JetBrains.Core.Result`2.FailValue"/> in case of !<see cref="P:JetBrains.Core.Result`2.Succeed"/>. 
            </summary>
            <typeparam name="TSuccess"></typeparam>
            <typeparam name="TFailure"></typeparam>
        </member>
        <member name="F:JetBrains.Core.Result`2.Value">
            <summary>
            Value in case of <see cref="P:JetBrains.Core.Result`2.Succeed"/>, default(T) otherwise
            </summary>
        </member>
        <member name="F:JetBrains.Core.Result`2.ExceptionOrExceptionDispatchInfo">
            <summary>
            It this field not null, this Result is !<see cref="P:JetBrains.Core.Result`2.Succeed"/> and vise versa.
            </summary>
        </member>
        <member name="P:JetBrains.Core.Result`2.Exception">
            <summary>
            Exception in case of (!<see cref="P:JetBrains.Core.Result`2.Succeed"/>), null otherwise
            </summary>
        </member>
        <member name="T:JetBrains.Core.ResultException">
            <summary>
            Exception arising in <see cref="T:JetBrains.Core.Result"/> when do not specify exception explicitly: <see cref="M:JetBrains.Core.Result.Fail(System.String)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Core.Unit">
            <summary>
            Type that has the single instance accessible by <see cref="F:JetBrains.Core.Unit.Instance"/>. Adornment to <see cref="T:System.Void"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Core.Unit.Instance">
            <summary>
            The only way to get instance of type <see cref="T:JetBrains.Core.Unit"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.FirstChanceExceptionInterceptor">
            <summary>
            Facilitates runtime diagnostics when exception arises. In a current thread scope, put diagnostic information in exception if it arises somewhere in call stack.
            All information put will be available with ',' separator under <see cref="F:JetBrains.Diagnostics.FirstChanceExceptionInterceptor.ExceptionDataKey"/> when you print exception
            
            Usage:
            <code>
            using (new FirstChanceExceptionInterceptor.ThreadLocalDebugInfo(your_diagnostic_information))
            {
                you_arbitrary_code
            }
            </code>    
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.ILog">
            <summary>
            Logger's frontend. This class is used as entry point for logging in this library. It could
            be bound to any logger's backend (say log4net) used in your solution by
            <list type="number">
            <item>Implementing this class</item>
            <item>Implementing <see cref="T:JetBrains.Diagnostics.ILogFactory"/></item>
            <item>Set as default by <see cref="M:JetBrains.Diagnostics.ILog.Log(JetBrains.Diagnostics.LoggingLevel,System.String,System.Exception)"/>.<see cref="P:JetBrains.Diagnostics.Log.DefaultFactory"/></item>
            </list>
            
            <seealso cref="T:JetBrains.Diagnostics.ILogFactory"/> 
            <seealso cref="M:JetBrains.Diagnostics.ILog.Log(JetBrains.Diagnostics.LoggingLevel,System.String,System.Exception)"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.ILogFactory">
            <summary>
            Logger's factory frontend. This class could
            be bound to any logger's backend (say log4net) used in your solution. <see cref="T:JetBrains.Diagnostics.Log"/>
            <seealso cref="T:JetBrains.Diagnostics.ILog"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.SingletonLogFactory">
            <summary>
            This factory always create one instance of <see cref="T:JetBrains.Diagnostics.ILog"/> for any category
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.TextWriterLog">
            <summary>
            Log that able to write to <see cref="T:System.IO.TextWriter"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Internal.TextWriterLogFactory">
            <summary>
            Log factory that create <see cref="T:JetBrains.Diagnostics.Internal.TextWriterLog"/>. Could be created for file by <see cref="M:JetBrains.Diagnostics.Log.CreateFileLogFactory(JetBrains.Lifetimes.Lifetime,System.String,System.Boolean,JetBrains.Diagnostics.LoggingLevel)"/>
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.Log">
            <summary>
            Logger configuration entry point. 
            If you want see logs from this library to bound in your solution
            you have to bound <see cref="T:JetBrains.Diagnostics.ILog"/> to some logger implementation library (backend) used in your code base (say log4net)
            by implementing <see cref="T:JetBrains.Diagnostics.ILog"/> and <see cref="T:JetBrains.Diagnostics.ILogFactory"/> and setting them as default by <see cref="M:JetBrains.Diagnostics.Log.set_DefaultFactory(JetBrains.Diagnostics.ILogFactory)"/>. 
            </summary>
        </member>
        <member name="P:JetBrains.Diagnostics.Log.DefaultFactory">
            <summary>
            Default (lowest priority) <see cref="T:JetBrains.Diagnostics.ILogFactory"/>. If nothing chosen <see cref="F:JetBrains.Diagnostics.Log.ConsoleVerboseFactory"/> is used.
            This setting is effectively overriden (in a stack-like way) by <see cref="M:JetBrains.Diagnostics.Log.UsingLogFactory(JetBrains.Diagnostics.ILogFactory)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.UsingLogFactory(JetBrains.Diagnostics.ILogFactory)">
            <summary>
            Use this method if you want to set your global log factory (push it to the top of the stack).  
            </summary>
            <param name="factory">Factory to use as global  util returned object is not disposed</param>
            <returns>IDisposable, that should be disposed to return old logger factory. </returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog(System.String)">
            <summary>
            Creates log for <see cref="!:category"/>. Dots ('.') are separators between subcategories so all loggers form a hierarchy tree.
            </summary>
            <param name="category"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog(System.Type)">
            <summary>
            Creates logger for FQN of <paramref name="type"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.GetLog``1">
            <summary>
            Creates logger for FQN of type <see cref="!:T"/>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Diagnostics.Log.SwitchingLog">
            <summary>
            This class is used automatically as wrapper when you log something. On each log event it checks whether underlying <see cref="F:JetBrains.Diagnostics.Log.SwitchingLog.myFactory"/>
            implementation is switched. So you can substitute new log factories by <see cref="M:JetBrains.Diagnostics.Log.UsingLogFactory(JetBrains.Diagnostics.ILogFactory)"/> and every existing <see cref="T:JetBrains.Diagnostics.ILog"/>
            will be reconfigured on the fly. 
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.Log.DefaultDateFormat">
            <summary>
            Default format for <see cref="T:System.DateTime"/> of logging event.
            WARNING!!! don't change it, we have code that do fast formatting according this pattern
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.DefaultFormat(System.Nullable{System.DateTime},JetBrains.Diagnostics.LoggingLevel,System.String,System.Threading.Thread,System.String,System.Exception)">
            <summary>
            Default formatting of logging message
            </summary>
            <param name="date"></param>
            <param name="loggingLevel"></param>
            <param name="category"></param>
            <param name="thread"></param>
            <param name="message"></param>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.Log.CreateFileLogFactory(JetBrains.Lifetimes.Lifetime,System.String,System.Boolean,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Creates <see cref="T:JetBrains.Diagnostics.ILogFactory"/> that opens file writer. All log messages will be in <see cref="M:JetBrains.Diagnostics.Log.DefaultFormat(System.Nullable{System.DateTime},JetBrains.Diagnostics.LoggingLevel,System.String,System.Threading.Thread,System.String,System.Exception)"/>  
            </summary>
            <param name="lifetime">lifetime of file writer; after lifetime termination file writer will be closed</param>
            <param name="path">path to the file</param>
            <param name="append">append or rewrite file</param>
            <param name="enabledLevel">Filter out all messages with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> more than this. I.e. enabledLevel == INFO will filter out VERBOSE and TRACE.</param>
            <returns>created factory</returns>
            <exception cref="T:System.Exception"></exception>
            <exception cref="T:System.IO.IOException"></exception>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Trace(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.StringInterpolation.JetLogTraceInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.TRACE"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Trace($"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogTraceInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Trace(ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Verbose(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.StringInterpolation.JetLogVerboseInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Verbose($"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogVerboseInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Verbose(ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Verbose(JetBrains.Diagnostics.ILog,System.Exception,JetBrains.Diagnostics.StringInterpolation.JetLogVerboseInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Verbose(ex, $"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogVerboseInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Verbose(ex, ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Info(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.StringInterpolation.JetLogInfoInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.INFO"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Info($"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogInfoInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Info(ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Info(JetBrains.Diagnostics.ILog,System.Exception,JetBrains.Diagnostics.StringInterpolation.JetLogInfoInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.INFO"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Info(ex, $"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogInfoInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Info(ex, ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Warn(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.StringInterpolation.JetLogWarnInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.WARN"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Warn($"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogWarnInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Warn(ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="messageHandler"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Diagnostics.LogEx.Warn(JetBrains.Diagnostics.ILog,System.Exception,JetBrains.Diagnostics.StringInterpolation.JetLogWarnInterpolatedStringHandler@)" -->
        <member name="M:JetBrains.Diagnostics.LogEx.Error(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.StringInterpolation.JetLogErrorInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.ERROR"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Error($"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogErrorInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Error(ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Error(JetBrains.Diagnostics.ILog,System.Exception,JetBrains.Diagnostics.StringInterpolation.JetLogErrorInterpolatedStringHandler@)">
            <summary>
            Log the message if <see cref="F:JetBrains.Diagnostics.LoggingLevel.ERROR"/> is enabled, otherwise the message will not be logged, moreover, no calculations (including method calls) will be performed.
            <br />
            <br />
            For example, the code below
            <code>
            logger.Error(ex, $"{DoSmthSlow()}");
            </code>
            
            will be compiled into
            
            <code>
            var handler = new JetLogErrorInterpolatedStringHandler(logger, out var isEnabled);
            if (isEnabled)
              handler.Append(DoSmthSlow());
            logger.Error(ex, ref handler);
            </code>
            </summary>
            <param name="logger"></param>
            <param name="ex"></param>
            <param name="messageHandler"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Catch(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == ERROR. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.Catch``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == ERROR. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchAndDrop(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception discard it. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchAndDrop``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception discard it. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchWarn(JetBrains.Diagnostics.ILog,System.Action)">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == WARN. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.CatchWarn``1(JetBrains.Diagnostics.ILog,System.Func{``0})">
            <summary>
            Run <paramref name="action"/> and in case of exception log it with <see cref="T:JetBrains.Diagnostics.LoggingLevel"/> == WARN. Do not throw exception (if any).
            </summary>
            <param name="log"></param>
            <param name="action"></param>
            <returns>result of action() or <c>default(T)></c> if exception arises</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.WhenTrace(JetBrains.Diagnostics.ILog)">
            <summary>
            One-line shortcut builder to replace common pattern:
            <code>
              if (logger.IsTraceEnabled())
                logger.Trace($"some messages with {HeavyComputation()}"")
            </code>
            Usage:
            <code>
              logger.WhenTrace()?.Log($"some messages with {HeavyComputation()}")
            </code>
            </summary>
            <param name="logger"/>
            <returns>struct <see cref="T:JetBrains.Diagnostics.LogWithLevel"/>(<paramref name="logger"/>, <see cref="F:JetBrains.Diagnostics.LoggingLevel.TRACE"/>) if <see cref="M:JetBrains.Diagnostics.LogEx.IsTraceEnabled(JetBrains.Diagnostics.ILog)"/>;
            null otherwise</returns>
        </member>
        <member name="M:JetBrains.Diagnostics.LogEx.WhenVerbose(JetBrains.Diagnostics.ILog)">
            <summary>
            One-line shortcut builder to replace common pattern:
            <code>
              if (logger.IsVerboseEnabled())
                logger.Verbose($"some messages with {HeavyComputation()}"")
            </code>
            Usage:
            <code>
              logger.WhenVerbose()?.Log($"some messages with {HeavyComputation()}")
            </code>
            </summary>
            <param name="logger"></param>
            <returns>struct <see cref="T:JetBrains.Diagnostics.LogWithLevel"/>(<paramref name="logger"/>, <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE"/>) if <see cref="M:JetBrains.Diagnostics.LogEx.IsVersboseEnabled(JetBrains.Diagnostics.ILog)"/>;
            null otherwise</returns>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.OFF">
            <summary>
            Do not use it in logging. Only in config to disable logging.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.FATAL">
            <summary>
            For errors that lead to application failure 
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.ERROR">
            <summary>
            For errors that must be shown in Exception Browser
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.WARN">
            <summary>
            Suspicious situations but not errors
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.INFO">
            <summary>
            Regular level for important events
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE">
            <summary>
            Additional info for debugging
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LoggingLevel.TRACE">
            <summary>
            Methods &amp; callstacks tracing, more than verbose
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.LogLogRecord">
            <summary>
            log event for <see cref="T:JetBrains.Diagnostics.LogLog"/> 
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.LogLog">
            <summary>
            <see cref="T:JetBrains.Diagnostics.Log"/>'s own diagnostics. To record messages and exceptions from logger (and logger referenced code) and don't fall into infinite recursion.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore">
            <summary>
            Sliding window of records
            </summary>
        </member>
        <member name="P:JetBrains.Diagnostics.LogLog.StoredRecords">
            <summary>
            We store last <see cref="F:JetBrains.Diagnostics.LogLog.MaxRecordsToStore"/> loglog records to browse
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.LogWithLevel">
            <summary>
            Special struct to replace common patten by one-liner:
            Old code:
            <code>
              if (logger.IsTraceEnabled())
                logger.Trace($"value: {HeavyComputation()}"")
            </code>
            New code:
            <code>
              logger.Trace()?.Log($"value: {HeavyComputation()}")
            </code>
            </summary>
            <seealso cref="M:JetBrains.Diagnostics.LogEx.Trace(JetBrains.Diagnostics.ILog,System.String)"/>
            <seealso cref="M:JetBrains.Diagnostics.LogEx.Verbose(JetBrains.Diagnostics.ILog,System.String)"/>
        </member>
        <member name="M:JetBrains.Diagnostics.LogWithLevel.Log(System.String)">
            <summary>
            Log <paramref name="message"/> (via <see cref="M:JetBrains.Diagnostics.ILog.Log(JetBrains.Diagnostics.LoggingLevel,System.String,System.Exception)"/>) with level <see cref="P:JetBrains.Diagnostics.LogWithLevel.Level"/>
            </summary>
            <param name="message"/>
        </member>
        <member name="M:JetBrains.Diagnostics.LogWithLevel.CreateIfEnabled(JetBrains.Diagnostics.ILog,JetBrains.Diagnostics.LoggingLevel)">
            <summary>
            Create <see cref="T:JetBrains.Diagnostics.LogWithLevel"/> only if provided level for given logger is enabled.
            </summary>
            <param name="logger"/>
            <param name="level"/>
            <returns><see cref="T:JetBrains.Diagnostics.LogWithLevel"/>(<paramref name="logger"/>, <paramref name="level"/>) if <see cref="M:JetBrains.Diagnostics.ILog.IsEnabled(JetBrains.Diagnostics.LoggingLevel)"/> for given level;
            null otherwise</returns>
        </member>
        <member name="F:JetBrains.Diagnostics.Mode.IsAssertion">
            <summary>
            Whether asserts are enabled. Can be configured by setting JET_MODE_ASSERT = true/false in Current App Domain storage.
            </summary>
        </member>
        <member name="F:JetBrains.Diagnostics.Mode.IsAssertionUndefined">
            <summary>
            True if JET_MODE_ASSERT wasn't specified at the moment of static constructor invocation and default value was
            used instead.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Diagnostics.ModeInitializer.Init(System.Boolean)" -->
        <member name="M:JetBrains.Diagnostics.ModeInitializer.GetIsAssertion">
            <summary>
            Force touches <see cref="T:JetBrains.Diagnostics.Mode"/> class and return the value of the current assertion enabled mode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Diagnostics.ModeInitializer.GetIsAssertionUndefined">
            <summary>
            Force touches <see cref="T:JetBrains.Diagnostics.Mode"/> class and returns if the assertion mode was properly initialized from AppDomain
            config or default value was used instead
            </summary>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Diagnostics.ProcessWatchdog">
            <summary>
            Watchdog that automatically terminates current process if some other process exits.
            </summary>
        </member>
        <member name="T:JetBrains.Diagnostics.RName">
            <summary>
            Recursive name. For constructs like Aaaa.Bbb::CCC
            </summary>
        </member>
        <member name="M:JetBrains.Diagnostics.RName.Sub(System.Object,System.String)">
            <summary>
            Separator doesn't count if localName is empty or parent is empty.
            </summary>
            <param name="localName"></param>
            <param name="separator"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.Lifetimes.ITerminationHandler">
            <summary>
            Alternative to <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>.
            Special interface for <see cref="T:JetBrains.Lifetimes.Lifetime"/>'s termination participants to implement to avoid memory traffic on lambda creation.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeStatus">
            <summary>
            Lifetime's lifecycle statuses. Lifetime is created in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/> status and eventually becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/>.
            Status change is one way road: from lower ordinal to higher (<c>Alive -> Canceling -> Terminating -> Terminated </c>).
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Alive">
            <summary>
            Lifetime is ready to use. Every lifetime's method will work. 
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Canceling">
             <summary>
             This status propagates instantly through all lifetime's children graph when <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> is invoked.
             Lifetime is in consistent state (no resources are terminated) but termination process is already began. All background activities that block
             termination (e.g. started with <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/>) should be interrupted
             as fast as possible. That's why background activities must check <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive"/>
             quite ofter (200 ms is a good reference value).
            
             Some methods in this status still works, e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/> others do nothing (<see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>)
             or throw <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/> (<see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.Bracket(System.Action,System.Action)"/>)
            
             Associated <see cref="M:JetBrains.Lifetimes.Lifetime.ToCancellationToken"/> is canceled.
             </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Terminating">
            <summary>
            Lifetime is in inconsistent state. Destruction begins: some resources are terminated, other not. All method throw exception or do nothing
            (e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.Action)"/>). 
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeStatus.Terminated">
            <summary>
            Lifetime is fully terminated, all resources are disposed and method's behavior is the same as in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> state.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind">
            <summary>
            Lifetime's termination timeout kind. The actual milliseconds value can be assigned via <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.SetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind,System.Int32)"/>. 
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind.Default">
            <summary>
            Default timeout (500ms).<br/>
            The actual value defined by <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.WaitForExecutingInTerminationTimeoutMs"/> (compatibility mode).
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind.Short">
            <summary>
            Short timeout (250ms).<br/>
            The actual value can be overridden via <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.SetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind.Long">
            <summary>
            Long timeout (5s).<br/>
            The actual value can be overriden via <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.SetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind,System.Int32)"/>.
            </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind.ExtraLong">
            <summary>
            Extra long timeout (30s).<br/>
            The actual value can be overriden via <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.SetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind,System.Int32)"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.Lifetime">
             <summary>
             Central class in <see cref="N:JetBrains.Lifetimes"/> package. Has two main functions:<br/>
             1. High performance analogue of <see cref="T:System.Threading.CancellationToken"/>. <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> is analogue of <see cref="T:System.Threading.CancellationTokenSource"/> <br/>
             2. Inversion of <see cref="T:System.IDisposable"/> pattern (with thread-safety):
             user can add termination resources into Lifetime with bunch of <c>OnTermination</c> (e.g. <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>) methods.
             When lifetime is being terminated (i.e. it's <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> was called <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/>) all
             previously added termination resources are being terminated in stack-way LIFO order. Lifetimes forms a hierarchy with parent-child relations so in single-threaded world child always
             becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> <b>BEFORE</b> parent. Usually this hierarchy is a tree but in some cases (like <see cref="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime[])"/> it can be
             a directed acyclic graph. 
            
             <para>
             Kinds of termination resources:
             <list type="number">
             <item><see cref="T:System.Action"/> - merely invoked on termination</item>
             <item><see cref="T:System.IDisposable"/> - <see cref="M:System.IDisposable.Dispose"/> is called on termination</item>
             <item><see cref="T:JetBrains.Lifetimes.ITerminationHandler"/> - <see cref="M:JetBrains.Lifetimes.ITerminationHandler.OnTermination(JetBrains.Lifetimes.Lifetime)"/> is called on termination</item>
             <item><see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> - for nested(child) lifetimes created by <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime)"/>.
             Child lifetime definition's <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> method is called.</item>
             </list>
            
             If some resource throws an exception during termination, it will be logged by <see cref="T:JetBrains.Diagnostics.ILog"/> with level <see cref="F:JetBrains.Diagnostics.LoggingLevel.ERROR"/> so termination of other resources
             won't be affected.
            
             
             
             <c>Lifetime</c> could be converted to <see cref="T:System.Threading.CancellationToken"/> by implicit cast or by explicit <see cref="M:JetBrains.Lifetimes.Lifetime.ToCancellationToken"/> to use in task based API. You can start
             </para>
             </summary>
        </member>
        <member name="F:JetBrains.Lifetimes.Lifetime.AsyncLocal">
            <summary>
            Special "async-static" lifetime that is captured when you execute <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            and can be used by cooperative cancellation.
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Eternal">
            <summary>
            <para>A lifetime that never ends. Scheduling actions on such a lifetime has no effect.</para>
            <para>Do not call <see cref="M:JetBrains.Lifetimes.Lifetime.AddRef(System.Object)"/> on such a lifetime, because it will not hold your object forever.</para>  
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Terminated">
            <summary>
            Singleton lifetime that is in <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> state by default.  
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Status">
            <summary>
            Lifecycle phase of current lifetime. 
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsEternal">
            <summary>
            Whether current lifetime is equal to <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal"/> and never be terminated
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsAlive">
            <summary>
            Is <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> of this lifetime equal to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.IsNotAlive">
            <summary>
            Is <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> of this lifetime not equal to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>: Termination started already (or even finished).
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.TerminationTimeoutKind">
            <summary>
            Gets termination timeout kind for the lifetime.<br/>
            The sub-definitions inherit this value at the moment of creation.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(System.IDisposable)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.OnTermination(JetBrains.Lifetimes.ITerminationHandler)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.Action)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(System.IDisposable)" -->
        <!-- Badly formed XML comment ignored for member "M:JetBrains.Lifetimes.Lifetime.TryOnTermination(JetBrains.Lifetimes.ITerminationHandler)" -->
        <member name="P:JetBrains.Lifetimes.Lifetime.ExecutingCount">
            <summary>
            Number of background activities started by <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>, <see cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            When lifetime became <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Canceling"/> (it happens right after user ask for this lifetime's or ancestor lifetime's definition <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/>) this
            number could only reduce, no new activities can be started.
            When it reach zero, lifetime begins to terminate its resources by changing <see cref="P:JetBrains.Lifetimes.Lifetime.Status"/> to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/>  
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution">
            <summary>
            If you terminate lifetime definition <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> you'll get exception because 
            it's impossible to keep guarantee that code under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> works with non-terminating lifetime.
            However if you know what you are doing (e.g. <c>Terminate</c> is the last call in code under <c>Execute</c>), you can take this cookie and allow this behavior.
            </summary>
            <returns>Disposable that allow to call <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> </returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingExecuteIfAlive(System.Boolean)">
            <summary>
            This method could be used as non-allocation version of <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> or <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>.
            Typical usage pattern is the following:
            <code>
              using (val cookie = lifetime.ExecuteIfAliveCookie()) {
                if (cookie.Succeed) {
                   // you can rely lifetime's resources are alive here (the same as body of Lifetime.Execute, Lifetime.TryExecute).
                } else {
                  //  lifetime is not alive, return (as TryExecute) or throw OCE (as Execute)
                }
              }
            </code>
            </summary>
            <param name="allowTerminationUnderExecution">Automatically takes <see cref="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution"/> under cookie</param>
            <returns>Special disposable object. If <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.ExecuteIfAliveCookie.Succeed"/> than until <c>Dispose</c> current lifetime can't
            become <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> and can't start resources destruction. If <c>!Succeed</c> than lifetime is already
            <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> or <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/> </returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)">
            <summary>
            Executes <paramref name="action"/> in atomic manner, preventing lifetime to terminate:
            <list type="number">
            <item>If <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/> is false then <paramref name="action"/> isn't executed and method returns <see cref="M:JetBrains.Core.Result.Canceled"/></item>
            <item>If <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/> is true then <paramref name="action"/> starts to execute and lifetime can't
            become <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> until this execution finished. If someone terminates lifetime during action invocation,
            it immediately becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Canceling"/> (that forbids all following <see cref="M:JetBrains.Lifetimes.Lifetime.Execute(System.Action)"/> to start), wait until
            <paramref name="action"/> finishes its execution and only then status is set to <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminating"/> i.e. resource termination begins. </item>
            </list>
            
              
            </summary>
            <remarks>
            <paramref name="action"/> execution can last long and lifetime termination can hang because of it. If you want responsiveness you must check lifetime from time to time inside execution body
            (e.g. by <see cref="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive"/> method).
            </remarks>
            <param name="action">action to execute if this lifetime <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/></param>
            <param name="wrapExceptions">if some exception (even <see cref="T:System.OperationCanceledException"/>) is thrown during execution should we wrap it
            into <see cref="T:JetBrains.Core.Result`1"/> or throw (default)</param>
            <typeparam name="T"></typeparam>
            <returns><see cref="T:JetBrains.Core.Result"/> that encapsulates execution: successful, canceled ot fail</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryExecute(System.Action,System.Boolean)">
            <summary>
            See <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>
            </summary>
            <param name="action"></param>
            <param name="wrapExceptions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/> but any if lifetime <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/> than throws <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/>
            </summary>
            <param name="action"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Execute(System.Action)">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/> but any if lifetime <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/> than throws <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/> 
            </summary>
            <param name="action"></param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryBracket(System.Action,System.Action,System.Boolean)">
             <summary>
             Semantic equivalent of <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>(<paramref name="opening"/>) and <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>(<paramref name="closing"/>)
             in atomic manner. Both actions will be executed only if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>: <paramref name="opening"/> immediately and <paramref name="closing"/> on termination. 
            
             If exception happens in <paramref name="opening"/> it will be thrown (or wrapped into <see cref="T:JetBrains.Core.Result`1"/> as in <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/>), but <paramref name="closing"/>
             will be executed on termination anyway.
             </summary>
             <param name="opening"></param>
             <param name="closing"></param>
             <param name="wrapExceptions"></param>
             <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryBracket``1(System.Func{``0},System.Action,System.Boolean)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.TryBracket(System.Action,System.Action,System.Boolean)"/>
            </summary>
            <param name="opening"></param>
            <param name="closing"></param>
            <param name="wrapExceptions"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryBracket``1(System.Func{``0},System.Action{``0},System.Boolean)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.TryBracket(System.Action,System.Action,System.Boolean)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Bracket(System.Action,System.Action)">
             <summary>
             Semantic equivalent of <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/>(<paramref name="opening"/>) and <see cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.Action)"/>(<paramref name="closing"/>)
             in atomic manner. Both actions will be executed only if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>: <paramref name="opening"/> immediately and <paramref name="closing"/> on termination.
             Otherwise (see <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/>) <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/> will be thrown. 
            
             If exception happens in <paramref name="opening"/> it will be thrown but <paramref name="closing"/>
             will be executed on termination anyway.
             </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Bracket``1(System.Func{``0},System.Action)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Bracket(System.Action,System.Action)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Bracket``1(System.Func{``0},System.Action{``0})">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Bracket(System.Action,System.Action)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.ToCancellationToken">
            <summary>
            Transforms this lifetime into cancellation token
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive">
            <summary>
            Throws <see cref="T:JetBrains.Lifetimes.LifetimeCanceledException"/> is this lifetimes is <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Using``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNested``1(System.Func{JetBrains.Lifetimes.Lifetime,``0})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The newly-created lifetime will be nested within the parent  lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
              <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and might terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingAsync``1(JetBrains.Lifetimes.OuterLifetime,System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
            </summary>
            <param name="parent">A parent lifetime which limits the lifetime given to your action, and might terminate it before the action ends.</param>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.CreateNested">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime)"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.CreateNested(System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.KeepAlive(System.Object)">
            <summary>
            Keeps object from being garbage collected until this lifetime is terminated.
            <seealso cref="T:JetBrains.Lifetimes.Lifetimed`1"/>
            </summary>
            <param name="object"></param>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AddDispose(System.IDisposable)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.OnTermination(System.IDisposable)"/>
            <remarks>It's more clear for code review purposes when you are adding IDisposable by <c>AddDispose</c> rather than by <c>OnTermination</c></remarks>
            </summary>
            <param name="disposable"></param>
            <returns>The same lifetime (fluent API)</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Synchronize(JetBrains.Lifetimes.LifetimeDefinition[])">
            <summary>
            Synchronizes termination of two lifetime definitions.
            Whenever any one is terminated, the other will be terminated also.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection with other lifetime: new lifetime that terminate when either one terminates.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)">
            <summary>
            Creates an intersection of some lifetimes: new lifetime that terminate when either one terminates.
            Created lifetime inherits the smallest <see cref="P:JetBrains.Lifetimes.Lifetime.TerminationTimeoutKind"/>  
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime[])">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.DefineIntersection(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)">
             <summary>
             <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Intersect(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)"/>
            
             This method returns definition rather than lifetime, so in addition to any parent's termination you can
             <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> it manually.  
             </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.DefineIntersection(JetBrains.Lifetimes.Lifetime[])">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.DefineIntersection(JetBrains.Lifetimes.Lifetime,JetBrains.Lifetimes.Lifetime)"/>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.Lifetime.Id">
            <summary>
            <inheritdoc cref="P:JetBrains.Lifetimes.LifetimeDefinition.Id"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.EnableTerminationLogging">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.LifetimeDefinition.EnableTerminationLogging"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
             <summary>
               <para>Defines a new lifetime nested within the <paramref name="lifetime" /> you pass in.</para>
             </summary>
             <remarks>
               <para>In most cases, you should have some lifetime to use as a parent, such as the lifetime of your component. If this is not the case, and you just need a function-scoped lifetime, call <see cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" /> instead. It is terminated automatically when your action ends and thus does not need a parent.</para>
               <para>If the lifetime you're created is really not parented by any other lifetime, use the <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal" /> as a parent.</para>
             </remarks>
             <param name="lifetime">
               <para>The parent lifetime.</para>
               <para>The newly-created lifetime will be nested within the parent lifetime and thus terminated automatically when the parent lifetime ends (unless the nested lifetime is terminated first).</para>
               <para>Nested lifetimes are listed within the parent lifetime, but as they're terminated, the records are removed. There will be no memory leak on the parent lifetime if the nested lifetimes are terminated.</para>
             </param>
             <param name="id">
               <para>Optional. The ID of the lifetime.</para>
               <para>Used for tracking and debugging. If the call stack annotations feature is ON, this ID will appear on the call stack when the lifetime object starts executing scheduled actions upon termination.</para>
               <para>In case of nested lifetimes and if scheduled actions are anonymous in their nature, it might be hard to tell what's happening from exception stack traces without this annotation. You're encouraged to specify IDs wherever such situations are suspected, but the IDs should better be statically defined (to avoid memory leaks on part of the call stacks annotation engine).</para>
               <para>If omitted, the default <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.AnonymousLifetimeId" /> or the <see cref="T:JetBrains.Lifetimes.Lifetime" /> should type name is used, depending on the context.</para>
             </param>
             <param name="atomicAction">
               <para>Optional. The code to be executed atomically on the newly-created lifetime.</para>
               <para>If this code succeeds (or is not specified), the definition of the new lifetime is returned from the method.</para>
               <para>If this code fails with an exception, the newly-created lifetime is terminated, all of the scheduled actions are executed (rolling back any activities already bound to the lifetime), the nested lifetime is not registered no the parent, and the exception is let out of this method.</para>
             </param>    
             <returns>
               <para>The definition to the new lifetime.</para>
               <para>As you own the lifetime, you can terminate it through this definition at any time.</para>
               <para>To pass the lifetime to objects&amp;functions or schedule termination actions on it, get it from the <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime" /> property. Do not pass the definition itself to child objects, unless this is the intended scenario to allow them to terminate the lifetime upon their discretion (e. g. a user-cancelable non-modal dialog).</para>
             </returns>
             <seealso cref="M:JetBrains.Lifetimes.Lifetime.Using(System.Action{JetBrains.Lifetimes.Lifetime})" />
            
             <remarks>For compatibility reason logic is different than <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>: in this method
             <paramref name="atomicAction"/> is always executed</remarks>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>
            </summary>
            <param name="lifetime"></param>
            <param name="atomicAction"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.Lifetime.Define(JetBrains.Lifetimes.Lifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>
            </summary>
            <param name="lifetime"></param>
            <param name="id"></param>
            <param name="atomicAction"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Define(System.String)">
            <summary>
            Same as <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor"/> with <see cref="P:JetBrains.Lifetimes.Lifetime.Id"/> = <paramref name="id"/>
            </summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Do the same as <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> but also (if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>) suppress lifetime termination until task returned by <paramref name="closure"/>
            is finished. Task will see this lifetime in <see cref="F:JetBrains.Lifetimes.Lifetime.AsyncLocal"/>.
            </summary>
            <param name="closure"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/>
            </summary>
            <param name="closure"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryExecuteAsync(System.Func{System.Threading.Tasks.Task},System.Boolean)">
            <summary>
            Do the same as <see cref="M:JetBrains.Lifetimes.Lifetime.TryExecute``1(System.Func{``0},System.Boolean)"/> but also (if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>) suppress lifetime termination until task returned by <paramref name="closure"/>
            is finished. Task will see this lifetime in <see cref="F:JetBrains.Lifetimes.Lifetime.AsyncLocal"/>.
            </summary>
            <param name="closure"></param>
            <param name="wrapExceptions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryExecuteAsync``1(System.Func{System.Threading.Tasks.Task{``0}},System.Boolean)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.ExecuteAsync(System.Func{System.Threading.Tasks.Task})"/>
            </summary>
            <param name="closure"></param>
            <param name="wrapExceptions"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Starts task with this lifetime as <see cref="T:System.Threading.CancellationToken"/>. Task will see this lifetime in <see cref="F:JetBrains.Lifetimes.Lifetime.AsyncLocal"/>.
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Start``1(System.Threading.Tasks.TaskScheduler,System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.Start``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAsync(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAsync(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAsync``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAsync``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,System.Threading.Tasks.Task{``0}},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.Start(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Starts task with this lifetime as <see cref="T:System.Threading.CancellationToken"/> but also (if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>) suppress
            lifetime termination until task is finished. Task will see this lifetime in <see cref="F:JetBrains.Lifetimes.Lifetime.AsyncLocal"/>.
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action{System.Object},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Starts task with this lifetime as <see cref="T:System.Threading.CancellationToken"/> but also (if <see cref="P:JetBrains.Lifetimes.Lifetime.IsAlive"/>) suppress
            lifetime termination until task is finished. Task will see this lifetime in <see cref="F:JetBrains.Lifetimes.Lifetime.AsyncLocal"/>.
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttached``1(System.Threading.Tasks.TaskScheduler,System.Func{``0},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttached``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,``0},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttachedAsync(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttachedAsync(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,System.Threading.Tasks.Task},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttachedAsync``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Threading.Tasks.Task{``0}},System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.StartAttachedAsync``1(System.Threading.Tasks.TaskScheduler,System.Func{System.Object,System.Threading.Tasks.Task{``0}},System.Object,System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.StartAttached(System.Threading.Tasks.TaskScheduler,System.Action,System.Threading.Tasks.TaskCreationOptions)"/>
            </summary>
            <param name="scheduler"></param>
            <param name="action"></param>
            <param name="state"></param>
            <param name="options"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.CreateTaskCompletionSource``1(System.Threading.Tasks.TaskCreationOptions)">
            <summary>
            Creates new <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/> that translate <see cref="P:System.Threading.Tasks.Task.Status"/> into canceled if this lifetime becomes terminates (and task wasn't completed before).
            </summary>
            <param name="options">to pass into <see cref="!:TaskCompletionSource&lt;TResult&gt;.ctor"/></param>
            <typeparam name="T"></typeparam>
            <returns>New <see cref="T:System.Threading.Tasks.TaskCompletionSource`1"/>. Possibly with already canceled <see cref="P:System.Threading.Tasks.TaskCompletionSource`1.Task"/> if this lifetime already terminated</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.CreateTerminatedAfter(System.TimeSpan,System.Threading.Tasks.TaskScheduler)">
            <summary>
            Returns lifetime that is child of this lifetime and will be terminated after specified period of time.
            </summary>
            <param name="timeSpan">Terminate lifetime after this amount of time</param>
            <param name="terminationScheduler">Scheduler where termination will be invoked (if none specified, termination will start in timer's thread)</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.WrapAsObject(JetBrains.Lifetimes.Lifetime)">
            <summary>
            Box lifetime without allocation. Must be use in pair with <see cref="M:JetBrains.Lifetimes.Lifetime.TryUnwrapAsObject(System.Object,JetBrains.Lifetimes.Lifetime@)"/>.
            </summary>
            <param name="lifetime">Lifetime that you want to box without allocation</param>
            <returns><see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> for this lifetime. ONLY for zero-allocation purpose.</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.TryUnwrapAsObject(System.Object,JetBrains.Lifetimes.Lifetime@)">
            <summary>
            Try to unwrap object into <see cref="T:JetBrains.Lifetimes.Lifetime"/>. Must be used in pair with <see cref="M:JetBrains.Lifetimes.Lifetime.WrapAsObject(JetBrains.Lifetimes.Lifetime)"/>.
            </summary>
            <param name="obj">object that potentially is LifetimeDefinition previously wrapped by <see cref="M:JetBrains.Lifetimes.Lifetime.WrapAsObject(JetBrains.Lifetimes.Lifetime)"/></param>
            <param name="lifetime">if <code>obj is LifetimeDefinition</code> returns corresponding <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime"/>; else returns <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal"/></param>
            <returns>true if <code>obj is LifetimeDefinition</code> previously wrapped by <see cref="M:JetBrains.Lifetimes.Lifetime.WrapAsObject(JetBrains.Lifetimes.Lifetime)"/>. false otherwise</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertEverTerminated(System.String)">
            <summary>
            <para>If this lifetime never gets terminated (and all the references to it get lost), reports an exception to the logger.</para>
            <para>The lifetime will not be terminated automatically, because this is not a lifetime definition. See Remarks for options.</para>
            <para>Note that this method means certain load on the finalization queue, and can degrade performance if used in large amounts.</para>
            <para>Fluent.</para>
            </summary>
            <remarks>
            <para>As this method operates on a <see cref="T:JetBrains.Lifetimes.Lifetime"/> object you do not own, it cannot terminate the lifetime automatically when a missed termination is detected.</para>
            </remarks>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.AssertTerminatesIn(System.TimeSpan,System.String)">
            <summary>
            Log error if this lifetime hasn't been terminated in specified <paramref name="timeout"/> 
            </summary>
            <param name="timeout">Maximum timeout to wait this lifetime is terminated</param>
            <param name="comment">Optional comment to log when assertion failed</param>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.RetryWhileOperationCancellingAsync(System.Func{System.Threading.Tasks.Task})">
            <summary>
            Creates and starts new <paramref name="task"/> while it is finished with <see cref="T:System.OperationCanceledException"/>.
            Returned task can be finished in:
            <list type="number">
            <item>successfully - if some started <paramref name="task"/> finished successfully</item>
            <item>failed - if some started <paramref name="task"/> finished with exception other than <see cref="T:System.OperationCanceledException"/></item>
            <item>canceled - if this lifetime <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/></item>
            </list>
            </summary>
            <param name="task"></param>
            <returns></returns>
            <exception cref="T:JetBrains.Lifetimes.LifetimeCanceledException"></exception>
        </member>
        <member name="M:JetBrains.Lifetimes.Lifetime.RetryWhileOperationCancellingAsync``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.RetryWhileOperationCancellingAsync(System.Func{System.Threading.Tasks.Task})"/>
            </summary>
            <param name="task"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:JetBrains.Lifetimes.LifetimeCanceledException"></exception>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeCanceledException">
            <summary>
            Inheritor of <see cref="T:System.OperationCanceledException"/> which is thrown by <see cref="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive"/>.
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.Lifetimed`1">
            <summary>
            Special kind reference to <see cref="P:JetBrains.Lifetimes.Lifetimed`1.Value"/> 
            that automatically nullify it (make <c>default</c> for value types)
            when lifetime becomes <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/>. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeDefinition">
            <summary>
            Controller for <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime"/> like <see cref="T:System.Threading.CancellationTokenSource"/> is a controller fot <see cref="T:System.Threading.CancellationToken"/>.
            You can terminate this definition by <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> method (or <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Dispose"/> which is the same). 
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.ExecutionWasNotCancelledByTimeout">
            <summary>
            Use this signal to improve diagnostics (e.g., to collect thread dumps etc.)) 
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeDefinition.AllowTerminationUnderExecutionCookie">
            <summary>
            Use this cookie only by <see cref="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.GetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind)">
            <summary>
            Gets the actual value in milliseconds for termination timeout kind (short, long, etc).
            </summary>
            <param name="timeoutKind">timeout kind as defined by <see cref="T:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind"/></param>
            <returns>timeout value in milliseconds</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.SetTerminationTimeoutMs(JetBrains.Lifetimes.LifetimeTerminationTimeoutKind,System.Int32)">
            <summary>
            Sets the actual value in milliseconds for termination timeout kind (short, long, etc).
            </summary>
            <param name="timeoutKind">timeout kind as defined by <see cref="T:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind"/></param>
            <param name="milliseconds">timeout value in milliseconds</param>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime">
            <summary>
            Underlying lifetime for this definition.
            <remarks> There are no implicit cast from <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> to <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Lifetime"/> intentionally.
            When method receives <see cref="T:JetBrains.Lifetimes.LifetimeDefinition"/> as a parameter it means (in a philosophic sense) that this method either responsible for definition's termination
            or it must pass definition to some other method.
            You can easily make a mistake and forget to terminate definition when you implicitly convert into lifetime and pass to some other method.
            </remarks>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.Status">
            <summary>
            <inheritdoc cref="T:JetBrains.Lifetimes.LifetimeStatus"/>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.IsEternal">
            <summary>
            Means that this definition corresponds to <see cref="P:JetBrains.Lifetimes.Lifetime.Eternal"/> and can't be terminated. 
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.AllowTerminationUnderExecution">
             <summary>
             Hack that allows to terminate this definition under <see cref="M:JetBrains.Lifetimes.Lifetime.Execute``1(System.Func{``0})"/> section. 
            
             <inheritdoc cref="M:JetBrains.Lifetimes.Lifetime.UsingAllowTerminationUnderExecution"/>
             </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.TerminationTimeoutKind">
            <summary>
            Gets or sets termination timeout kind for the definition.<br/>
            The sub-definitions inherit this value at the moment of creation.
            The changing of <c>TerminationTimeoutKind</c> doesn't affect already created sub-definitions.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor">
            <summary>
            Creates toplevel lifetime definition with no parent. <see cref="P:JetBrains.Lifetimes.LifetimeDefinition.Status"/> will always be <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>.<br/>
            Created definition and all its children (if not explicitly overriden) will have specified termination timeout (see <see cref="T:JetBrains.Lifetimes.LifetimeTerminationTimeoutKind"/>). 
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime)">
             <summary>
             <para>
             Created definition nested into <paramref name="parent"/>, i.e. this definition is attached to parent as termination resource.  
             If parent <see cref="!:Lifetimes.Lifetime.Alive"/> than status of new definition is <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>.
             If parent <see cref="P:JetBrains.Lifetimes.Lifetime.IsNotAlive"/> than status of new definition is <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Terminated"/>.
             </para>
             
             <para>
             <see cref="!:parent"/>'s termination (via <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> method) will instantly propagate <c>Canceling</c> signal
             to all descendants, i.e all statuses of parent's children, children's children, ... will become <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Canceling"/>
             instantly. And then resources destructure will begin from the most recently connected children to the last (stack's like LIFO way).
             </para>
            
             <para>
             Created definition inherits current value of <paramref name="parent"/>.<see cref="P:JetBrains.Lifetimes.LifetimeDefinition.TerminationTimeoutKind"/>.<br/>
             Note: subsequent change of <c>TerminationTimeoutKind</c> doesn't affect already created sub-definitions.
             </para>
             </summary>
            
             <param name="parent"></param>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
             <summary>
             <inheritdoc cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime)"/>
            
             <para>
             <c>atomicAction</c> will be executed only if <paramref name="parent"/>'s status is <see cref="F:JetBrains.Lifetimes.LifetimeStatus.Alive"/>.
             Any exception thrown by <paramref name="atomicAction"/> execution will cause termination of created definition (it will be returned
             in status <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.Terminated"/>) and all attached resources will be terminated.
             </para> 
             </summary>
             <param name="parent"></param>
             <param name="atomicAction"></param>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            <inheritdoc cref="M:JetBrains.Lifetimes.LifetimeDefinition.#ctor(JetBrains.Lifetimes.Lifetime,System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>
            </summary>
            <param name="parent"></param>
            <param name="atomicAction"></param>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.Id">
            <summary>
            You can optionally set this identification information to see logs with lifetime's id other than <see cref="F:JetBrains.Lifetimes.LifetimeDefinition.AnonymousLifetimeId"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.EnableTerminationLogging">
            <summary>
            Enables logging of this lifetime's termination with level <see cref="F:JetBrains.Diagnostics.LoggingLevel.VERBOSE"/> rather than <see cref="F:JetBrains.Diagnostics.LoggingLevel.TRACE"/>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.LifetimeDefinition.ExecutingCount">
            <summary>
            <inheritdoc cref="P:JetBrains.Lifetimes.Lifetime.ExecutingCount"/>
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimeDefinition.ExecuteIfAliveCookie">
            <summary>
            Must be used only by <see cref="M:JetBrains.Lifetimes.Lifetime.UsingExecuteIfAlive(System.Boolean)"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.ThrowIfNotAlive">
            <summary>
            <see cref="M:JetBrains.Lifetimes.Lifetime.ThrowIfNotAlive"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.AssertEverTerminated(System.String)">
            <summary>
            Adds finalizer that logs error (via <see cref="!:Log.Error"/>) if this definition is garbage collected without being terminated.  
            </summary>
            <param name="comment"></param>
        </member>
        <member name="M:JetBrains.Lifetimes.LifetimeDefinition.SynchronizeWith``1(System.Threading.Tasks.TaskCompletionSource{``0})">
            <summary>
            <list type="number">
            <item>Finishes <paramref name="taskCompletionSource"/> with <see cref="M:System.Threading.Tasks.TaskCompletionSource`1.SetCanceled"/> when
            this definition is termination.</item>
            <item>
            Terminates this definition by <see cref="M:JetBrains.Lifetimes.LifetimeDefinition.Terminate"/> when <paramref name="taskCompletionSource"/> is completed (with any result).
            </item>
            </list>
            </summary>
            <param name="taskCompletionSource"></param>
            <typeparam name="T"></typeparam>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="T:JetBrains.Lifetimes.LifetimedList`1">
             <summary>
             Thread safe list for <see cref="T:JetBrains.Lifetimes.ValueLifetimed`1"/> entities.
            
             There are no <see cref="M:System.Collections.Generic.ICollection`1.Remove(`0)"/> method, it's append only. When item's <see cref="P:JetBrains.Lifetimes.ValueLifetimed`1.Lifetime"/> becomes
             not alive, item's <see cref="P:JetBrains.Lifetimes.ValueLifetimed`1.Value"/> is cleared (to avoid memory leak) and item is fully removed from internal
             <see cref="F:JetBrains.Lifetimes.LifetimedList`1.myItems"/> array after exponential growth phase in <see cref="M:JetBrains.Lifetimes.LifetimedList`1.EnsureCapacityNoLock(System.Boolean,JetBrains.Lifetimes.ValueLifetimed{`0}[]@,System.Int32@,System.Int32@)"/>.
            
              
             </summary>
             <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Lifetimes.OuterLifetime">
            <summary>
              <para>A subset of the <see cref="T:JetBrains.Lifetimes.Lifetime" /> interface with which you cannot “bind” actions to a lifetime.</para>
              <para>It's “outer” in the sense that it's not your lifetime, but of some parent object potentially more long-lived than yours. You cannot schedule anything to its termination because it will happen way after your object goes off scope.</para>
              <para>The only thing you can know is that it's an “outer”, it's limiting the life of your object, and if it's terminated — so are you. Checking for <see cref="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated" /> is one of the allowed option.</para>
              <para>Another option is to define a nested lifetime, in which case you MUST ensure it's terminated explicitly, without relying on the outer lifetime. The outer lifetime is only a safety catch to make sure it does not live too long.</para>
            </summary>
        </member>
        <member name="P:JetBrains.Lifetimes.OuterLifetime.IsTerminated">
            <summary>
              <para>Gets whether this lifetime has already been terminated.</para>
              <para>It's an error to continue scheduling on a terminated lifetime.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync``1(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task{``0}})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.UsingNestedAsync(System.Func{JetBrains.Lifetimes.Lifetime,System.Threading.Tasks.Task})">
            <summary>
              <para>Scopes your code in <paramref name="action" /> with a lifetime that is terminated automatically when <paramref name="action" /> completes execution, or when its execution is aborted by an exception.</para>
              <para>Analogous to the <c>using</c> statement of the C# language on everything that is added to the lifetime.</para>
              <para>The parent lifetime which might cause premature termination of our lifetime (and, supposedly, the chain of tasks executed under the lifetime, if started correctly).</para>
            </summary>
            <param name="action">The code to execute with a temporary lifetime.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.Define(JetBrains.Lifetimes.OuterLifetime,System.String,System.Action{JetBrains.Lifetimes.LifetimeDefinition,JetBrains.Lifetimes.Lifetime})">
            <summary>
              <para>See documentation on an overload which takes a <see cref="T:JetBrains.Lifetimes.Lifetime" />.</para>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.OuterLifetime.DefineIntersection(JetBrains.Lifetimes.OuterLifetime[])">
            <summary>
            Creates an intersection of some lifetimes — a lifetime to terminate when either one terminates.
            Created lifetime inherits the smallest <see cref="P:JetBrains.Lifetimes.Lifetime.TerminationTimeoutKind"/>
            </summary>
        </member>
        <member name="T:JetBrains.Lifetimes.SequentialLifetimes">
            <summary>
            Maintains a sequence of lifetimes, so that the previous lifetime is closed before the new one is opened.
            Good for implementing a sequence of non-simultaneous activities when it's nice to guarantee only one is active at a time.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.#ctor(JetBrains.Lifetimes.Lifetime)">
            <summary>Creates and binds to the lifetime.</summary>
            <param name="lifetime">When this lifetime is closed, the last of the sequential lifetimes is closed too.</param>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.Next">
            <summary>
            Terminates current lifetime and starts new.
            </summary>
            <returns>New lifetime. Note, In case of a race condition this lifetime might be terminated.</returns>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.Next(System.Action{JetBrains.Lifetimes.Lifetime})">
            <summary>
            Terminates the current lifetime, calls your handler with the new lifetime and tries to set it as current.
            Similar to <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.DefineNext(System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.DefineNext(System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
            <summary>
            Terminates the current lifetime, calls your handler with the new lifetime and tries to set it as current.
            Similar to <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.Next(System.Action{JetBrains.Lifetimes.Lifetime})"/>
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent">
            <summary>
            Terminates the current lifetime and calls your handler with the new lifetime.
            The lifetime definition allows to terminate it as desired.
            Also, the lifetime will be terminated when either parent lifetime is terminated,
            or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.TerminateCurrent"/> is called, or <see cref="M:JetBrains.Lifetimes.SequentialLifetimes.DefineNext(System.Action{JetBrains.Lifetimes.LifetimeDefinition})"/>/<see cref="M:JetBrains.Lifetimes.SequentialLifetimes.Next"/> is called.
            </summary>
            <summary>
            Terminates the current lifetime.
            </summary>
        </member>
        <member name="M:JetBrains.Lifetimes.SequentialLifetimes.TrySetNewAndTerminateOld(JetBrains.Lifetimes.LifetimeDefinition,System.Action{JetBrains.Lifetimes.LifetimeDefinition})">
            <summary>
            Atomically, assigns the new lifetime and terminates the old one.
            In case of a race condition when current lifetime is overwritten new lifetime is terminated
            </summary>
            <param name="newLifetimeDefinition">New lifetime definition to set</param>
            <param name="actionWithNewLifetime">Action to perform once new lifetime is set</param>
            <returns>New lifetime definition which can be terminated in case of a race condition</returns>
        </member>
        <member name="T:JetBrains.Lifetimes.ValueLifetimed`1">
            <summary>
            Pair of lifetime and value
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="F:JetBrains.Serialization.NativeMemoryPool.ourBlocks">
            <summary>
            All allocated holders of native blocks. The array should be filled from the start.
            Lock policy: any modification of this array should be protected by <see cref="F:JetBrains.Serialization.NativeMemoryPool.ourLock"/>
            It is mandatory to reserve block before removing or replacing it from the array. Be aware, that it is valid to
            read this array without taking any lock
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.NativeMemoryPool.Reserve">
            <summary>
            Reserve an unmanaged block of memory size of <see cref="P:JetBrains.Serialization.NativeMemoryPool.Cookie.Length"/>.
            You use <see cref="P:JetBrains.Serialization.NativeMemoryPool.Cookie.Data"/> to obtain pointer. Always call Dispose on provided cookie to avoid memory leaks.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.NativeMemoryPool.TryFreeMemory">
            <summary>
            Tries to free one of the available pre-allocated native blocks.
            </summary>
            <returns>true if the block was deallocated, false if there are no such blocks.</returns>
        </member>
        <member name="F:JetBrains.Serialization.NativeMemoryPool.Cookie.CausedAllocation">
            <summary>
            Indicates whether a new native block was actually allocated to fulfil the request.
            When this property is set to true in returned Cookie, you become responsible for the allocated block
            in pool (which can be used by different features). But it is only your obligation to call
            <see cref="M:JetBrains.Serialization.NativeMemoryPool.TryFreeMemory"/> after lifetime of your feature has over.
            </summary>
        </member>
        <member name="T:JetBrains.Serialization.UnsafeReader">
            <summary>
            Deserialize data from byte buffer that was initially serialized by <see cref="T:JetBrains.Serialization.UnsafeWriter"/>
            <seealso cref="T:JetBrains.Serialization.UnsafeReader"/>
            
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeReader.ReadCollection``2(JetBrains.Serialization.UnsafeReader.ReadDelegate{``0},System.Func{System.Int32,``1})">
            <summary>
            Non optimal collection serialization. One can serialize internal structure (eg. array) instead.
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="TCol"></typeparam>
            <param name="readDelegate"></param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="T:JetBrains.Serialization.UnsafeWriter">
             <summary>
             Effective serialization tool. <see cref="T:JetBrains.Serialization.UnsafeWriter"/> is thread-bound automatically expandable and shrinkable
             byte buffer (with initial size of 1Mb). Entry point is <see cref="T:JetBrains.Serialization.UnsafeWriter.Cookie"/> obtained by  <see cref="M:JetBrains.Serialization.UnsafeWriter.NewThreadLocalWriter"/>.
             It is <see cref="T:System.IDisposable"/> so must be used only with (possibly nested) <c>using</c> in stack-like way.
             <see cref="T:JetBrains.Serialization.UnsafeWriter.Cookie"/> contains start position and length of currently serialized data (start + len = position), so when disposed it reverts writer
             position to the cookie's start position.
            
            
             <seealso cref="T:JetBrains.Serialization.UnsafeReader"/>
             </summary>
        </member>
        <member name="T:JetBrains.Serialization.UnsafeWriter.Bookmark">
            <summary>
            A bookmark to the offset in the memory block of the <see cref="T:JetBrains.Serialization.UnsafeWriter"/>. Can be used for saving address
            in UnsafeWriter for future use. Basically every method in <see cref="T:JetBrains.Serialization.UnsafeWriter"/> can cause reallocation of
            data. It is important to avoid storing pointers obtained from UnsafeWriter between these calls.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Bookmark.WriteIntLength">
            <summary>
            Writes `<see cref="P:JetBrains.Serialization.UnsafeWriter.Count"/><c> - sizeof(int)</c>` into the <see cref="P:JetBrains.Serialization.UnsafeWriter.Bookmark.Data"/> pointer. Cookie must be prepared by invoking `<see cref="M:JetBrains.Serialization.UnsafeWriter.Write(System.Int32)"/><c>(0)</c>` as first cookie call.
            </summary>
        </member>
        <member name="P:JetBrains.Serialization.UnsafeWriter.AllowUnsafeWriterCaching">
            <summary>
            Whether <see cref="T:JetBrains.Serialization.UnsafeWriter"/> can be cached for the specific thread.
            </summary>
        </member>
        <member name="F:JetBrains.Serialization.UnsafeWriter.ourWriter">
            <summary>
            Cached <see cref="T:JetBrains.Serialization.UnsafeWriter"/> for reuse
            </summary>
        </member>
        <member name="F:JetBrains.Serialization.UnsafeWriter.ReleaseResources">
            <summary>
            Indicates whether the UnsafeWriter should try to cleanup used memory in <see cref="T:JetBrains.Serialization.NativeMemoryPool"/> 
            </summary>
        </member>
        <member name="F:JetBrains.Serialization.UnsafeWriter.myMemory">
            <summary>
            Stores the last used memory holder. Be aware that this holder is not reserved for current unsafe writer only and
            in some circumstances may be used and reserved by other consumer (when it's free)
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Initialize">
            <summary>
            Creates a new UnsafeWriter
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.WriteStringContent(System.String,System.Int32,System.Int32)">
            <summary>
            Doesn't write length prefix, only string contents. If value == null, does nothing.
            </summary>
            <param name="value"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.MakeBookmark">
            <summary>
            Creates <see cref="T:JetBrains.Serialization.UnsafeWriter.Bookmark"/> for the current <see cref="T:JetBrains.Serialization.UnsafeWriter"/>'s position.
            </summary>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)">
            <summary>
            Correctly allocates the number of bytes as if they were written with any func, and advances the pointer past them.
            This is useful if you want to use buffer space for direct memory access.
            </summary>
            <remarks>
            Never save the value of <see cref="P:JetBrains.Serialization.UnsafeWriter.Ptr" /> before calling <see cref="M:JetBrains.Serialization.UnsafeWriter.Alloc(System.Int32)" />! This method may cause a reallocation
            of data after which the saved pointer became invalid.
            </remarks>
            <returns><see cref="T:JetBrains.Serialization.UnsafeWriter.Bookmark"/> to the allocated buffer </returns>
        </member>
        <member name="M:JetBrains.Serialization.UnsafeWriter.Write``2(JetBrains.Serialization.UnsafeWriter.WriteDelegate{``0},``1)">
            <summary>
            Non optimal collection serialization. You can serialize internal structure (eg. array) instead.
            </summary>
        </member>
        <member name="T:JetBrains.Threading.Actor`1">
            <summary>
            Actor is a channel with predefined (possible async) handler. All messages from the channel are
            processed sequentially so handling of new message from channel can only start when handling of previous one is completed.  
            </summary>
            <typeparam name="T">type of message</typeparam>
        </member>
        <member name="P:JetBrains.Threading.Actor`1.Channel">
            <summary>
            You can use this field for composing this actor's channel with other channels.
            <see cref="M:JetBrains.Threading.Actor`1.SendAsync(`0)"/> and <see cref="M:JetBrains.Threading.Actor`1.SendBlocking(`0)"/> simply delegates to it.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Actor`1.IsEmpty">
            <summary>
            Channel becomes empty when last message is processed and no new messages enqueued
            or when actor's lifetime is terminated.
            enqueued.
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Actor`1.IsNotEmpty">
            <summary>
            There are some messages that are not processed. Actor becomes not empty synchronously
            when one sends message to it. 
            </summary>
        </member>
        <member name="P:JetBrains.Threading.Actor`1.IsInsideProcessing">
            <summary>
            Returns true if called inside message processing (in logical flow / async locally).  
            <see cref="T:System.Threading.AsyncLocal`1"/>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.#ctor(System.String,JetBrains.Lifetimes.Lifetime,System.Action{`0},System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>
            Creates new actor with synchronous handler
            </summary>
            <param name="id">for logging purposes</param>
            <param name="lifetime">cancels all inner messages after this lifetime's termination and make this actor <see cref="P:JetBrains.Threading.Actor`1.IsEmpty"/></param>
            <param name="processor">handler of messages</param>
            <param name="scheduler"><paramref name="processor"/>'s body scheduler</param>
            <param name="maxQueueSize">upper bound for channel after that <see cref="M:JetBrains.Threading.Actor`1.SendBlocking(`0)"/> will block</param>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.#ctor(System.String,JetBrains.Lifetimes.Lifetime,System.Func{`0,System.Threading.Tasks.Task},System.Threading.Tasks.TaskScheduler,System.Int32)">
            <summary>
            Creates new actor with asynchronous handler
            </summary>
            <param name="id"></param>
            <param name="lifetime"></param>
            <param name="processor"></param>
            <param name="scheduler"></param>
            <param name="maxQueueSize"></param>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.SendBlocking(`0)">
            <summary>
            Send message to actor. If underlying channel is full than blocks.
            </summary>
            <param name="msg"></param>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.SendAsync(`0)">
            <summary>
            Send message to actor. If underlying channel is full than return task that will be completed when
            message is finally gets into buffer.
            
            Otherwise return <see cref="T:System.Threading.Tasks.Task"/>.<see cref="P:System.Threading.Tasks.Task.CompletedTask"/>
            </summary>
            <param name="msg"></param>
            <returns></returns>
            <remarks>Note than returned task completes when message is put into buffer, not when it's processed. </remarks>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.SendOrExecuteInline(`0)">
            <summary>
            If <see cref="P:JetBrains.Threading.Actor`1.IsInsideProcessing"/> is true than process message inline.
            Otherwise do <see cref="M:JetBrains.Threading.Actor`1.SendBlocking(`0)"/>.
            </summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:JetBrains.Threading.Actor`1.WaitForEmpty">
            <summary>
            Synchronously wait until <see cref="P:JetBrains.Threading.Actor`1.IsEmpty"/> is true
            </summary>
        </member>
        <member name="T:JetBrains.Threading.ByteBufferAsyncProcessor">
            <summary>
            Circular auto expandable and shrinkable byte buffer based on linked list of arrays with two roles:
            <list type="number">
            <item>Producers - fills buffer with <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte*,System.Int32)"/> method</item>
            <item>Consumer - process buffer in dedicated thread</item>
            </list>
            
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Start">
            <summary>
            Starts async processing of queue.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Stop(System.Int32)">
            <summary>
            Graceful stop. Process queue, but doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="M:JetBrains.Threading.ByteBufferAsyncProcessor.Terminate(System.Int32)">
            <summary>
            Force stop. Doesn't process queue, doesn't accept new data via <see cref="M:JetBrains.Threading.ByteBufferAsyncProcessor.Put(System.Byte[])"/>. Joins processing thread for given timeout. If timeout elapsed, aborts thread.
            </summary>
            <param name="timeoutMs">Timeout to wait. <see cref="F:System.Threading.Timeout.Infinite"/> for infinite waiting.</param>
            <returns>'true' if Join(timeoutMs) was successful, false otherwise. Also returns 'false' if thread is already stopped or killed."></returns>
        </member>
        <member name="T:JetBrains.Threading.AsyncChannel`1">
            <summary>
            The same as blocking queue but for non-blocking asynchronous world.
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:JetBrains.Threading.ExceptionEx.IsOperationCanceled(System.Exception)">
            <summary>
            Whether this exception is <see cref="T:System.OperationCanceledException"/> or <see cref="P:System.Exception.InnerException"/> is <see cref="T:System.OperationCanceledException"/>
            (e.g. <c>"TargetInvocationException"</c>) or Inner.Inner and so on.
            Or this exception is <see cref="T:System.AggregateException"/> that consists only from <see cref="T:System.OperationCanceledException"/> (or exception that has OCE as Inner exception).
            </summary>
            <param name="exception">exception to test or null</param>
            <returns>if <paramref name="exception"/> is null, returns false. Otherwise tries to run algorithm from the summary.</returns>
        </member>
        <member name="T:JetBrains.Threading.ProactiveLazy`1">
            <summary>
            Holder that starts evaluation immediately right in the constructor in background. 
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:JetBrains.Threading.SpinWaitEx">
            <summary>
            Extensions for <see cref="T:System.Threading.SpinWait"/> static methods.
            </summary>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="condition"/> is false.     
            </summary>
            <param name="condition">Stops spinning when condition is true</param>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(System.TimeSpan,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="timeout"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="timeout">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="timeout"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.TimeSpan,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeout"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeout">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeout"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntil(JetBrains.Lifetimes.Lifetime,System.Int64,System.Func{System.Boolean})">
            <summary>
            Spins while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.     
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns>    
        </member>
        <member name="M:JetBrains.Threading.SpinWaitEx.SpinUntilAsync(JetBrains.Lifetimes.Lifetime,System.Int64,System.Int32,System.Func{System.Boolean})">
            <summary>
            Spins in ASYNC manner (not consuming thread or CPU resources) while <paramref name="lifetime"/> is alive, <paramref name="timeoutMs"/> is not elapsed and <paramref name="condition"/> is false.
            Sleeps in async fashion (using <see cref="M:System.Threading.Tasks.Task.Delay(System.TimeSpan,System.Threading.CancellationToken)"/> for <paramref name="delayBetweenChecksMs"/> each time between <paramref name="condition"/> check.
            Only <paramref name="lifetime"/> cancellation could immediately return execution from delay. 
            </summary>
            <param name="lifetime">Stops spinning and return <c>false</c> when lifetime is no more alive</param>
            <param name="timeoutMs">Stops spinning and return <c>false</c> when timeout is alive</param>
            <param name="delayBetweenChecksMs">Interval to delay</param>
            <param name="condition">Stops spinning and return <c>false</c> when condition is true</param>
            <returns><c>false</c> if <paramref name="lifetime"/> is not alive or canceled during spinning, <paramref name="timeoutMs"/> is zero or elapsed during spinning.
            Otherwise <c>true</c> (when <paramref name="condition"/> returns true)</returns> 
        </member>
        <member name="M:JetBrains.Threading.TaskEx.NoAwait(System.Threading.Tasks.Task)">
            <summary>
              <para>Marks that this task is intentionally not awaited or continued-with.</para>
              <para>The task is let to run, its return value (if any) is abandoned, its exceptions are consumed by our logger.</para>
              <para>Prevents Compiler Warning (level 1) CS4014 “Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the 'await' operator to the result of the call.”</para>
            </summary>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.ToResultProperty``1(System.Threading.Tasks.Task{``0})">
            <summary>
            Transform this task into <see cref="T:JetBrains.Collections.Viewable.ViewableProperty`1"/>. Task could be finished by exception so we need
            </summary>
            <param name="task"></param>
            <typeparam name="T"></typeparam>
            <returns></returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.GetOrWait``1(System.Threading.Tasks.Task{``0},JetBrains.Lifetimes.Lifetime)">
            <summary>
            Waits for result of given task or throw <see cref="T:System.OperationCanceledException"/> 
            </summary>
            <param name="task">Task to wait</param>
            <param name="lifetime">Cancellation token for </param>
            <typeparam name="T"></typeparam>
            <returns><see cref="!:Task.Result"/> of <paramref name="task"/></returns>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.IsOperationCanceled(System.Threading.Tasks.Task)">
            <summary>
            Return true only if task finished and finished with exception that is or consists only from <see cref="T:System.OperationCanceledException"/>.
            Allow to dive through all <see cref="T:System.AggregateException"/> and Inner exceptions.
            </summary>
            <param name="task"></param>
            <returns>true only if task finished and resulting exception matches <see cref="M:JetBrains.Threading.ExceptionEx.IsOperationCanceled(System.Exception)"/></returns>
        </member>
        <member name="M:JetBrains.Threading.TaskEx.Select``2(System.Threading.Tasks.Task{``0},System.Func{``0,``1})">
            <summary>
            Transform result of original task right after it finished (with <see cref="M:System.Threading.Tasks.Task.ConfigureAwait(System.Boolean)"/> == false).
            If task is not successfully finished then throw original exception. 
            </summary>
            <param name="task">original task</param>
            <param name="selector">transform function from original type to destination one</param>
            <typeparam name="TSrc">original type</typeparam>
            <typeparam name="TDst">destination type</typeparam>
            <returns>new task that is considered completed right after original task completes</returns>
            <exception cref="T:System.ArgumentNullException"></exception>
        </member>
    </members>
</doc>
